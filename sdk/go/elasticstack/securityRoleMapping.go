// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package elasticstack

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manage role mappings. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role-mapping.html
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"encoding/json"
//
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		tmpJSON0, err := json.Marshal(map[string]interface{}{
// 			"any": []interface{}{
// 				map[string]interface{}{
// 					"field": map[string]interface{}{
// 						"username": "esadmin",
// 					},
// 				},
// 				map[string]interface{}{
// 					"field": map[string]interface{}{
// 						"groups": "cn=admins,dc=example,dc=com",
// 					},
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		json0 := string(tmpJSON0)
// 		example, err := elasticstack.NewSecurityRoleMapping(ctx, "example", &elasticstack.SecurityRoleMappingArgs{
// 			Enabled: pulumi.Bool(true),
// 			Roles: pulumi.StringArray{
// 				pulumi.String("admin"),
// 			},
// 			Rules: pulumi.String(json0),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		ctx.Export("role", example.Name)
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// ```sh
//  $ pulumi import elasticstack:index/securityRoleMapping:SecurityRoleMapping my_role_mapping <cluster_uuid>/<role mapping name>
// ```
type SecurityRoleMapping struct {
	pulumi.CustomResourceState

	// Elasticsearch connection configuration block.
	ElasticsearchConnection SecurityRoleMappingElasticsearchConnectionPtrOutput `pulumi:"elasticsearchConnection"`
	// Mappings that have `enabled` set to `false` are ignored when role mapping is performed.
	Enabled pulumi.BoolPtrOutput `pulumi:"enabled"`
	// Additional metadata that helps define which roles are assigned to each user. Keys beginning with `_` are reserved for system usage.
	Metadata pulumi.StringPtrOutput `pulumi:"metadata"`
	// The distinct name that identifies the role mapping, used solely as an identifier.
	Name pulumi.StringOutput `pulumi:"name"`
	// A list of mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.
	RoleTemplates pulumi.StringPtrOutput `pulumi:"roleTemplates"`
	// A list of role names that are granted to the users that match the role mapping rules.
	Roles pulumi.StringArrayOutput `pulumi:"roles"`
	// The rules that determine which users should be matched by the mapping. A rule is a logical condition that is expressed by using a JSON DSL.
	Rules pulumi.StringOutput `pulumi:"rules"`
}

// NewSecurityRoleMapping registers a new resource with the given unique name, arguments, and options.
func NewSecurityRoleMapping(ctx *pulumi.Context,
	name string, args *SecurityRoleMappingArgs, opts ...pulumi.ResourceOption) (*SecurityRoleMapping, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Rules == nil {
		return nil, errors.New("invalid value for required argument 'Rules'")
	}
	var resource SecurityRoleMapping
	err := ctx.RegisterResource("elasticstack:index/securityRoleMapping:SecurityRoleMapping", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSecurityRoleMapping gets an existing SecurityRoleMapping resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSecurityRoleMapping(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SecurityRoleMappingState, opts ...pulumi.ResourceOption) (*SecurityRoleMapping, error) {
	var resource SecurityRoleMapping
	err := ctx.ReadResource("elasticstack:index/securityRoleMapping:SecurityRoleMapping", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SecurityRoleMapping resources.
type securityRoleMappingState struct {
	// Elasticsearch connection configuration block.
	ElasticsearchConnection *SecurityRoleMappingElasticsearchConnection `pulumi:"elasticsearchConnection"`
	// Mappings that have `enabled` set to `false` are ignored when role mapping is performed.
	Enabled *bool `pulumi:"enabled"`
	// Additional metadata that helps define which roles are assigned to each user. Keys beginning with `_` are reserved for system usage.
	Metadata *string `pulumi:"metadata"`
	// The distinct name that identifies the role mapping, used solely as an identifier.
	Name *string `pulumi:"name"`
	// A list of mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.
	RoleTemplates *string `pulumi:"roleTemplates"`
	// A list of role names that are granted to the users that match the role mapping rules.
	Roles []string `pulumi:"roles"`
	// The rules that determine which users should be matched by the mapping. A rule is a logical condition that is expressed by using a JSON DSL.
	Rules *string `pulumi:"rules"`
}

type SecurityRoleMappingState struct {
	// Elasticsearch connection configuration block.
	ElasticsearchConnection SecurityRoleMappingElasticsearchConnectionPtrInput
	// Mappings that have `enabled` set to `false` are ignored when role mapping is performed.
	Enabled pulumi.BoolPtrInput
	// Additional metadata that helps define which roles are assigned to each user. Keys beginning with `_` are reserved for system usage.
	Metadata pulumi.StringPtrInput
	// The distinct name that identifies the role mapping, used solely as an identifier.
	Name pulumi.StringPtrInput
	// A list of mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.
	RoleTemplates pulumi.StringPtrInput
	// A list of role names that are granted to the users that match the role mapping rules.
	Roles pulumi.StringArrayInput
	// The rules that determine which users should be matched by the mapping. A rule is a logical condition that is expressed by using a JSON DSL.
	Rules pulumi.StringPtrInput
}

func (SecurityRoleMappingState) ElementType() reflect.Type {
	return reflect.TypeOf((*securityRoleMappingState)(nil)).Elem()
}

type securityRoleMappingArgs struct {
	// Elasticsearch connection configuration block.
	ElasticsearchConnection *SecurityRoleMappingElasticsearchConnection `pulumi:"elasticsearchConnection"`
	// Mappings that have `enabled` set to `false` are ignored when role mapping is performed.
	Enabled *bool `pulumi:"enabled"`
	// Additional metadata that helps define which roles are assigned to each user. Keys beginning with `_` are reserved for system usage.
	Metadata *string `pulumi:"metadata"`
	// The distinct name that identifies the role mapping, used solely as an identifier.
	Name *string `pulumi:"name"`
	// A list of mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.
	RoleTemplates *string `pulumi:"roleTemplates"`
	// A list of role names that are granted to the users that match the role mapping rules.
	Roles []string `pulumi:"roles"`
	// The rules that determine which users should be matched by the mapping. A rule is a logical condition that is expressed by using a JSON DSL.
	Rules string `pulumi:"rules"`
}

// The set of arguments for constructing a SecurityRoleMapping resource.
type SecurityRoleMappingArgs struct {
	// Elasticsearch connection configuration block.
	ElasticsearchConnection SecurityRoleMappingElasticsearchConnectionPtrInput
	// Mappings that have `enabled` set to `false` are ignored when role mapping is performed.
	Enabled pulumi.BoolPtrInput
	// Additional metadata that helps define which roles are assigned to each user. Keys beginning with `_` are reserved for system usage.
	Metadata pulumi.StringPtrInput
	// The distinct name that identifies the role mapping, used solely as an identifier.
	Name pulumi.StringPtrInput
	// A list of mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.
	RoleTemplates pulumi.StringPtrInput
	// A list of role names that are granted to the users that match the role mapping rules.
	Roles pulumi.StringArrayInput
	// The rules that determine which users should be matched by the mapping. A rule is a logical condition that is expressed by using a JSON DSL.
	Rules pulumi.StringInput
}

func (SecurityRoleMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*securityRoleMappingArgs)(nil)).Elem()
}

type SecurityRoleMappingInput interface {
	pulumi.Input

	ToSecurityRoleMappingOutput() SecurityRoleMappingOutput
	ToSecurityRoleMappingOutputWithContext(ctx context.Context) SecurityRoleMappingOutput
}

func (*SecurityRoleMapping) ElementType() reflect.Type {
	return reflect.TypeOf((**SecurityRoleMapping)(nil)).Elem()
}

func (i *SecurityRoleMapping) ToSecurityRoleMappingOutput() SecurityRoleMappingOutput {
	return i.ToSecurityRoleMappingOutputWithContext(context.Background())
}

func (i *SecurityRoleMapping) ToSecurityRoleMappingOutputWithContext(ctx context.Context) SecurityRoleMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecurityRoleMappingOutput)
}

// SecurityRoleMappingArrayInput is an input type that accepts SecurityRoleMappingArray and SecurityRoleMappingArrayOutput values.
// You can construct a concrete instance of `SecurityRoleMappingArrayInput` via:
//
//          SecurityRoleMappingArray{ SecurityRoleMappingArgs{...} }
type SecurityRoleMappingArrayInput interface {
	pulumi.Input

	ToSecurityRoleMappingArrayOutput() SecurityRoleMappingArrayOutput
	ToSecurityRoleMappingArrayOutputWithContext(context.Context) SecurityRoleMappingArrayOutput
}

type SecurityRoleMappingArray []SecurityRoleMappingInput

func (SecurityRoleMappingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SecurityRoleMapping)(nil)).Elem()
}

func (i SecurityRoleMappingArray) ToSecurityRoleMappingArrayOutput() SecurityRoleMappingArrayOutput {
	return i.ToSecurityRoleMappingArrayOutputWithContext(context.Background())
}

func (i SecurityRoleMappingArray) ToSecurityRoleMappingArrayOutputWithContext(ctx context.Context) SecurityRoleMappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecurityRoleMappingArrayOutput)
}

// SecurityRoleMappingMapInput is an input type that accepts SecurityRoleMappingMap and SecurityRoleMappingMapOutput values.
// You can construct a concrete instance of `SecurityRoleMappingMapInput` via:
//
//          SecurityRoleMappingMap{ "key": SecurityRoleMappingArgs{...} }
type SecurityRoleMappingMapInput interface {
	pulumi.Input

	ToSecurityRoleMappingMapOutput() SecurityRoleMappingMapOutput
	ToSecurityRoleMappingMapOutputWithContext(context.Context) SecurityRoleMappingMapOutput
}

type SecurityRoleMappingMap map[string]SecurityRoleMappingInput

func (SecurityRoleMappingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SecurityRoleMapping)(nil)).Elem()
}

func (i SecurityRoleMappingMap) ToSecurityRoleMappingMapOutput() SecurityRoleMappingMapOutput {
	return i.ToSecurityRoleMappingMapOutputWithContext(context.Background())
}

func (i SecurityRoleMappingMap) ToSecurityRoleMappingMapOutputWithContext(ctx context.Context) SecurityRoleMappingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecurityRoleMappingMapOutput)
}

type SecurityRoleMappingOutput struct{ *pulumi.OutputState }

func (SecurityRoleMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SecurityRoleMapping)(nil)).Elem()
}

func (o SecurityRoleMappingOutput) ToSecurityRoleMappingOutput() SecurityRoleMappingOutput {
	return o
}

func (o SecurityRoleMappingOutput) ToSecurityRoleMappingOutputWithContext(ctx context.Context) SecurityRoleMappingOutput {
	return o
}

// Elasticsearch connection configuration block.
func (o SecurityRoleMappingOutput) ElasticsearchConnection() SecurityRoleMappingElasticsearchConnectionPtrOutput {
	return o.ApplyT(func(v *SecurityRoleMapping) SecurityRoleMappingElasticsearchConnectionPtrOutput {
		return v.ElasticsearchConnection
	}).(SecurityRoleMappingElasticsearchConnectionPtrOutput)
}

// Mappings that have `enabled` set to `false` are ignored when role mapping is performed.
func (o SecurityRoleMappingOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecurityRoleMapping) pulumi.BoolPtrOutput { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// Additional metadata that helps define which roles are assigned to each user. Keys beginning with `_` are reserved for system usage.
func (o SecurityRoleMappingOutput) Metadata() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SecurityRoleMapping) pulumi.StringPtrOutput { return v.Metadata }).(pulumi.StringPtrOutput)
}

// The distinct name that identifies the role mapping, used solely as an identifier.
func (o SecurityRoleMappingOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SecurityRoleMapping) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// A list of mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.
func (o SecurityRoleMappingOutput) RoleTemplates() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SecurityRoleMapping) pulumi.StringPtrOutput { return v.RoleTemplates }).(pulumi.StringPtrOutput)
}

// A list of role names that are granted to the users that match the role mapping rules.
func (o SecurityRoleMappingOutput) Roles() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SecurityRoleMapping) pulumi.StringArrayOutput { return v.Roles }).(pulumi.StringArrayOutput)
}

// The rules that determine which users should be matched by the mapping. A rule is a logical condition that is expressed by using a JSON DSL.
func (o SecurityRoleMappingOutput) Rules() pulumi.StringOutput {
	return o.ApplyT(func(v *SecurityRoleMapping) pulumi.StringOutput { return v.Rules }).(pulumi.StringOutput)
}

type SecurityRoleMappingArrayOutput struct{ *pulumi.OutputState }

func (SecurityRoleMappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SecurityRoleMapping)(nil)).Elem()
}

func (o SecurityRoleMappingArrayOutput) ToSecurityRoleMappingArrayOutput() SecurityRoleMappingArrayOutput {
	return o
}

func (o SecurityRoleMappingArrayOutput) ToSecurityRoleMappingArrayOutputWithContext(ctx context.Context) SecurityRoleMappingArrayOutput {
	return o
}

func (o SecurityRoleMappingArrayOutput) Index(i pulumi.IntInput) SecurityRoleMappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SecurityRoleMapping {
		return vs[0].([]*SecurityRoleMapping)[vs[1].(int)]
	}).(SecurityRoleMappingOutput)
}

type SecurityRoleMappingMapOutput struct{ *pulumi.OutputState }

func (SecurityRoleMappingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SecurityRoleMapping)(nil)).Elem()
}

func (o SecurityRoleMappingMapOutput) ToSecurityRoleMappingMapOutput() SecurityRoleMappingMapOutput {
	return o
}

func (o SecurityRoleMappingMapOutput) ToSecurityRoleMappingMapOutputWithContext(ctx context.Context) SecurityRoleMappingMapOutput {
	return o
}

func (o SecurityRoleMappingMapOutput) MapIndex(k pulumi.StringInput) SecurityRoleMappingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SecurityRoleMapping {
		return vs[0].(map[string]*SecurityRoleMapping)[vs[1].(string)]
	}).(SecurityRoleMappingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SecurityRoleMappingInput)(nil)).Elem(), &SecurityRoleMapping{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecurityRoleMappingArrayInput)(nil)).Elem(), SecurityRoleMappingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecurityRoleMappingMapInput)(nil)).Elem(), SecurityRoleMappingMap{})
	pulumi.RegisterOutputType(SecurityRoleMappingOutput{})
	pulumi.RegisterOutputType(SecurityRoleMappingArrayOutput{})
	pulumi.RegisterOutputType(SecurityRoleMappingMapOutput{})
}
