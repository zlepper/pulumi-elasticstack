// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package elasticstack

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates or updates lifecycle policy. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-put-lifecycle.html and https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-index-lifecycle.html
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"encoding/json"
//
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		tmpJSON0, err := json.Marshal(map[string]interface{}{
// 			"box_type": "hot",
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		json0 := string(tmpJSON0)
// 		_, err = elasticstack.NewIndexLifecycle(ctx, "myIlm", &elasticstack.IndexLifecycleArgs{
// 			Hot: &elasticstack.IndexLifecycleHotArgs{
// 				MinAge: pulumi.String("1h"),
// 				SetPriority: &elasticstack.IndexLifecycleHotSetPriorityArgs{
// 					Priority: pulumi.Int(0),
// 				},
// 				Rollover: &elasticstack.IndexLifecycleHotRolloverArgs{
// 					MaxAge: pulumi.String("1d"),
// 				},
// 				Readonly: nil,
// 			},
// 			Warm: &elasticstack.IndexLifecycleWarmArgs{
// 				MinAge: pulumi.String("0ms"),
// 				SetPriority: &elasticstack.IndexLifecycleWarmSetPriorityArgs{
// 					Priority: pulumi.Int(10),
// 				},
// 				Readonly: nil,
// 				Allocate: &elasticstack.IndexLifecycleWarmAllocateArgs{
// 					Exclude:            pulumi.String(json0),
// 					NumberOfReplicas:   pulumi.Int(1),
// 					TotalShardsPerNode: pulumi.Int(200),
// 				},
// 			},
// 			Delete: &elasticstack.IndexLifecycleDeleteArgs{
// 				MinAge: pulumi.String("2d"),
// 				Delete: nil,
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// ```sh
//  $ pulumi import elasticstack:index/indexLifecycle:IndexLifecycle my_ilm <cluster_uuid>/<ilm_name>
// ```
type IndexLifecycle struct {
	pulumi.CustomResourceState

	// The index is no longer being updated and is queried infrequently. The information still needs to be searchable, but it’s okay if those queries are slower.
	Cold IndexLifecycleColdPtrOutput `pulumi:"cold"`
	// The index is no longer needed and can safely be removed.
	Delete IndexLifecycleDeletePtrOutput `pulumi:"delete"`
	// Elasticsearch connection configuration block.
	ElasticsearchConnection IndexLifecycleElasticsearchConnectionPtrOutput `pulumi:"elasticsearchConnection"`
	// The index is no longer being updated and is queried rarely. The information still needs to be searchable, but it’s okay if those queries are extremely slow.
	Frozen IndexLifecycleFrozenPtrOutput `pulumi:"frozen"`
	// The index is actively being updated and queried.
	Hot IndexLifecycleHotPtrOutput `pulumi:"hot"`
	// Optional user metadata about the ilm policy. Must be valid JSON document.
	Metadata pulumi.StringPtrOutput `pulumi:"metadata"`
	// The DateTime of the last modification.
	ModifiedDate pulumi.StringOutput `pulumi:"modifiedDate"`
	// Identifier for the policy.
	Name pulumi.StringOutput `pulumi:"name"`
	// The index is no longer being updated but is still being queried.
	Warm IndexLifecycleWarmPtrOutput `pulumi:"warm"`
}

// NewIndexLifecycle registers a new resource with the given unique name, arguments, and options.
func NewIndexLifecycle(ctx *pulumi.Context,
	name string, args *IndexLifecycleArgs, opts ...pulumi.ResourceOption) (*IndexLifecycle, error) {
	if args == nil {
		args = &IndexLifecycleArgs{}
	}

	var resource IndexLifecycle
	err := ctx.RegisterResource("elasticstack:index/indexLifecycle:IndexLifecycle", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIndexLifecycle gets an existing IndexLifecycle resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIndexLifecycle(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IndexLifecycleState, opts ...pulumi.ResourceOption) (*IndexLifecycle, error) {
	var resource IndexLifecycle
	err := ctx.ReadResource("elasticstack:index/indexLifecycle:IndexLifecycle", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IndexLifecycle resources.
type indexLifecycleState struct {
	// The index is no longer being updated and is queried infrequently. The information still needs to be searchable, but it’s okay if those queries are slower.
	Cold *IndexLifecycleCold `pulumi:"cold"`
	// The index is no longer needed and can safely be removed.
	Delete *IndexLifecycleDelete `pulumi:"delete"`
	// Elasticsearch connection configuration block.
	ElasticsearchConnection *IndexLifecycleElasticsearchConnection `pulumi:"elasticsearchConnection"`
	// The index is no longer being updated and is queried rarely. The information still needs to be searchable, but it’s okay if those queries are extremely slow.
	Frozen *IndexLifecycleFrozen `pulumi:"frozen"`
	// The index is actively being updated and queried.
	Hot *IndexLifecycleHot `pulumi:"hot"`
	// Optional user metadata about the ilm policy. Must be valid JSON document.
	Metadata *string `pulumi:"metadata"`
	// The DateTime of the last modification.
	ModifiedDate *string `pulumi:"modifiedDate"`
	// Identifier for the policy.
	Name *string `pulumi:"name"`
	// The index is no longer being updated but is still being queried.
	Warm *IndexLifecycleWarm `pulumi:"warm"`
}

type IndexLifecycleState struct {
	// The index is no longer being updated and is queried infrequently. The information still needs to be searchable, but it’s okay if those queries are slower.
	Cold IndexLifecycleColdPtrInput
	// The index is no longer needed and can safely be removed.
	Delete IndexLifecycleDeletePtrInput
	// Elasticsearch connection configuration block.
	ElasticsearchConnection IndexLifecycleElasticsearchConnectionPtrInput
	// The index is no longer being updated and is queried rarely. The information still needs to be searchable, but it’s okay if those queries are extremely slow.
	Frozen IndexLifecycleFrozenPtrInput
	// The index is actively being updated and queried.
	Hot IndexLifecycleHotPtrInput
	// Optional user metadata about the ilm policy. Must be valid JSON document.
	Metadata pulumi.StringPtrInput
	// The DateTime of the last modification.
	ModifiedDate pulumi.StringPtrInput
	// Identifier for the policy.
	Name pulumi.StringPtrInput
	// The index is no longer being updated but is still being queried.
	Warm IndexLifecycleWarmPtrInput
}

func (IndexLifecycleState) ElementType() reflect.Type {
	return reflect.TypeOf((*indexLifecycleState)(nil)).Elem()
}

type indexLifecycleArgs struct {
	// The index is no longer being updated and is queried infrequently. The information still needs to be searchable, but it’s okay if those queries are slower.
	Cold *IndexLifecycleCold `pulumi:"cold"`
	// The index is no longer needed and can safely be removed.
	Delete *IndexLifecycleDelete `pulumi:"delete"`
	// Elasticsearch connection configuration block.
	ElasticsearchConnection *IndexLifecycleElasticsearchConnection `pulumi:"elasticsearchConnection"`
	// The index is no longer being updated and is queried rarely. The information still needs to be searchable, but it’s okay if those queries are extremely slow.
	Frozen *IndexLifecycleFrozen `pulumi:"frozen"`
	// The index is actively being updated and queried.
	Hot *IndexLifecycleHot `pulumi:"hot"`
	// Optional user metadata about the ilm policy. Must be valid JSON document.
	Metadata *string `pulumi:"metadata"`
	// Identifier for the policy.
	Name *string `pulumi:"name"`
	// The index is no longer being updated but is still being queried.
	Warm *IndexLifecycleWarm `pulumi:"warm"`
}

// The set of arguments for constructing a IndexLifecycle resource.
type IndexLifecycleArgs struct {
	// The index is no longer being updated and is queried infrequently. The information still needs to be searchable, but it’s okay if those queries are slower.
	Cold IndexLifecycleColdPtrInput
	// The index is no longer needed and can safely be removed.
	Delete IndexLifecycleDeletePtrInput
	// Elasticsearch connection configuration block.
	ElasticsearchConnection IndexLifecycleElasticsearchConnectionPtrInput
	// The index is no longer being updated and is queried rarely. The information still needs to be searchable, but it’s okay if those queries are extremely slow.
	Frozen IndexLifecycleFrozenPtrInput
	// The index is actively being updated and queried.
	Hot IndexLifecycleHotPtrInput
	// Optional user metadata about the ilm policy. Must be valid JSON document.
	Metadata pulumi.StringPtrInput
	// Identifier for the policy.
	Name pulumi.StringPtrInput
	// The index is no longer being updated but is still being queried.
	Warm IndexLifecycleWarmPtrInput
}

func (IndexLifecycleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*indexLifecycleArgs)(nil)).Elem()
}

type IndexLifecycleInput interface {
	pulumi.Input

	ToIndexLifecycleOutput() IndexLifecycleOutput
	ToIndexLifecycleOutputWithContext(ctx context.Context) IndexLifecycleOutput
}

func (*IndexLifecycle) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexLifecycle)(nil)).Elem()
}

func (i *IndexLifecycle) ToIndexLifecycleOutput() IndexLifecycleOutput {
	return i.ToIndexLifecycleOutputWithContext(context.Background())
}

func (i *IndexLifecycle) ToIndexLifecycleOutputWithContext(ctx context.Context) IndexLifecycleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexLifecycleOutput)
}

// IndexLifecycleArrayInput is an input type that accepts IndexLifecycleArray and IndexLifecycleArrayOutput values.
// You can construct a concrete instance of `IndexLifecycleArrayInput` via:
//
//          IndexLifecycleArray{ IndexLifecycleArgs{...} }
type IndexLifecycleArrayInput interface {
	pulumi.Input

	ToIndexLifecycleArrayOutput() IndexLifecycleArrayOutput
	ToIndexLifecycleArrayOutputWithContext(context.Context) IndexLifecycleArrayOutput
}

type IndexLifecycleArray []IndexLifecycleInput

func (IndexLifecycleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IndexLifecycle)(nil)).Elem()
}

func (i IndexLifecycleArray) ToIndexLifecycleArrayOutput() IndexLifecycleArrayOutput {
	return i.ToIndexLifecycleArrayOutputWithContext(context.Background())
}

func (i IndexLifecycleArray) ToIndexLifecycleArrayOutputWithContext(ctx context.Context) IndexLifecycleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexLifecycleArrayOutput)
}

// IndexLifecycleMapInput is an input type that accepts IndexLifecycleMap and IndexLifecycleMapOutput values.
// You can construct a concrete instance of `IndexLifecycleMapInput` via:
//
//          IndexLifecycleMap{ "key": IndexLifecycleArgs{...} }
type IndexLifecycleMapInput interface {
	pulumi.Input

	ToIndexLifecycleMapOutput() IndexLifecycleMapOutput
	ToIndexLifecycleMapOutputWithContext(context.Context) IndexLifecycleMapOutput
}

type IndexLifecycleMap map[string]IndexLifecycleInput

func (IndexLifecycleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IndexLifecycle)(nil)).Elem()
}

func (i IndexLifecycleMap) ToIndexLifecycleMapOutput() IndexLifecycleMapOutput {
	return i.ToIndexLifecycleMapOutputWithContext(context.Background())
}

func (i IndexLifecycleMap) ToIndexLifecycleMapOutputWithContext(ctx context.Context) IndexLifecycleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexLifecycleMapOutput)
}

type IndexLifecycleOutput struct{ *pulumi.OutputState }

func (IndexLifecycleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexLifecycle)(nil)).Elem()
}

func (o IndexLifecycleOutput) ToIndexLifecycleOutput() IndexLifecycleOutput {
	return o
}

func (o IndexLifecycleOutput) ToIndexLifecycleOutputWithContext(ctx context.Context) IndexLifecycleOutput {
	return o
}

// The index is no longer being updated and is queried infrequently. The information still needs to be searchable, but it’s okay if those queries are slower.
func (o IndexLifecycleOutput) Cold() IndexLifecycleColdPtrOutput {
	return o.ApplyT(func(v *IndexLifecycle) IndexLifecycleColdPtrOutput { return v.Cold }).(IndexLifecycleColdPtrOutput)
}

// The index is no longer needed and can safely be removed.
func (o IndexLifecycleOutput) Delete() IndexLifecycleDeletePtrOutput {
	return o.ApplyT(func(v *IndexLifecycle) IndexLifecycleDeletePtrOutput { return v.Delete }).(IndexLifecycleDeletePtrOutput)
}

// Elasticsearch connection configuration block.
func (o IndexLifecycleOutput) ElasticsearchConnection() IndexLifecycleElasticsearchConnectionPtrOutput {
	return o.ApplyT(func(v *IndexLifecycle) IndexLifecycleElasticsearchConnectionPtrOutput {
		return v.ElasticsearchConnection
	}).(IndexLifecycleElasticsearchConnectionPtrOutput)
}

// The index is no longer being updated and is queried rarely. The information still needs to be searchable, but it’s okay if those queries are extremely slow.
func (o IndexLifecycleOutput) Frozen() IndexLifecycleFrozenPtrOutput {
	return o.ApplyT(func(v *IndexLifecycle) IndexLifecycleFrozenPtrOutput { return v.Frozen }).(IndexLifecycleFrozenPtrOutput)
}

// The index is actively being updated and queried.
func (o IndexLifecycleOutput) Hot() IndexLifecycleHotPtrOutput {
	return o.ApplyT(func(v *IndexLifecycle) IndexLifecycleHotPtrOutput { return v.Hot }).(IndexLifecycleHotPtrOutput)
}

// Optional user metadata about the ilm policy. Must be valid JSON document.
func (o IndexLifecycleOutput) Metadata() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexLifecycle) pulumi.StringPtrOutput { return v.Metadata }).(pulumi.StringPtrOutput)
}

// The DateTime of the last modification.
func (o IndexLifecycleOutput) ModifiedDate() pulumi.StringOutput {
	return o.ApplyT(func(v *IndexLifecycle) pulumi.StringOutput { return v.ModifiedDate }).(pulumi.StringOutput)
}

// Identifier for the policy.
func (o IndexLifecycleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *IndexLifecycle) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The index is no longer being updated but is still being queried.
func (o IndexLifecycleOutput) Warm() IndexLifecycleWarmPtrOutput {
	return o.ApplyT(func(v *IndexLifecycle) IndexLifecycleWarmPtrOutput { return v.Warm }).(IndexLifecycleWarmPtrOutput)
}

type IndexLifecycleArrayOutput struct{ *pulumi.OutputState }

func (IndexLifecycleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IndexLifecycle)(nil)).Elem()
}

func (o IndexLifecycleArrayOutput) ToIndexLifecycleArrayOutput() IndexLifecycleArrayOutput {
	return o
}

func (o IndexLifecycleArrayOutput) ToIndexLifecycleArrayOutputWithContext(ctx context.Context) IndexLifecycleArrayOutput {
	return o
}

func (o IndexLifecycleArrayOutput) Index(i pulumi.IntInput) IndexLifecycleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *IndexLifecycle {
		return vs[0].([]*IndexLifecycle)[vs[1].(int)]
	}).(IndexLifecycleOutput)
}

type IndexLifecycleMapOutput struct{ *pulumi.OutputState }

func (IndexLifecycleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IndexLifecycle)(nil)).Elem()
}

func (o IndexLifecycleMapOutput) ToIndexLifecycleMapOutput() IndexLifecycleMapOutput {
	return o
}

func (o IndexLifecycleMapOutput) ToIndexLifecycleMapOutputWithContext(ctx context.Context) IndexLifecycleMapOutput {
	return o
}

func (o IndexLifecycleMapOutput) MapIndex(k pulumi.StringInput) IndexLifecycleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *IndexLifecycle {
		return vs[0].(map[string]*IndexLifecycle)[vs[1].(string)]
	}).(IndexLifecycleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IndexLifecycleInput)(nil)).Elem(), &IndexLifecycle{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexLifecycleArrayInput)(nil)).Elem(), IndexLifecycleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexLifecycleMapInput)(nil)).Elem(), IndexLifecycleMap{})
	pulumi.RegisterOutputType(IndexLifecycleOutput{})
	pulumi.RegisterOutputType(IndexLifecycleArrayOutput{})
	pulumi.RegisterOutputType(IndexLifecycleMapOutput{})
}
