// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Elasticstack
{
    /// <summary>
    /// Creates or updates an index. This resource can define settings, mappings and aliases. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html
    /// 
    /// ## Import
    /// 
    /// You can later adjust the index configuration to account for those imported settings. Some of the default settings, which could be imported are`index.number_of_replicas`, `index.number_of_shards` and `index.routing.allocation.include._tier_preference`. NOTEwhile importing index resource, keep in mind, that some of the default index settings will be imported into the TF state too You can later adjust the index configuration to account for those imported settings
    /// 
    /// ```sh
    ///  $ pulumi import elasticstack:index/index:Index my_index &lt;cluster_uuid&gt;/&lt;index_name&gt;
    /// ```
    /// </summary>
    [ElasticstackResourceType("elasticstack:index/index:Index")]
    public partial class Index : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Aliases for the index.
        /// </summary>
        [Output("aliases")]
        public Output<ImmutableArray<Outputs.IndexAlias>> Aliases { get; private set; } = null!;

        /// <summary>
        /// A JSON string describing the analyzers applied to the index.
        /// </summary>
        [Output("analysisAnalyzer")]
        public Output<string?> AnalysisAnalyzer { get; private set; } = null!;

        /// <summary>
        /// A JSON string describing the char_filters applied to the index.
        /// </summary>
        [Output("analysisCharFilter")]
        public Output<string?> AnalysisCharFilter { get; private set; } = null!;

        /// <summary>
        /// A JSON string describing the filters applied to the index.
        /// </summary>
        [Output("analysisFilter")]
        public Output<string?> AnalysisFilter { get; private set; } = null!;

        /// <summary>
        /// A JSON string describing the normalizers applied to the index.
        /// </summary>
        [Output("analysisNormalizer")]
        public Output<string?> AnalysisNormalizer { get; private set; } = null!;

        /// <summary>
        /// A JSON string describing the tokenizers applied to the index.
        /// </summary>
        [Output("analysisTokenizer")]
        public Output<string?> AnalysisTokenizer { get; private set; } = null!;

        /// <summary>
        /// The maximum number of tokens that can be produced using _analyze API.
        /// </summary>
        [Output("analyzeMaxTokenCount")]
        public Output<int?> AnalyzeMaxTokenCount { get; private set; } = null!;

        /// <summary>
        /// Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)
        /// </summary>
        [Output("autoExpandReplicas")]
        public Output<string?> AutoExpandReplicas { get; private set; } = null!;

        /// <summary>
        /// Set to `true` to disable index metadata reads and writes.
        /// </summary>
        [Output("blocksMetadata")]
        public Output<bool?> BlocksMetadata { get; private set; } = null!;

        /// <summary>
        /// Set to `true` to disable read operations against the index.
        /// </summary>
        [Output("blocksRead")]
        public Output<bool?> BlocksRead { get; private set; } = null!;

        /// <summary>
        /// Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.
        /// </summary>
        [Output("blocksReadOnly")]
        public Output<bool?> BlocksReadOnly { get; private set; } = null!;

        /// <summary>
        /// Identical to `index.blocks.read_only` but allows deleting the index to free up resources.
        /// </summary>
        [Output("blocksReadOnlyAllowDelete")]
        public Output<bool?> BlocksReadOnlyAllowDelete { get; private set; } = null!;

        /// <summary>
        /// Set to `true` to disable data write operations against the index. This setting does not affect metadata.
        /// </summary>
        [Output("blocksWrite")]
        public Output<bool?> BlocksWrite { get; private set; } = null!;

        /// <summary>
        /// The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.
        /// </summary>
        [Output("codec")]
        public Output<string?> Codec { get; private set; } = null!;

        /// <summary>
        /// The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.
        /// </summary>
        [Output("defaultPipeline")]
        public Output<string?> DefaultPipeline { get; private set; } = null!;

        /// <summary>
        /// Elasticsearch connection configuration block.
        /// </summary>
        [Output("elasticsearchConnection")]
        public Output<Outputs.IndexElasticsearchConnection?> ElasticsearchConnection { get; private set; } = null!;

        /// <summary>
        /// Final ingest pipeline for the index. Indexing requests will fail if the final pipeline is set and the pipeline does not exist. The final pipeline always runs after the request pipeline (if specified) and the default pipeline (if it exists). The special pipeline name _none indicates no ingest pipeline will run.
        /// </summary>
        [Output("finalPipeline")]
        public Output<string?> FinalPipeline { get; private set; } = null!;

        /// <summary>
        /// The length of time that a deleted document's version number remains available for further versioned operations.
        /// </summary>
        [Output("gcDeletes")]
        public Output<string?> GcDeletes { get; private set; } = null!;

        /// <summary>
        /// The maximum number of characters that will be analyzed for a highlight request.
        /// </summary>
        [Output("highlightMaxAnalyzedOffset")]
        public Output<int?> HighlightMaxAnalyzedOffset { get; private set; } = null!;

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Output("indexingSlowlogLevel")]
        public Output<string?> IndexingSlowlogLevel { get; private set; } = null!;

        /// <summary>
        /// Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.
        /// </summary>
        [Output("indexingSlowlogSource")]
        public Output<string?> IndexingSlowlogSource { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`
        /// </summary>
        [Output("indexingSlowlogThresholdIndexDebug")]
        public Output<string?> IndexingSlowlogThresholdIndexDebug { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`
        /// </summary>
        [Output("indexingSlowlogThresholdIndexInfo")]
        public Output<string?> IndexingSlowlogThresholdIndexInfo { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`
        /// </summary>
        [Output("indexingSlowlogThresholdIndexTrace")]
        public Output<string?> IndexingSlowlogThresholdIndexTrace { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`
        /// </summary>
        [Output("indexingSlowlogThresholdIndexWarn")]
        public Output<string?> IndexingSlowlogThresholdIndexWarn { get; private set; } = null!;

        /// <summary>
        /// Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.
        /// </summary>
        [Output("loadFixedBitsetFiltersEagerly")]
        public Output<bool?> LoadFixedBitsetFiltersEagerly { get; private set; } = null!;

        /// <summary>
        /// Mapping for fields in the index.
        /// If specified, this mapping can include: field names, [field data types](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html), [mapping parameters](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html).
        /// **NOTE:** changing datatypes in the existing *mappings* will force index to be re-created.
        /// </summary>
        [Output("mappings")]
        public Output<string?> Mappings { get; private set; } = null!;

        /// <summary>
        /// The maximum number of `docvalue_fields` that are allowed in a query.
        /// </summary>
        [Output("maxDocvalueFieldsSearch")]
        public Output<int?> MaxDocvalueFieldsSearch { get; private set; } = null!;

        /// <summary>
        /// The maximum value of `from + size` for inner hits definition and top hits aggregations to this index.
        /// </summary>
        [Output("maxInnerResultWindow")]
        public Output<int?> MaxInnerResultWindow { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter.
        /// </summary>
        [Output("maxNgramDiff")]
        public Output<int?> MaxNgramDiff { get; private set; } = null!;

        /// <summary>
        /// Maximum number of refresh listeners available on each shard of the index.
        /// </summary>
        [Output("maxRefreshListeners")]
        public Output<int?> MaxRefreshListeners { get; private set; } = null!;

        /// <summary>
        /// The maximum length of regex that can be used in Regexp Query.
        /// </summary>
        [Output("maxRegexLength")]
        public Output<int?> MaxRegexLength { get; private set; } = null!;

        /// <summary>
        /// The maximum value of `window_size` for `rescore` requests in searches of this index.
        /// </summary>
        [Output("maxRescoreWindow")]
        public Output<int?> MaxRescoreWindow { get; private set; } = null!;

        /// <summary>
        /// The maximum value of `from + size` for searches to this index.
        /// </summary>
        [Output("maxResultWindow")]
        public Output<int?> MaxResultWindow { get; private set; } = null!;

        /// <summary>
        /// The maximum number of `script_fields` that are allowed in a query.
        /// </summary>
        [Output("maxScriptFields")]
        public Output<int?> MaxScriptFields { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter.
        /// </summary>
        [Output("maxShingleDiff")]
        public Output<int?> MaxShingleDiff { get; private set; } = null!;

        /// <summary>
        /// The maximum number of terms that can be used in Terms Query.
        /// </summary>
        [Output("maxTermsCount")]
        public Output<int?> MaxTermsCount { get; private set; } = null!;

        /// <summary>
        /// Name of the index you wish to create.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Number of shard replicas.
        /// </summary>
        [Output("numberOfReplicas")]
        public Output<int> NumberOfReplicas { get; private set; } = null!;

        /// <summary>
        /// Value used with number*of*shards to route documents to a primary shard. This can be set only on creation.
        /// </summary>
        [Output("numberOfRoutingShards")]
        public Output<int?> NumberOfRoutingShards { get; private set; } = null!;

        /// <summary>
        /// Number of shards for the index. This can be set only on creation.
        /// </summary>
        [Output("numberOfShards")]
        public Output<int?> NumberOfShards { get; private set; } = null!;

        /// <summary>
        /// Wildcard (*) patterns matching one or more fields. Defaults to '*', which matches all fields eligible for term-level queries, excluding metadata fields.
        /// </summary>
        [Output("queryDefaultFields")]
        public Output<ImmutableArray<string>> QueryDefaultFields { get; private set; } = null!;

        /// <summary>
        /// How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.
        /// </summary>
        [Output("refreshInterval")]
        public Output<string?> RefreshInterval { get; private set; } = null!;

        /// <summary>
        /// Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.
        /// </summary>
        [Output("routingAllocationEnable")]
        public Output<string?> RoutingAllocationEnable { get; private set; } = null!;

        /// <summary>
        /// The number of shards a custom routing value can go to. This can be set only on creation.
        /// </summary>
        [Output("routingPartitionSize")]
        public Output<int?> RoutingPartitionSize { get; private set; } = null!;

        /// <summary>
        /// Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.
        /// </summary>
        [Output("routingRebalanceEnable")]
        public Output<string?> RoutingRebalanceEnable { get; private set; } = null!;

        /// <summary>
        /// How long a shard can not receive a search or get request until it’s considered search idle.
        /// </summary>
        [Output("searchIdleAfter")]
        public Output<string?> SearchIdleAfter { get; private set; } = null!;

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Output("searchSlowlogLevel")]
        public Output<string?> SearchSlowlogLevel { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`
        /// </summary>
        [Output("searchSlowlogThresholdFetchDebug")]
        public Output<string?> SearchSlowlogThresholdFetchDebug { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`
        /// </summary>
        [Output("searchSlowlogThresholdFetchInfo")]
        public Output<string?> SearchSlowlogThresholdFetchInfo { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`
        /// </summary>
        [Output("searchSlowlogThresholdFetchTrace")]
        public Output<string?> SearchSlowlogThresholdFetchTrace { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`
        /// </summary>
        [Output("searchSlowlogThresholdFetchWarn")]
        public Output<string?> SearchSlowlogThresholdFetchWarn { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`
        /// </summary>
        [Output("searchSlowlogThresholdQueryDebug")]
        public Output<string?> SearchSlowlogThresholdQueryDebug { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`
        /// </summary>
        [Output("searchSlowlogThresholdQueryInfo")]
        public Output<string?> SearchSlowlogThresholdQueryInfo { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`
        /// </summary>
        [Output("searchSlowlogThresholdQueryTrace")]
        public Output<string?> SearchSlowlogThresholdQueryTrace { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`
        /// </summary>
        [Output("searchSlowlogThresholdQueryWarn")]
        public Output<string?> SearchSlowlogThresholdQueryWarn { get; private set; } = null!;

        /// <summary>
        /// DEPRECATED: Please use dedicated setting field. Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings.
        /// **NOTE:** Static index settings (see: https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#*static*index_settings) can be only set on the index creation and later cannot be removed or updated - *apply* will return error
        /// </summary>
        [Output("settings")]
        public Output<Outputs.IndexSettings?> Settings { get; private set; } = null!;

        /// <summary>
        /// All raw settings fetched from the cluster.
        /// </summary>
        [Output("settingsRaw")]
        public Output<string> SettingsRaw { get; private set; } = null!;

        /// <summary>
        /// Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.
        /// </summary>
        [Output("shardCheckOnStartup")]
        public Output<string?> ShardCheckOnStartup { get; private set; } = null!;

        /// <summary>
        /// The field to sort shards in this index by.
        /// </summary>
        [Output("sortFields")]
        public Output<ImmutableArray<string>> SortFields { get; private set; } = null!;

        /// <summary>
        /// The direction to sort shards in. Accepts `asc`, `desc`.
        /// </summary>
        [Output("sortOrders")]
        public Output<ImmutableArray<string>> SortOrders { get; private set; } = null!;

        /// <summary>
        /// Time to delay the allocation of replica shards which become unassigned because a node has left, in time units, e.g. `10s`
        /// </summary>
        [Output("unassignedNodeLeftDelayedTimeout")]
        public Output<string?> UnassignedNodeLeftDelayedTimeout { get; private set; } = null!;


        /// <summary>
        /// Create a Index resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Index(string name, IndexArgs? args = null, CustomResourceOptions? options = null)
            : base("elasticstack:index/index:Index", name, args ?? new IndexArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Index(string name, Input<string> id, IndexState? state = null, CustomResourceOptions? options = null)
            : base("elasticstack:index/index:Index", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Index resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Index Get(string name, Input<string> id, IndexState? state = null, CustomResourceOptions? options = null)
        {
            return new Index(name, id, state, options);
        }
    }

    public sealed class IndexArgs : global::Pulumi.ResourceArgs
    {
        [Input("aliases")]
        private InputList<Inputs.IndexAliasArgs>? _aliases;

        /// <summary>
        /// Aliases for the index.
        /// </summary>
        public InputList<Inputs.IndexAliasArgs> Aliases
        {
            get => _aliases ?? (_aliases = new InputList<Inputs.IndexAliasArgs>());
            set => _aliases = value;
        }

        /// <summary>
        /// A JSON string describing the analyzers applied to the index.
        /// </summary>
        [Input("analysisAnalyzer")]
        public Input<string>? AnalysisAnalyzer { get; set; }

        /// <summary>
        /// A JSON string describing the char_filters applied to the index.
        /// </summary>
        [Input("analysisCharFilter")]
        public Input<string>? AnalysisCharFilter { get; set; }

        /// <summary>
        /// A JSON string describing the filters applied to the index.
        /// </summary>
        [Input("analysisFilter")]
        public Input<string>? AnalysisFilter { get; set; }

        /// <summary>
        /// A JSON string describing the normalizers applied to the index.
        /// </summary>
        [Input("analysisNormalizer")]
        public Input<string>? AnalysisNormalizer { get; set; }

        /// <summary>
        /// A JSON string describing the tokenizers applied to the index.
        /// </summary>
        [Input("analysisTokenizer")]
        public Input<string>? AnalysisTokenizer { get; set; }

        /// <summary>
        /// The maximum number of tokens that can be produced using _analyze API.
        /// </summary>
        [Input("analyzeMaxTokenCount")]
        public Input<int>? AnalyzeMaxTokenCount { get; set; }

        /// <summary>
        /// Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)
        /// </summary>
        [Input("autoExpandReplicas")]
        public Input<string>? AutoExpandReplicas { get; set; }

        /// <summary>
        /// Set to `true` to disable index metadata reads and writes.
        /// </summary>
        [Input("blocksMetadata")]
        public Input<bool>? BlocksMetadata { get; set; }

        /// <summary>
        /// Set to `true` to disable read operations against the index.
        /// </summary>
        [Input("blocksRead")]
        public Input<bool>? BlocksRead { get; set; }

        /// <summary>
        /// Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.
        /// </summary>
        [Input("blocksReadOnly")]
        public Input<bool>? BlocksReadOnly { get; set; }

        /// <summary>
        /// Identical to `index.blocks.read_only` but allows deleting the index to free up resources.
        /// </summary>
        [Input("blocksReadOnlyAllowDelete")]
        public Input<bool>? BlocksReadOnlyAllowDelete { get; set; }

        /// <summary>
        /// Set to `true` to disable data write operations against the index. This setting does not affect metadata.
        /// </summary>
        [Input("blocksWrite")]
        public Input<bool>? BlocksWrite { get; set; }

        /// <summary>
        /// The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.
        /// </summary>
        [Input("codec")]
        public Input<string>? Codec { get; set; }

        /// <summary>
        /// The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.
        /// </summary>
        [Input("defaultPipeline")]
        public Input<string>? DefaultPipeline { get; set; }

        /// <summary>
        /// Elasticsearch connection configuration block.
        /// </summary>
        [Input("elasticsearchConnection")]
        public Input<Inputs.IndexElasticsearchConnectionArgs>? ElasticsearchConnection { get; set; }

        /// <summary>
        /// Final ingest pipeline for the index. Indexing requests will fail if the final pipeline is set and the pipeline does not exist. The final pipeline always runs after the request pipeline (if specified) and the default pipeline (if it exists). The special pipeline name _none indicates no ingest pipeline will run.
        /// </summary>
        [Input("finalPipeline")]
        public Input<string>? FinalPipeline { get; set; }

        /// <summary>
        /// The length of time that a deleted document's version number remains available for further versioned operations.
        /// </summary>
        [Input("gcDeletes")]
        public Input<string>? GcDeletes { get; set; }

        /// <summary>
        /// The maximum number of characters that will be analyzed for a highlight request.
        /// </summary>
        [Input("highlightMaxAnalyzedOffset")]
        public Input<int>? HighlightMaxAnalyzedOffset { get; set; }

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Input("indexingSlowlogLevel")]
        public Input<string>? IndexingSlowlogLevel { get; set; }

        /// <summary>
        /// Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.
        /// </summary>
        [Input("indexingSlowlogSource")]
        public Input<string>? IndexingSlowlogSource { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexDebug")]
        public Input<string>? IndexingSlowlogThresholdIndexDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexInfo")]
        public Input<string>? IndexingSlowlogThresholdIndexInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexTrace")]
        public Input<string>? IndexingSlowlogThresholdIndexTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexWarn")]
        public Input<string>? IndexingSlowlogThresholdIndexWarn { get; set; }

        /// <summary>
        /// Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.
        /// </summary>
        [Input("loadFixedBitsetFiltersEagerly")]
        public Input<bool>? LoadFixedBitsetFiltersEagerly { get; set; }

        /// <summary>
        /// Mapping for fields in the index.
        /// If specified, this mapping can include: field names, [field data types](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html), [mapping parameters](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html).
        /// **NOTE:** changing datatypes in the existing *mappings* will force index to be re-created.
        /// </summary>
        [Input("mappings")]
        public Input<string>? Mappings { get; set; }

        /// <summary>
        /// The maximum number of `docvalue_fields` that are allowed in a query.
        /// </summary>
        [Input("maxDocvalueFieldsSearch")]
        public Input<int>? MaxDocvalueFieldsSearch { get; set; }

        /// <summary>
        /// The maximum value of `from + size` for inner hits definition and top hits aggregations to this index.
        /// </summary>
        [Input("maxInnerResultWindow")]
        public Input<int>? MaxInnerResultWindow { get; set; }

        /// <summary>
        /// The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter.
        /// </summary>
        [Input("maxNgramDiff")]
        public Input<int>? MaxNgramDiff { get; set; }

        /// <summary>
        /// Maximum number of refresh listeners available on each shard of the index.
        /// </summary>
        [Input("maxRefreshListeners")]
        public Input<int>? MaxRefreshListeners { get; set; }

        /// <summary>
        /// The maximum length of regex that can be used in Regexp Query.
        /// </summary>
        [Input("maxRegexLength")]
        public Input<int>? MaxRegexLength { get; set; }

        /// <summary>
        /// The maximum value of `window_size` for `rescore` requests in searches of this index.
        /// </summary>
        [Input("maxRescoreWindow")]
        public Input<int>? MaxRescoreWindow { get; set; }

        /// <summary>
        /// The maximum value of `from + size` for searches to this index.
        /// </summary>
        [Input("maxResultWindow")]
        public Input<int>? MaxResultWindow { get; set; }

        /// <summary>
        /// The maximum number of `script_fields` that are allowed in a query.
        /// </summary>
        [Input("maxScriptFields")]
        public Input<int>? MaxScriptFields { get; set; }

        /// <summary>
        /// The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter.
        /// </summary>
        [Input("maxShingleDiff")]
        public Input<int>? MaxShingleDiff { get; set; }

        /// <summary>
        /// The maximum number of terms that can be used in Terms Query.
        /// </summary>
        [Input("maxTermsCount")]
        public Input<int>? MaxTermsCount { get; set; }

        /// <summary>
        /// Name of the index you wish to create.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Number of shard replicas.
        /// </summary>
        [Input("numberOfReplicas")]
        public Input<int>? NumberOfReplicas { get; set; }

        /// <summary>
        /// Value used with number*of*shards to route documents to a primary shard. This can be set only on creation.
        /// </summary>
        [Input("numberOfRoutingShards")]
        public Input<int>? NumberOfRoutingShards { get; set; }

        /// <summary>
        /// Number of shards for the index. This can be set only on creation.
        /// </summary>
        [Input("numberOfShards")]
        public Input<int>? NumberOfShards { get; set; }

        [Input("queryDefaultFields")]
        private InputList<string>? _queryDefaultFields;

        /// <summary>
        /// Wildcard (*) patterns matching one or more fields. Defaults to '*', which matches all fields eligible for term-level queries, excluding metadata fields.
        /// </summary>
        public InputList<string> QueryDefaultFields
        {
            get => _queryDefaultFields ?? (_queryDefaultFields = new InputList<string>());
            set => _queryDefaultFields = value;
        }

        /// <summary>
        /// How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.
        /// </summary>
        [Input("refreshInterval")]
        public Input<string>? RefreshInterval { get; set; }

        /// <summary>
        /// Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.
        /// </summary>
        [Input("routingAllocationEnable")]
        public Input<string>? RoutingAllocationEnable { get; set; }

        /// <summary>
        /// The number of shards a custom routing value can go to. This can be set only on creation.
        /// </summary>
        [Input("routingPartitionSize")]
        public Input<int>? RoutingPartitionSize { get; set; }

        /// <summary>
        /// Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.
        /// </summary>
        [Input("routingRebalanceEnable")]
        public Input<string>? RoutingRebalanceEnable { get; set; }

        /// <summary>
        /// How long a shard can not receive a search or get request until it’s considered search idle.
        /// </summary>
        [Input("searchIdleAfter")]
        public Input<string>? SearchIdleAfter { get; set; }

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Input("searchSlowlogLevel")]
        public Input<string>? SearchSlowlogLevel { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchDebug")]
        public Input<string>? SearchSlowlogThresholdFetchDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchInfo")]
        public Input<string>? SearchSlowlogThresholdFetchInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`
        /// </summary>
        [Input("searchSlowlogThresholdFetchTrace")]
        public Input<string>? SearchSlowlogThresholdFetchTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchWarn")]
        public Input<string>? SearchSlowlogThresholdFetchWarn { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryDebug")]
        public Input<string>? SearchSlowlogThresholdQueryDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryInfo")]
        public Input<string>? SearchSlowlogThresholdQueryInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`
        /// </summary>
        [Input("searchSlowlogThresholdQueryTrace")]
        public Input<string>? SearchSlowlogThresholdQueryTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryWarn")]
        public Input<string>? SearchSlowlogThresholdQueryWarn { get; set; }

        /// <summary>
        /// DEPRECATED: Please use dedicated setting field. Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings.
        /// **NOTE:** Static index settings (see: https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#*static*index_settings) can be only set on the index creation and later cannot be removed or updated - *apply* will return error
        /// </summary>
        [Input("settings")]
        public Input<Inputs.IndexSettingsArgs>? Settings { get; set; }

        /// <summary>
        /// Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.
        /// </summary>
        [Input("shardCheckOnStartup")]
        public Input<string>? ShardCheckOnStartup { get; set; }

        [Input("sortFields")]
        private InputList<string>? _sortFields;

        /// <summary>
        /// The field to sort shards in this index by.
        /// </summary>
        public InputList<string> SortFields
        {
            get => _sortFields ?? (_sortFields = new InputList<string>());
            set => _sortFields = value;
        }

        [Input("sortOrders")]
        private InputList<string>? _sortOrders;

        /// <summary>
        /// The direction to sort shards in. Accepts `asc`, `desc`.
        /// </summary>
        public InputList<string> SortOrders
        {
            get => _sortOrders ?? (_sortOrders = new InputList<string>());
            set => _sortOrders = value;
        }

        /// <summary>
        /// Time to delay the allocation of replica shards which become unassigned because a node has left, in time units, e.g. `10s`
        /// </summary>
        [Input("unassignedNodeLeftDelayedTimeout")]
        public Input<string>? UnassignedNodeLeftDelayedTimeout { get; set; }

        public IndexArgs()
        {
        }
        public static new IndexArgs Empty => new IndexArgs();
    }

    public sealed class IndexState : global::Pulumi.ResourceArgs
    {
        [Input("aliases")]
        private InputList<Inputs.IndexAliasGetArgs>? _aliases;

        /// <summary>
        /// Aliases for the index.
        /// </summary>
        public InputList<Inputs.IndexAliasGetArgs> Aliases
        {
            get => _aliases ?? (_aliases = new InputList<Inputs.IndexAliasGetArgs>());
            set => _aliases = value;
        }

        /// <summary>
        /// A JSON string describing the analyzers applied to the index.
        /// </summary>
        [Input("analysisAnalyzer")]
        public Input<string>? AnalysisAnalyzer { get; set; }

        /// <summary>
        /// A JSON string describing the char_filters applied to the index.
        /// </summary>
        [Input("analysisCharFilter")]
        public Input<string>? AnalysisCharFilter { get; set; }

        /// <summary>
        /// A JSON string describing the filters applied to the index.
        /// </summary>
        [Input("analysisFilter")]
        public Input<string>? AnalysisFilter { get; set; }

        /// <summary>
        /// A JSON string describing the normalizers applied to the index.
        /// </summary>
        [Input("analysisNormalizer")]
        public Input<string>? AnalysisNormalizer { get; set; }

        /// <summary>
        /// A JSON string describing the tokenizers applied to the index.
        /// </summary>
        [Input("analysisTokenizer")]
        public Input<string>? AnalysisTokenizer { get; set; }

        /// <summary>
        /// The maximum number of tokens that can be produced using _analyze API.
        /// </summary>
        [Input("analyzeMaxTokenCount")]
        public Input<int>? AnalyzeMaxTokenCount { get; set; }

        /// <summary>
        /// Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)
        /// </summary>
        [Input("autoExpandReplicas")]
        public Input<string>? AutoExpandReplicas { get; set; }

        /// <summary>
        /// Set to `true` to disable index metadata reads and writes.
        /// </summary>
        [Input("blocksMetadata")]
        public Input<bool>? BlocksMetadata { get; set; }

        /// <summary>
        /// Set to `true` to disable read operations against the index.
        /// </summary>
        [Input("blocksRead")]
        public Input<bool>? BlocksRead { get; set; }

        /// <summary>
        /// Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.
        /// </summary>
        [Input("blocksReadOnly")]
        public Input<bool>? BlocksReadOnly { get; set; }

        /// <summary>
        /// Identical to `index.blocks.read_only` but allows deleting the index to free up resources.
        /// </summary>
        [Input("blocksReadOnlyAllowDelete")]
        public Input<bool>? BlocksReadOnlyAllowDelete { get; set; }

        /// <summary>
        /// Set to `true` to disable data write operations against the index. This setting does not affect metadata.
        /// </summary>
        [Input("blocksWrite")]
        public Input<bool>? BlocksWrite { get; set; }

        /// <summary>
        /// The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.
        /// </summary>
        [Input("codec")]
        public Input<string>? Codec { get; set; }

        /// <summary>
        /// The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.
        /// </summary>
        [Input("defaultPipeline")]
        public Input<string>? DefaultPipeline { get; set; }

        /// <summary>
        /// Elasticsearch connection configuration block.
        /// </summary>
        [Input("elasticsearchConnection")]
        public Input<Inputs.IndexElasticsearchConnectionGetArgs>? ElasticsearchConnection { get; set; }

        /// <summary>
        /// Final ingest pipeline for the index. Indexing requests will fail if the final pipeline is set and the pipeline does not exist. The final pipeline always runs after the request pipeline (if specified) and the default pipeline (if it exists). The special pipeline name _none indicates no ingest pipeline will run.
        /// </summary>
        [Input("finalPipeline")]
        public Input<string>? FinalPipeline { get; set; }

        /// <summary>
        /// The length of time that a deleted document's version number remains available for further versioned operations.
        /// </summary>
        [Input("gcDeletes")]
        public Input<string>? GcDeletes { get; set; }

        /// <summary>
        /// The maximum number of characters that will be analyzed for a highlight request.
        /// </summary>
        [Input("highlightMaxAnalyzedOffset")]
        public Input<int>? HighlightMaxAnalyzedOffset { get; set; }

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Input("indexingSlowlogLevel")]
        public Input<string>? IndexingSlowlogLevel { get; set; }

        /// <summary>
        /// Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.
        /// </summary>
        [Input("indexingSlowlogSource")]
        public Input<string>? IndexingSlowlogSource { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexDebug")]
        public Input<string>? IndexingSlowlogThresholdIndexDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexInfo")]
        public Input<string>? IndexingSlowlogThresholdIndexInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexTrace")]
        public Input<string>? IndexingSlowlogThresholdIndexTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexWarn")]
        public Input<string>? IndexingSlowlogThresholdIndexWarn { get; set; }

        /// <summary>
        /// Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.
        /// </summary>
        [Input("loadFixedBitsetFiltersEagerly")]
        public Input<bool>? LoadFixedBitsetFiltersEagerly { get; set; }

        /// <summary>
        /// Mapping for fields in the index.
        /// If specified, this mapping can include: field names, [field data types](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html), [mapping parameters](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html).
        /// **NOTE:** changing datatypes in the existing *mappings* will force index to be re-created.
        /// </summary>
        [Input("mappings")]
        public Input<string>? Mappings { get; set; }

        /// <summary>
        /// The maximum number of `docvalue_fields` that are allowed in a query.
        /// </summary>
        [Input("maxDocvalueFieldsSearch")]
        public Input<int>? MaxDocvalueFieldsSearch { get; set; }

        /// <summary>
        /// The maximum value of `from + size` for inner hits definition and top hits aggregations to this index.
        /// </summary>
        [Input("maxInnerResultWindow")]
        public Input<int>? MaxInnerResultWindow { get; set; }

        /// <summary>
        /// The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter.
        /// </summary>
        [Input("maxNgramDiff")]
        public Input<int>? MaxNgramDiff { get; set; }

        /// <summary>
        /// Maximum number of refresh listeners available on each shard of the index.
        /// </summary>
        [Input("maxRefreshListeners")]
        public Input<int>? MaxRefreshListeners { get; set; }

        /// <summary>
        /// The maximum length of regex that can be used in Regexp Query.
        /// </summary>
        [Input("maxRegexLength")]
        public Input<int>? MaxRegexLength { get; set; }

        /// <summary>
        /// The maximum value of `window_size` for `rescore` requests in searches of this index.
        /// </summary>
        [Input("maxRescoreWindow")]
        public Input<int>? MaxRescoreWindow { get; set; }

        /// <summary>
        /// The maximum value of `from + size` for searches to this index.
        /// </summary>
        [Input("maxResultWindow")]
        public Input<int>? MaxResultWindow { get; set; }

        /// <summary>
        /// The maximum number of `script_fields` that are allowed in a query.
        /// </summary>
        [Input("maxScriptFields")]
        public Input<int>? MaxScriptFields { get; set; }

        /// <summary>
        /// The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter.
        /// </summary>
        [Input("maxShingleDiff")]
        public Input<int>? MaxShingleDiff { get; set; }

        /// <summary>
        /// The maximum number of terms that can be used in Terms Query.
        /// </summary>
        [Input("maxTermsCount")]
        public Input<int>? MaxTermsCount { get; set; }

        /// <summary>
        /// Name of the index you wish to create.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Number of shard replicas.
        /// </summary>
        [Input("numberOfReplicas")]
        public Input<int>? NumberOfReplicas { get; set; }

        /// <summary>
        /// Value used with number*of*shards to route documents to a primary shard. This can be set only on creation.
        /// </summary>
        [Input("numberOfRoutingShards")]
        public Input<int>? NumberOfRoutingShards { get; set; }

        /// <summary>
        /// Number of shards for the index. This can be set only on creation.
        /// </summary>
        [Input("numberOfShards")]
        public Input<int>? NumberOfShards { get; set; }

        [Input("queryDefaultFields")]
        private InputList<string>? _queryDefaultFields;

        /// <summary>
        /// Wildcard (*) patterns matching one or more fields. Defaults to '*', which matches all fields eligible for term-level queries, excluding metadata fields.
        /// </summary>
        public InputList<string> QueryDefaultFields
        {
            get => _queryDefaultFields ?? (_queryDefaultFields = new InputList<string>());
            set => _queryDefaultFields = value;
        }

        /// <summary>
        /// How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.
        /// </summary>
        [Input("refreshInterval")]
        public Input<string>? RefreshInterval { get; set; }

        /// <summary>
        /// Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.
        /// </summary>
        [Input("routingAllocationEnable")]
        public Input<string>? RoutingAllocationEnable { get; set; }

        /// <summary>
        /// The number of shards a custom routing value can go to. This can be set only on creation.
        /// </summary>
        [Input("routingPartitionSize")]
        public Input<int>? RoutingPartitionSize { get; set; }

        /// <summary>
        /// Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.
        /// </summary>
        [Input("routingRebalanceEnable")]
        public Input<string>? RoutingRebalanceEnable { get; set; }

        /// <summary>
        /// How long a shard can not receive a search or get request until it’s considered search idle.
        /// </summary>
        [Input("searchIdleAfter")]
        public Input<string>? SearchIdleAfter { get; set; }

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Input("searchSlowlogLevel")]
        public Input<string>? SearchSlowlogLevel { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchDebug")]
        public Input<string>? SearchSlowlogThresholdFetchDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchInfo")]
        public Input<string>? SearchSlowlogThresholdFetchInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`
        /// </summary>
        [Input("searchSlowlogThresholdFetchTrace")]
        public Input<string>? SearchSlowlogThresholdFetchTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchWarn")]
        public Input<string>? SearchSlowlogThresholdFetchWarn { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryDebug")]
        public Input<string>? SearchSlowlogThresholdQueryDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryInfo")]
        public Input<string>? SearchSlowlogThresholdQueryInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`
        /// </summary>
        [Input("searchSlowlogThresholdQueryTrace")]
        public Input<string>? SearchSlowlogThresholdQueryTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryWarn")]
        public Input<string>? SearchSlowlogThresholdQueryWarn { get; set; }

        /// <summary>
        /// DEPRECATED: Please use dedicated setting field. Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings.
        /// **NOTE:** Static index settings (see: https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#*static*index_settings) can be only set on the index creation and later cannot be removed or updated - *apply* will return error
        /// </summary>
        [Input("settings")]
        public Input<Inputs.IndexSettingsGetArgs>? Settings { get; set; }

        /// <summary>
        /// All raw settings fetched from the cluster.
        /// </summary>
        [Input("settingsRaw")]
        public Input<string>? SettingsRaw { get; set; }

        /// <summary>
        /// Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.
        /// </summary>
        [Input("shardCheckOnStartup")]
        public Input<string>? ShardCheckOnStartup { get; set; }

        [Input("sortFields")]
        private InputList<string>? _sortFields;

        /// <summary>
        /// The field to sort shards in this index by.
        /// </summary>
        public InputList<string> SortFields
        {
            get => _sortFields ?? (_sortFields = new InputList<string>());
            set => _sortFields = value;
        }

        [Input("sortOrders")]
        private InputList<string>? _sortOrders;

        /// <summary>
        /// The direction to sort shards in. Accepts `asc`, `desc`.
        /// </summary>
        public InputList<string> SortOrders
        {
            get => _sortOrders ?? (_sortOrders = new InputList<string>());
            set => _sortOrders = value;
        }

        /// <summary>
        /// Time to delay the allocation of replica shards which become unassigned because a node has left, in time units, e.g. `10s`
        /// </summary>
        [Input("unassignedNodeLeftDelayedTimeout")]
        public Input<string>? UnassignedNodeLeftDelayedTimeout { get; set; }

        public IndexState()
        {
        }
        public static new IndexState Empty => new IndexState();
    }
}
