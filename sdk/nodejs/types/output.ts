// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ClusterSettingsElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ClusterSettingsPersistent {
    /**
     * Defines the setting in the cluster.
     */
    settings: outputs.ClusterSettingsPersistentSetting[];
}

export interface ClusterSettingsPersistentSetting {
    name: string;
    value?: string;
    valueLists?: string[];
}

export interface ClusterSettingsTransient {
    /**
     * Defines the setting in the cluster.
     */
    settings: outputs.ClusterSettingsTransientSetting[];
}

export interface ClusterSettingsTransientSetting {
    name: string;
    value?: string;
    valueLists?: string[];
}

export interface ComponentTemplateElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ComponentTemplateTemplate {
    /**
     * Alias to add.
     */
    aliases?: outputs.ComponentTemplateTemplateAlias[];
    /**
     * Mapping for fields in the index.
     */
    mappings?: string;
    /**
     * Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
     */
    settings?: string;
}

export interface ComponentTemplateTemplateAlias {
    filter?: string;
    indexRouting?: string;
    isHidden?: boolean;
    isWriteIndex?: boolean;
    /**
     * Name of the component template to create.
     */
    name: string;
    routing?: string;
    searchRouting?: string;
}

export interface DataStreamElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface DataStreamIndex {
    indexName: string;
    indexUuid: string;
}

export interface GetSecurityRoleApplication {
    application: string;
    privileges: string[];
    resources: string[];
}

export interface GetSecurityRoleElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface GetSecurityRoleIndex {
    allowRestrictedIndices: boolean;
    fieldSecurities: outputs.GetSecurityRoleIndexFieldSecurity[];
    names: string[];
    privileges: string[];
    query: string;
}

export interface GetSecurityRoleIndexFieldSecurity {
    excepts: string[];
    grants: string[];
}

export interface GetSecurityRoleMappingElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface GetSecurityUserElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface GetSnapshotRepositoryAzure {
    basePath: string;
    chunkSize: string;
    client: string;
    compress: boolean;
    container: string;
    locationMode: string;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    readonly: boolean;
}

export interface GetSnapshotRepositoryElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface GetSnapshotRepositoryF {
    chunkSize: string;
    compress: boolean;
    location: string;
    maxNumberOfSnapshots: number;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    readonly: boolean;
}

export interface GetSnapshotRepositoryGc {
    basePath: string;
    bucket: string;
    chunkSize: string;
    client: string;
    compress: boolean;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    readonly: boolean;
}

export interface GetSnapshotRepositoryHdf {
    chunkSize: string;
    compress: boolean;
    loadDefaults: boolean;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    path: string;
    readonly: boolean;
    uri: string;
}

export interface GetSnapshotRepositoryS3 {
    basePath: string;
    bucket: string;
    bufferSize: string;
    cannedAcl: string;
    chunkSize: string;
    client: string;
    compress: boolean;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    readonly: boolean;
    serverSideEncryption: boolean;
    storageClass: string;
}

export interface GetSnapshotRepositoryUrl {
    chunkSize: string;
    compress: boolean;
    httpMaxRetries: number;
    httpSocketTimeout: string;
    maxNumberOfSnapshots: number;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    readonly: boolean;
    /**
     * URL repository. Set only if the type of the fetched repo is `url`.
     */
    url: string;
}

export interface IndexAlias {
    /**
     * Query used to limit documents the alias can access.
     */
    filter?: string;
    /**
     * Value used to route indexing operations to a specific shard. If specified, this overwrites the `routing` value for indexing operations.
     */
    indexRouting?: string;
    /**
     * If true, the alias is hidden.
     */
    isHidden?: boolean;
    /**
     * If true, the index is the write index for the alias.
     */
    isWriteIndex?: boolean;
    /**
     * Index alias name.
     */
    name: string;
    /**
     * Value used to route indexing and search operations to a specific shard.
     */
    routing?: string;
    /**
     * Value used to route search operations to a specific shard. If specified, this overwrites the routing value for search operations.
     */
    searchRouting?: string;
}

export interface IndexElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface IndexLifecycleCold {
    /**
     * Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
     */
    allocate?: outputs.IndexLifecycleColdAllocate;
    /**
     * Freeze the index to minimize its memory footprint.
     */
    freeze?: outputs.IndexLifecycleColdFreeze;
    /**
     * Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include.*tier*preference" index setting.
     */
    migrate?: outputs.IndexLifecycleColdMigrate;
    /**
     * ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
     */
    minAge: string;
    /**
     * Makes the index read-only.
     */
    readonly?: outputs.IndexLifecycleColdReadonly;
    /**
     * Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
     */
    searchableSnapshot?: outputs.IndexLifecycleColdSearchableSnapshot;
    /**
     * Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
     */
    setPriority?: outputs.IndexLifecycleColdSetPriority;
    /**
     * Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
     */
    unfollow?: outputs.IndexLifecycleColdUnfollow;
}

export interface IndexLifecycleColdAllocate {
    exclude?: string;
    include?: string;
    numberOfReplicas?: number;
    require?: string;
    totalShardsPerNode?: number;
}

export interface IndexLifecycleColdFreeze {
    enabled?: boolean;
}

export interface IndexLifecycleColdMigrate {
    enabled?: boolean;
}

export interface IndexLifecycleColdReadonly {
    enabled?: boolean;
}

export interface IndexLifecycleColdSearchableSnapshot {
    forceMergeIndex?: boolean;
    snapshotRepository: string;
}

export interface IndexLifecycleColdSetPriority {
    priority: number;
}

export interface IndexLifecycleColdUnfollow {
    enabled?: boolean;
}

export interface IndexLifecycleDelete {
    /**
     * Permanently removes the index.
     */
    delete?: outputs.IndexLifecycleDeleteDelete;
    /**
     * ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
     */
    minAge: string;
    /**
     * Waits for the specified SLM policy to be executed before removing the index. This ensures that a snapshot of the deleted index is available.
     */
    waitForSnapshot?: outputs.IndexLifecycleDeleteWaitForSnapshot;
}

export interface IndexLifecycleDeleteDelete {
    deleteSearchableSnapshot?: boolean;
}

export interface IndexLifecycleDeleteWaitForSnapshot {
    policy: string;
}

export interface IndexLifecycleElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface IndexLifecycleFrozen {
    /**
     * ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
     */
    minAge: string;
    /**
     * Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
     */
    searchableSnapshot?: outputs.IndexLifecycleFrozenSearchableSnapshot;
}

export interface IndexLifecycleFrozenSearchableSnapshot {
    forceMergeIndex?: boolean;
    snapshotRepository: string;
}

export interface IndexLifecycleHot {
    /**
     * Force merges the index into the specified maximum number of segments. This action makes the index read-only.
     */
    forcemerge?: outputs.IndexLifecycleHotForcemerge;
    /**
     * ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
     */
    minAge: string;
    /**
     * Makes the index read-only.
     */
    readonly?: outputs.IndexLifecycleHotReadonly;
    /**
     * Rolls over a target to a new index when the existing index meets one or more of the rollover conditions.
     */
    rollover?: outputs.IndexLifecycleHotRollover;
    /**
     * Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
     */
    searchableSnapshot?: outputs.IndexLifecycleHotSearchableSnapshot;
    /**
     * Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
     */
    setPriority?: outputs.IndexLifecycleHotSetPriority;
    /**
     * Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
     */
    shrink?: outputs.IndexLifecycleHotShrink;
    /**
     * Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
     */
    unfollow?: outputs.IndexLifecycleHotUnfollow;
}

export interface IndexLifecycleHotForcemerge {
    indexCodec?: string;
    maxNumSegments: number;
}

export interface IndexLifecycleHotReadonly {
    enabled?: boolean;
}

export interface IndexLifecycleHotRollover {
    maxAge?: string;
    maxDocs?: number;
    maxPrimaryShardSize?: string;
    maxSize?: string;
}

export interface IndexLifecycleHotSearchableSnapshot {
    forceMergeIndex?: boolean;
    snapshotRepository: string;
}

export interface IndexLifecycleHotSetPriority {
    priority: number;
}

export interface IndexLifecycleHotShrink {
    maxPrimaryShardSize?: string;
    numberOfShards?: number;
}

export interface IndexLifecycleHotUnfollow {
    enabled?: boolean;
}

export interface IndexLifecycleWarm {
    /**
     * Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
     */
    allocate?: outputs.IndexLifecycleWarmAllocate;
    /**
     * Force merges the index into the specified maximum number of segments. This action makes the index read-only.
     */
    forcemerge?: outputs.IndexLifecycleWarmForcemerge;
    /**
     * Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include.*tier*preference" index setting.
     */
    migrate?: outputs.IndexLifecycleWarmMigrate;
    /**
     * ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
     */
    minAge: string;
    /**
     * Makes the index read-only.
     */
    readonly?: outputs.IndexLifecycleWarmReadonly;
    /**
     * Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
     */
    setPriority?: outputs.IndexLifecycleWarmSetPriority;
    /**
     * Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
     */
    shrink?: outputs.IndexLifecycleWarmShrink;
    /**
     * Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
     */
    unfollow?: outputs.IndexLifecycleWarmUnfollow;
}

export interface IndexLifecycleWarmAllocate {
    exclude?: string;
    include?: string;
    numberOfReplicas?: number;
    require?: string;
    totalShardsPerNode?: number;
}

export interface IndexLifecycleWarmForcemerge {
    indexCodec?: string;
    maxNumSegments: number;
}

export interface IndexLifecycleWarmMigrate {
    enabled?: boolean;
}

export interface IndexLifecycleWarmReadonly {
    enabled?: boolean;
}

export interface IndexLifecycleWarmSetPriority {
    priority: number;
}

export interface IndexLifecycleWarmShrink {
    maxPrimaryShardSize?: string;
    numberOfShards?: number;
}

export interface IndexLifecycleWarmUnfollow {
    enabled?: boolean;
}

export interface IndexSettings {
    /**
     * Defines the setting for the index.
     */
    settings: outputs.IndexSettingsSetting[];
}

export interface IndexSettingsSetting {
    /**
     * Name of the index you wish to create.
     */
    name: string;
    value: string;
}

export interface IndexTemplateDataStream {
    /**
     * If `true`, the data stream supports custom routing. Defaults to `false`. Available only in **8.x**
     */
    allowCustomRouting?: boolean;
    /**
     * If true, the data stream is hidden.
     */
    hidden?: boolean;
}

export interface IndexTemplateElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface IndexTemplateTemplate {
    /**
     * Alias to add.
     */
    aliases?: outputs.IndexTemplateTemplateAlias[];
    /**
     * Mapping for fields in the index.
     */
    mappings?: string;
    /**
     * Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
     */
    settings?: string;
}

export interface IndexTemplateTemplateAlias {
    filter?: string;
    indexRouting?: string;
    isHidden?: boolean;
    isWriteIndex?: boolean;
    /**
     * Name of the index template to create.
     */
    name: string;
    routing?: string;
    searchRouting?: string;
}

export interface IngestPipelineElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface LogstashPipelineElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ScriptElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface SecurityApiKeyElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface SecurityRoleApplication {
    /**
     * The name of the application to which this entry applies.
     */
    application: string;
    /**
     * A list of strings, where each element is the name of an application privilege or action.
     */
    privileges: string[];
    /**
     * A list resources to which the privileges are applied.
     */
    resources: string[];
}

export interface SecurityRoleElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface SecurityRoleIndex {
    /**
     * Include matching restricted indices in names parameter. Usage is strongly discouraged as it can grant unrestricted operations on critical data, make the entire system unstable or leak sensitive information.
     */
    allowRestrictedIndices?: boolean;
    /**
     * The document fields that the owners of the role have read access to.
     */
    fieldSecurity?: outputs.SecurityRoleIndexFieldSecurity;
    /**
     * A list of indices (or index name patterns) to which the permissions in this entry apply.
     */
    names: string[];
    /**
     * The index level privileges that the owners of the role have on the specified indices.
     */
    privileges: string[];
    /**
     * A search query that defines the documents the owners of the role have read access to.
     */
    query?: string;
}

export interface SecurityRoleIndexFieldSecurity {
    excepts?: string[];
    grants?: string[];
}

export interface SecurityRoleMappingElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface SecuritySystemUserElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface SecurityUserElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface SnapshotLifecycleElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface SnapshotRepositoryAzure {
    /**
     * Specifies the path within the container to the repository data.
     */
    basePath: string;
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * Azure named client to use.
     */
    client?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Container name. You must create the Azure container before creating the repository.
     */
    container: string;
    /**
     * Location mode. `primaryOnly` or `secondaryOnly`. See: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy
     */
    locationMode?: string;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
}

export interface SnapshotRepositoryElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface SnapshotRepositoryFs {
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Location of the shared filesystem used to store and retrieve snapshots.
     */
    location: string;
    /**
     * Maximum number of snapshots the repository can contain.
     */
    maxNumberOfSnapshots?: number;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
}

export interface SnapshotRepositoryGcs {
    /**
     * Specifies the path within the bucket to the repository data. Defaults to the root of the bucket.
     */
    basePath: string;
    /**
     * The name of the bucket to be used for snapshots.
     */
    bucket: string;
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * The name of the client to use to connect to Google Cloud Storage.
     */
    client?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
}

export interface SnapshotRepositoryHdfs {
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Whether to load the default Hadoop configuration or not.
     */
    loadDefaults?: boolean;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * The file path within the filesystem where data is stored/loaded.
     */
    path: string;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
    /**
     * The uri address for hdfs. ex: "hdfs://\n\n:\n\n/".
     */
    uri: string;
}

export interface SnapshotRepositoryS3 {
    /**
     * Specifies the path to the repository data within its bucket.
     */
    basePath: string;
    /**
     * Name of the S3 bucket to use for snapshots.
     */
    bucket: string;
    /**
     * Minimum threshold below which the chunk is uploaded using a single request.
     */
    bufferSize: string;
    /**
     * The S3 repository supports all S3 canned ACLs.
     */
    cannedAcl?: string;
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * The name of the S3 client to use to connect to S3.
     */
    client?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
    /**
     * When true, files are encrypted server-side using AES-256 algorithm.
     */
    serverSideEncryption?: boolean;
    /**
     * Sets the S3 storage class for objects stored in the snapshot repository.
     */
    storageClass?: string;
}

export interface SnapshotRepositoryUrl {
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Maximum number of retries for http and https URLs.
     */
    httpMaxRetries?: number;
    /**
     * Maximum wait time for data transfers over a connection.
     */
    httpSocketTimeout?: string;
    /**
     * Maximum number of snapshots the repository can contain.
     */
    maxNumberOfSnapshots?: number;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
    /**
     * URL location of the root of the shared filesystem repository.
     */
    url: string;
}

export namespace config {
    export interface Elasticsearch {
        apiKey?: string;
        caData?: string;
        caFile?: string;
        certData?: string;
        certFile?: string;
        endpoints?: string[];
        insecure?: boolean;
        keyData?: string;
        keyFile?: string;
        password?: string;
        username?: string;
    }

}
