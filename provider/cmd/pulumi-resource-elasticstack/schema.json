{
    "name": "elasticstack",
    "description": "A Pulumi package for creating and managing elasticstack cloud resources.",
    "keywords": [
        "pulumi",
        "elasticstack",
        "category/cloud"
    ],
    "homepage": "https://www.pulumi.com",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`elasticstack` Terraform Provider](https://github.com/elastic/terraform-provider-elasticstack).",
    "repository": "https://github.com/zlepper/pulumi-elasticstack",
    "pluginDownloadURL": "https://github.com/zlepper/pulumi-elasticstack/releases/",
    "publisher": "Zlepper",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": null,
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing elasticstack cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/elastic/terraform-provider-elasticstack)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-elasticstack` repo](https://github.com/zlepper/pulumi-elasticstack/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-elasticstack` repo](https://github.com/elastic/terraform-provider-elasticstack/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/elastic/terraform-provider-elasticstack)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-elasticstack` repo](https://github.com/zlepper/pulumi-elasticstack/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-elasticstack` repo](https://github.com/elastic/terraform-provider-elasticstack/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    },
    "config": {
        "variables": {
            "elasticsearch": {
                "$ref": "#/types/elasticstack:config/elasticsearch:elasticsearch",
                "description": "Elasticsearch connection configuration block.\n"
            }
        }
    },
    "types": {
        "elasticstack:config/elasticsearch:elasticsearch": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "secret": true
                },
                "caData": {
                    "type": "string"
                },
                "caFile": {
                    "type": "string"
                },
                "certData": {
                    "type": "string"
                },
                "certFile": {
                    "type": "string"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean"
                },
                "keyData": {
                    "type": "string",
                    "secret": true
                },
                "keyFile": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "secret": true
                },
                "username": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "elasticstack:index/ClusterSettingsElasticsearchConnection:ClusterSettingsElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/ClusterSettingsPersistent:ClusterSettingsPersistent": {
            "properties": {
                "settings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/ClusterSettingsPersistentSetting:ClusterSettingsPersistentSetting"
                    },
                    "description": "Defines the setting in the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "settings"
            ]
        },
        "elasticstack:index/ClusterSettingsPersistentSetting:ClusterSettingsPersistentSetting": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "elasticstack:index/ClusterSettingsTransient:ClusterSettingsTransient": {
            "properties": {
                "settings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/ClusterSettingsTransientSetting:ClusterSettingsTransientSetting"
                    },
                    "description": "Defines the setting in the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "settings"
            ]
        },
        "elasticstack:index/ClusterSettingsTransientSetting:ClusterSettingsTransientSetting": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "valueLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "elasticstack:index/ComponentTemplateElasticsearchConnection:ComponentTemplateElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/ComponentTemplateTemplate:ComponentTemplateTemplate": {
            "properties": {
                "aliases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/ComponentTemplateTemplateAlias:ComponentTemplateTemplateAlias"
                    },
                    "description": "Alias to add.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mappings": {
                    "type": "string",
                    "description": "Mapping for fields in the index.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "settings": {
                    "type": "string",
                    "description": "Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/ComponentTemplateTemplateAlias:ComponentTemplateTemplateAlias": {
            "properties": {
                "filter": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "indexRouting": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isHidden": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isWriteIndex": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the component template to create.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "routing": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "searchRouting": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "elasticstack:index/DataStreamElasticsearchConnection:DataStreamElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/DataStreamIndex:DataStreamIndex": {
            "properties": {
                "indexName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "indexUuid": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "indexName",
                        "indexUuid"
                    ]
                }
            }
        },
        "elasticstack:index/IndexAlias:IndexAlias": {
            "properties": {
                "filter": {
                    "type": "string",
                    "description": "Query used to limit documents the alias can access.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "indexRouting": {
                    "type": "string",
                    "description": "Value used to route indexing operations to a specific shard. If specified, this overwrites the `routing` value for indexing operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isHidden": {
                    "type": "boolean",
                    "description": "If true, the alias is hidden.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isWriteIndex": {
                    "type": "boolean",
                    "description": "If true, the index is the write index for the alias.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Index alias name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "routing": {
                    "type": "string",
                    "description": "Value used to route indexing and search operations to a specific shard.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "searchRouting": {
                    "type": "string",
                    "description": "Value used to route search operations to a specific shard. If specified, this overwrites the routing value for search operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "elasticstack:index/IndexElasticsearchConnection:IndexElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleCold:IndexLifecycleCold": {
            "properties": {
                "allocate": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleColdAllocate:IndexLifecycleColdAllocate",
                    "description": "Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "freeze": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleColdFreeze:IndexLifecycleColdFreeze",
                    "description": "Freeze the index to minimize its memory footprint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "migrate": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleColdMigrate:IndexLifecycleColdMigrate",
                    "description": "Moves the index to the data tier that corresponds to the current phase by updating the \"index.routing.allocation.include.*tier*preference\" index setting.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minAge": {
                    "type": "string",
                    "description": "ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleColdReadonly:IndexLifecycleColdReadonly",
                    "description": "Makes the index read-only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "searchableSnapshot": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleColdSearchableSnapshot:IndexLifecycleColdSearchableSnapshot",
                    "description": "Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "setPriority": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleColdSetPriority:IndexLifecycleColdSetPriority",
                    "description": "Sets a source index to read-only and shrinks it into a new index with fewer primary shards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "unfollow": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleColdUnfollow:IndexLifecycleColdUnfollow",
                    "description": "Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "minAge"
                    ]
                }
            }
        },
        "elasticstack:index/IndexLifecycleColdAllocate:IndexLifecycleColdAllocate": {
            "properties": {
                "exclude": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "include": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "numberOfReplicas": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "require": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "totalShardsPerNode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleColdFreeze:IndexLifecycleColdFreeze": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleColdMigrate:IndexLifecycleColdMigrate": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleColdReadonly:IndexLifecycleColdReadonly": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleColdSearchableSnapshot:IndexLifecycleColdSearchableSnapshot": {
            "properties": {
                "forceMergeIndex": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "snapshotRepository": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "snapshotRepository"
            ]
        },
        "elasticstack:index/IndexLifecycleColdSetPriority:IndexLifecycleColdSetPriority": {
            "properties": {
                "priority": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "priority"
            ]
        },
        "elasticstack:index/IndexLifecycleColdUnfollow:IndexLifecycleColdUnfollow": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleDelete:IndexLifecycleDelete": {
            "properties": {
                "delete": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleDeleteDelete:IndexLifecycleDeleteDelete",
                    "description": "Permanently removes the index.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minAge": {
                    "type": "string",
                    "description": "ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waitForSnapshot": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleDeleteWaitForSnapshot:IndexLifecycleDeleteWaitForSnapshot",
                    "description": "Waits for the specified SLM policy to be executed before removing the index. This ensures that a snapshot of the deleted index is available.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "minAge"
                    ]
                }
            }
        },
        "elasticstack:index/IndexLifecycleDeleteDelete:IndexLifecycleDeleteDelete": {
            "properties": {
                "deleteSearchableSnapshot": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleDeleteWaitForSnapshot:IndexLifecycleDeleteWaitForSnapshot": {
            "properties": {
                "policy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "policy"
            ]
        },
        "elasticstack:index/IndexLifecycleElasticsearchConnection:IndexLifecycleElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleFrozen:IndexLifecycleFrozen": {
            "properties": {
                "minAge": {
                    "type": "string",
                    "description": "ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "searchableSnapshot": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleFrozenSearchableSnapshot:IndexLifecycleFrozenSearchableSnapshot",
                    "description": "Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "minAge"
                    ]
                }
            }
        },
        "elasticstack:index/IndexLifecycleFrozenSearchableSnapshot:IndexLifecycleFrozenSearchableSnapshot": {
            "properties": {
                "forceMergeIndex": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "snapshotRepository": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "snapshotRepository"
            ]
        },
        "elasticstack:index/IndexLifecycleHot:IndexLifecycleHot": {
            "properties": {
                "forcemerge": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleHotForcemerge:IndexLifecycleHotForcemerge",
                    "description": "Force merges the index into the specified maximum number of segments. This action makes the index read-only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minAge": {
                    "type": "string",
                    "description": "ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleHotReadonly:IndexLifecycleHotReadonly",
                    "description": "Makes the index read-only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rollover": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleHotRollover:IndexLifecycleHotRollover",
                    "description": "Rolls over a target to a new index when the existing index meets one or more of the rollover conditions.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "searchableSnapshot": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleHotSearchableSnapshot:IndexLifecycleHotSearchableSnapshot",
                    "description": "Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "setPriority": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleHotSetPriority:IndexLifecycleHotSetPriority",
                    "description": "Sets a source index to read-only and shrinks it into a new index with fewer primary shards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "shrink": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleHotShrink:IndexLifecycleHotShrink",
                    "description": "Sets a source index to read-only and shrinks it into a new index with fewer primary shards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "unfollow": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleHotUnfollow:IndexLifecycleHotUnfollow",
                    "description": "Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "minAge"
                    ]
                }
            }
        },
        "elasticstack:index/IndexLifecycleHotForcemerge:IndexLifecycleHotForcemerge": {
            "properties": {
                "indexCodec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxNumSegments": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "maxNumSegments"
            ]
        },
        "elasticstack:index/IndexLifecycleHotReadonly:IndexLifecycleHotReadonly": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleHotRollover:IndexLifecycleHotRollover": {
            "properties": {
                "maxAge": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxDocs": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxPrimaryShardSize": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSize": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleHotSearchableSnapshot:IndexLifecycleHotSearchableSnapshot": {
            "properties": {
                "forceMergeIndex": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "snapshotRepository": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "snapshotRepository"
            ]
        },
        "elasticstack:index/IndexLifecycleHotSetPriority:IndexLifecycleHotSetPriority": {
            "properties": {
                "priority": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "priority"
            ]
        },
        "elasticstack:index/IndexLifecycleHotShrink:IndexLifecycleHotShrink": {
            "properties": {
                "maxPrimaryShardSize": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "numberOfShards": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleHotUnfollow:IndexLifecycleHotUnfollow": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleWarm:IndexLifecycleWarm": {
            "properties": {
                "allocate": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleWarmAllocate:IndexLifecycleWarmAllocate",
                    "description": "Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "forcemerge": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleWarmForcemerge:IndexLifecycleWarmForcemerge",
                    "description": "Force merges the index into the specified maximum number of segments. This action makes the index read-only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "migrate": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleWarmMigrate:IndexLifecycleWarmMigrate",
                    "description": "Moves the index to the data tier that corresponds to the current phase by updating the \"index.routing.allocation.include.*tier*preference\" index setting.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minAge": {
                    "type": "string",
                    "description": "ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleWarmReadonly:IndexLifecycleWarmReadonly",
                    "description": "Makes the index read-only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "setPriority": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleWarmSetPriority:IndexLifecycleWarmSetPriority",
                    "description": "Sets a source index to read-only and shrinks it into a new index with fewer primary shards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "shrink": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleWarmShrink:IndexLifecycleWarmShrink",
                    "description": "Sets a source index to read-only and shrinks it into a new index with fewer primary shards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "unfollow": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleWarmUnfollow:IndexLifecycleWarmUnfollow",
                    "description": "Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "minAge"
                    ]
                }
            }
        },
        "elasticstack:index/IndexLifecycleWarmAllocate:IndexLifecycleWarmAllocate": {
            "properties": {
                "exclude": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "include": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "numberOfReplicas": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "require": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "totalShardsPerNode": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleWarmForcemerge:IndexLifecycleWarmForcemerge": {
            "properties": {
                "indexCodec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxNumSegments": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "maxNumSegments"
            ]
        },
        "elasticstack:index/IndexLifecycleWarmMigrate:IndexLifecycleWarmMigrate": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleWarmReadonly:IndexLifecycleWarmReadonly": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleWarmSetPriority:IndexLifecycleWarmSetPriority": {
            "properties": {
                "priority": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "priority"
            ]
        },
        "elasticstack:index/IndexLifecycleWarmShrink:IndexLifecycleWarmShrink": {
            "properties": {
                "maxPrimaryShardSize": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "numberOfShards": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexLifecycleWarmUnfollow:IndexLifecycleWarmUnfollow": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexSettings:IndexSettings": {
            "properties": {
                "settings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/IndexSettingsSetting:IndexSettingsSetting"
                    },
                    "description": "Defines the setting for the index.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "settings"
            ]
        },
        "elasticstack:index/IndexSettingsSetting:IndexSettingsSetting": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the index you wish to create.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "elasticstack:index/IndexTemplateDataStream:IndexTemplateDataStream": {
            "properties": {
                "allowCustomRouting": {
                    "type": "boolean",
                    "description": "If `true`, the data stream supports custom routing. Defaults to `false`. Available only in **8.x**\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hidden": {
                    "type": "boolean",
                    "description": "If true, the data stream is hidden.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexTemplateElasticsearchConnection:IndexTemplateElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexTemplateTemplate:IndexTemplateTemplate": {
            "properties": {
                "aliases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/IndexTemplateTemplateAlias:IndexTemplateTemplateAlias"
                    },
                    "description": "Alias to add.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mappings": {
                    "type": "string",
                    "description": "Mapping for fields in the index.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "settings": {
                    "type": "string",
                    "description": "Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/IndexTemplateTemplateAlias:IndexTemplateTemplateAlias": {
            "properties": {
                "filter": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "indexRouting": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isHidden": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isWriteIndex": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index template to create.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "routing": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "searchRouting": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "elasticstack:index/IngestPipelineElasticsearchConnection:IngestPipelineElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/LogstashPipelineElasticsearchConnection:LogstashPipelineElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/ProviderElasticsearch:ProviderElasticsearch": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/ScriptElasticsearchConnection:ScriptElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/SecurityApiKeyElasticsearchConnection:SecurityApiKeyElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/SecurityRoleApplication:SecurityRoleApplication": {
            "properties": {
                "application": {
                    "type": "string",
                    "description": "The name of the application to which this entry applies.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of strings, where each element is the name of an application privilege or action.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list resources to which the privileges are applied.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "application",
                "privileges",
                "resources"
            ]
        },
        "elasticstack:index/SecurityRoleElasticsearchConnection:SecurityRoleElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/SecurityRoleIndex:SecurityRoleIndex": {
            "properties": {
                "allowRestrictedIndices": {
                    "type": "boolean",
                    "description": "Include matching restricted indices in names parameter. Usage is strongly discouraged as it can grant unrestricted operations on critical data, make the entire system unstable or leak sensitive information.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fieldSecurity": {
                    "$ref": "#/types/elasticstack:index/SecurityRoleIndexFieldSecurity:SecurityRoleIndexFieldSecurity",
                    "description": "The document fields that the owners of the role have read access to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of indices (or index name patterns) to which the permissions in this entry apply.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The index level privileges that the owners of the role have on the specified indices.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "query": {
                    "type": "string",
                    "description": "A search query that defines the documents the owners of the role have read access to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "names",
                "privileges"
            ]
        },
        "elasticstack:index/SecurityRoleIndexFieldSecurity:SecurityRoleIndexFieldSecurity": {
            "properties": {
                "excepts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "grants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/SecurityRoleMappingElasticsearchConnection:SecurityRoleMappingElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/SecuritySystemUserElasticsearchConnection:SecuritySystemUserElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/SecurityUserElasticsearchConnection:SecurityUserElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/SnapshotLifecycleElasticsearchConnection:SnapshotLifecycleElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/SnapshotRepositoryAzure:SnapshotRepositoryAzure": {
            "properties": {
                "basePath": {
                    "type": "string",
                    "description": "Specifies the path within the container to the repository data.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "chunkSize": {
                    "type": "string",
                    "description": "Maximum size of files in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "client": {
                    "type": "string",
                    "description": "Azure named client to use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "description": "If true, metadata files, such as index mappings and settings, are compressed in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "container": {
                    "type": "string",
                    "description": "Container name. You must create the Azure container before creating the repository.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "locationMode": {
                    "type": "string",
                    "description": "Location mode. `primary_only` or `secondary_only`. See: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot restore rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot creation rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "description": "If true, the repository is read-only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "container"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "basePath",
                        "container"
                    ]
                }
            }
        },
        "elasticstack:index/SnapshotRepositoryElasticsearchConnection:SnapshotRepositoryElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/SnapshotRepositoryFs:SnapshotRepositoryFs": {
            "properties": {
                "chunkSize": {
                    "type": "string",
                    "description": "Maximum size of files in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "description": "If true, metadata files, such as index mappings and settings, are compressed in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "location": {
                    "type": "string",
                    "description": "Location of the shared filesystem used to store and retrieve snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxNumberOfSnapshots": {
                    "type": "integer",
                    "description": "Maximum number of snapshots the repository can contain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot restore rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot creation rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "description": "If true, the repository is read-only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "location"
            ]
        },
        "elasticstack:index/SnapshotRepositoryGcs:SnapshotRepositoryGcs": {
            "properties": {
                "basePath": {
                    "type": "string",
                    "description": "Specifies the path within the bucket to the repository data. Defaults to the root of the bucket.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bucket": {
                    "type": "string",
                    "description": "The name of the bucket to be used for snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "chunkSize": {
                    "type": "string",
                    "description": "Maximum size of files in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "client": {
                    "type": "string",
                    "description": "The name of the client to use to connect to Google Cloud Storage.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "description": "If true, metadata files, such as index mappings and settings, are compressed in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot restore rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot creation rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "description": "If true, the repository is read-only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "bucket"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "basePath",
                        "bucket"
                    ]
                }
            }
        },
        "elasticstack:index/SnapshotRepositoryHdfs:SnapshotRepositoryHdfs": {
            "properties": {
                "chunkSize": {
                    "type": "string",
                    "description": "Maximum size of files in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "description": "If true, metadata files, such as index mappings and settings, are compressed in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadDefaults": {
                    "type": "boolean",
                    "description": "Whether to load the default Hadoop configuration or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot restore rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot creation rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The file path within the filesystem where data is stored/loaded.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "description": "If true, the repository is read-only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uri": {
                    "type": "string",
                    "description": "The uri address for hdfs. ex: \"hdfs://\\n\\n:\\n\\n/\".\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "path",
                "uri"
            ]
        },
        "elasticstack:index/SnapshotRepositoryS3:SnapshotRepositoryS3": {
            "properties": {
                "basePath": {
                    "type": "string",
                    "description": "Specifies the path to the repository data within its bucket.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bucket": {
                    "type": "string",
                    "description": "Name of the S3 bucket to use for snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bufferSize": {
                    "type": "string",
                    "description": "Minimum threshold below which the chunk is uploaded using a single request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cannedAcl": {
                    "type": "string",
                    "description": "The S3 repository supports all S3 canned ACLs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "chunkSize": {
                    "type": "string",
                    "description": "Maximum size of files in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "client": {
                    "type": "string",
                    "description": "The name of the S3 client to use to connect to S3.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "description": "If true, metadata files, such as index mappings and settings, are compressed in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot restore rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot creation rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "description": "If true, the repository is read-only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideEncryption": {
                    "type": "boolean",
                    "description": "When true, files are encrypted server-side using AES-256 algorithm.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storageClass": {
                    "type": "string",
                    "description": "Sets the S3 storage class for objects stored in the snapshot repository.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "bucket"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "basePath",
                        "bucket",
                        "bufferSize"
                    ]
                }
            }
        },
        "elasticstack:index/SnapshotRepositoryUrl:SnapshotRepositoryUrl": {
            "properties": {
                "chunkSize": {
                    "type": "string",
                    "description": "Maximum size of files in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "description": "If true, metadata files, such as index mappings and settings, are compressed in snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpMaxRetries": {
                    "type": "integer",
                    "description": "Maximum number of retries for http and https URLs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpSocketTimeout": {
                    "type": "string",
                    "description": "Maximum wait time for data transfers over a connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxNumberOfSnapshots": {
                    "type": "integer",
                    "description": "Maximum number of snapshots the repository can contain.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot restore rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "description": "Maximum snapshot creation rate per node.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "description": "If true, the repository is read-only.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "URL location of the root of the shared filesystem repository.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "url"
            ]
        },
        "elasticstack:index/getSecurityRoleApplication:getSecurityRoleApplication": {
            "properties": {
                "application": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "application",
                "privileges",
                "resources"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "elasticstack:index/getSecurityRoleElasticsearchConnection:getSecurityRoleElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/getSecurityRoleIndex:getSecurityRoleIndex": {
            "properties": {
                "allowRestrictedIndices": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fieldSecurities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/getSecurityRoleIndexFieldSecurity:getSecurityRoleIndexFieldSecurity"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "names": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "query": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "allowRestrictedIndices",
                "fieldSecurities",
                "names",
                "privileges",
                "query"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "elasticstack:index/getSecurityRoleIndexFieldSecurity:getSecurityRoleIndexFieldSecurity": {
            "properties": {
                "excepts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "grants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "excepts",
                "grants"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "elasticstack:index/getSecurityRoleMappingElasticsearchConnection:getSecurityRoleMappingElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/getSecurityUserElasticsearchConnection:getSecurityUserElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/getSnapshotRepositoryAzure:getSnapshotRepositoryAzure": {
            "properties": {
                "basePath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "chunkSize": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "client": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "container": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "locationMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "basePath",
                "chunkSize",
                "client",
                "compress",
                "container",
                "locationMode",
                "maxRestoreBytesPerSec",
                "maxSnapshotBytesPerSec",
                "readonly"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "elasticstack:index/getSnapshotRepositoryElasticsearchConnection:getSnapshotRepositoryElasticsearchConnection": {
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "API Key to use for authentication to Elasticsearch\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "caData": {
                    "type": "string",
                    "description": "PEM-encoded custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "caFile": {
                    "type": "string",
                    "description": "Path to a custom Certificate Authority certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certData": {
                    "type": "string",
                    "description": "PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded certificate for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "insecure": {
                    "type": "boolean",
                    "description": "Disable TLS certificate validation\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyData": {
                    "type": "string",
                    "description": "PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyFile": {
                    "type": "string",
                    "description": "Path to a file containing the PEM encoded private key for client auth\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username to use for API authentication to Elasticsearch.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "elasticstack:index/getSnapshotRepositoryF:getSnapshotRepositoryF": {
            "properties": {
                "chunkSize": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "location": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxNumberOfSnapshots": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "chunkSize",
                "compress",
                "location",
                "maxNumberOfSnapshots",
                "maxRestoreBytesPerSec",
                "maxSnapshotBytesPerSec",
                "readonly"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "elasticstack:index/getSnapshotRepositoryGc:getSnapshotRepositoryGc": {
            "properties": {
                "basePath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bucket": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "chunkSize": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "client": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "basePath",
                "bucket",
                "chunkSize",
                "client",
                "compress",
                "maxRestoreBytesPerSec",
                "maxSnapshotBytesPerSec",
                "readonly"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "elasticstack:index/getSnapshotRepositoryHdf:getSnapshotRepositoryHdf": {
            "properties": {
                "chunkSize": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loadDefaults": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uri": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "chunkSize",
                "compress",
                "loadDefaults",
                "maxRestoreBytesPerSec",
                "maxSnapshotBytesPerSec",
                "path",
                "readonly",
                "uri"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "elasticstack:index/getSnapshotRepositoryS3:getSnapshotRepositoryS3": {
            "properties": {
                "basePath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bucket": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bufferSize": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cannedAcl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "chunkSize": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "client": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverSideEncryption": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storageClass": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "basePath",
                "bucket",
                "bufferSize",
                "cannedAcl",
                "chunkSize",
                "client",
                "compress",
                "maxRestoreBytesPerSec",
                "maxSnapshotBytesPerSec",
                "readonly",
                "serverSideEncryption",
                "storageClass"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "elasticstack:index/getSnapshotRepositoryUrl:getSnapshotRepositoryUrl": {
            "properties": {
                "chunkSize": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "compress": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpMaxRetries": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "httpSocketTimeout": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxNumberOfSnapshots": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxRestoreBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxSnapshotBytesPerSec": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readonly": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "URL repository. Set only if the type of the fetched repo is `url`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "chunkSize",
                "compress",
                "httpMaxRetries",
                "httpSocketTimeout",
                "maxNumberOfSnapshots",
                "maxRestoreBytesPerSec",
                "maxSnapshotBytesPerSec",
                "readonly",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the elasticstack package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "elasticsearch": {
                "$ref": "#/types/elasticstack:index/ProviderElasticsearch:ProviderElasticsearch",
                "description": "Elasticsearch connection configuration block.\n"
            }
        },
        "inputProperties": {
            "elasticsearch": {
                "$ref": "#/types/elasticstack:index/ProviderElasticsearch:ProviderElasticsearch",
                "description": "Elasticsearch connection configuration block.\n"
            }
        }
    },
    "resources": {
        "elasticstack:index/clusterSettings:ClusterSettings": {
            "description": "Updates cluster-wide settings. If the Elasticsearch security features are enabled, you must have the manage cluster privilege to use this API. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-update-settings.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ClusterSettings;\nimport com.pulumi.elasticstack.ClusterSettingsArgs;\nimport com.pulumi.elasticstack.inputs.ClusterSettingsPersistentArgs;\nimport com.pulumi.elasticstack.inputs.ClusterSettingsTransientArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myClusterSettings = new ClusterSettings(\"myClusterSettings\", ClusterSettingsArgs.builder()        \n            .persistent(ClusterSettingsPersistentArgs.builder()\n                .settings(                \n                    ClusterSettingsPersistentSettingArgs.builder()\n                        .name(\"indices.lifecycle.poll_interval\")\n                        .value(\"10m\")\n                        .build(),\n                    ClusterSettingsPersistentSettingArgs.builder()\n                        .name(\"indices.recovery.max_bytes_per_sec\")\n                        .value(\"50mb\")\n                        .build(),\n                    ClusterSettingsPersistentSettingArgs.builder()\n                        .name(\"indices.breaker.total.limit\")\n                        .value(\"65%\")\n                        .build(),\n                    ClusterSettingsPersistentSettingArgs.builder()\n                        .name(\"xpack.security.audit.logfile.events.include\")\n                        .valueList(                        \n                            \"ACCESS_DENIED\",\n                            \"ACCESS_GRANTED\")\n                        .build())\n                .build())\n            .transient_(ClusterSettingsTransientArgs.builder()\n                .settings(ClusterSettingsTransientSettingArgs.builder()\n                    .name(\"indices.breaker.total.limit\")\n                    .value(\"60%\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myClusterSettings:\n    type: elasticstack:ClusterSettings\n    properties:\n      persistent:\n        settings:\n          - name: indices.lifecycle.poll_interval\n            value: 10m\n          - name: indices.recovery.max_bytes_per_sec\n            value: 50mb\n          - name: indices.breaker.total.limit\n            value: 65%\n          - name: xpack.security.audit.logfile.events.include\n            valueList:\n              - ACCESS_DENIED\n              - ACCESS_GRANTED\n      transient:\n        settings:\n          - name: indices.breaker.total.limit\n            value: 60%\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/ClusterSettingsElasticsearchConnection:ClusterSettingsElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "persistent": {
                    "$ref": "#/types/elasticstack:index/ClusterSettingsPersistent:ClusterSettingsPersistent",
                    "description": "Settings will apply across restarts.\n"
                },
                "transient": {
                    "$ref": "#/types/elasticstack:index/ClusterSettingsTransient:ClusterSettingsTransient",
                    "description": "Settings do not survive a full cluster restart.\n"
                }
            },
            "inputProperties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/ClusterSettingsElasticsearchConnection:ClusterSettingsElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "persistent": {
                    "$ref": "#/types/elasticstack:index/ClusterSettingsPersistent:ClusterSettingsPersistent",
                    "description": "Settings will apply across restarts.\n"
                },
                "transient": {
                    "$ref": "#/types/elasticstack:index/ClusterSettingsTransient:ClusterSettingsTransient",
                    "description": "Settings do not survive a full cluster restart.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClusterSettings resources.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/ClusterSettingsElasticsearchConnection:ClusterSettingsElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "persistent": {
                        "$ref": "#/types/elasticstack:index/ClusterSettingsPersistent:ClusterSettingsPersistent",
                        "description": "Settings will apply across restarts.\n"
                    },
                    "transient": {
                        "$ref": "#/types/elasticstack:index/ClusterSettingsTransient:ClusterSettingsTransient",
                        "description": "Settings do not survive a full cluster restart.\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/componentTemplate:ComponentTemplate": {
            "description": "Creates or updates a component template. Component templates are building blocks for constructing index templates that specify index mappings, settings, and aliases. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-component-template.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst myTemplateComponentTemplate = new elasticstack.ComponentTemplate(\"myTemplateComponentTemplate\", {template: {\n    aliases: [{\n        name: \"my_template_test\",\n    }],\n    settings: JSON.stringify({\n        number_of_shards: \"3\",\n    }),\n}});\nconst myTemplateIndexTemplate = new elasticstack.IndexTemplate(\"myTemplateIndexTemplate\", {\n    indexPatterns: [\"stream*\"],\n    composedOfs: [myTemplateComponentTemplate.name],\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_elasticstack as elasticstack\n\nmy_template_component_template = elasticstack.ComponentTemplate(\"myTemplateComponentTemplate\", template=elasticstack.ComponentTemplateTemplateArgs(\n    aliases=[elasticstack.ComponentTemplateTemplateAliasArgs(\n        name=\"my_template_test\",\n    )],\n    settings=json.dumps({\n        \"number_of_shards\": \"3\",\n    }),\n))\nmy_template_index_template = elasticstack.IndexTemplate(\"myTemplateIndexTemplate\",\n    index_patterns=[\"stream*\"],\n    composed_ofs=[my_template_component_template.name])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myTemplateComponentTemplate = new Elasticstack.ComponentTemplate(\"myTemplateComponentTemplate\", new()\n    {\n        Template = new Elasticstack.Inputs.ComponentTemplateTemplateArgs\n        {\n            Aliases = new[]\n            {\n                new Elasticstack.Inputs.ComponentTemplateTemplateAliasArgs\n                {\n                    Name = \"my_template_test\",\n                },\n            },\n            Settings = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n            {\n                [\"number_of_shards\"] = \"3\",\n            }),\n        },\n    });\n\n    var myTemplateIndexTemplate = new Elasticstack.IndexTemplate(\"myTemplateIndexTemplate\", new()\n    {\n        IndexPatterns = new[]\n        {\n            \"stream*\",\n        },\n        ComposedOfs = new[]\n        {\n            myTemplateComponentTemplate.Name,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"number_of_shards\": \"3\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\tmyTemplateComponentTemplate, err := elasticstack.NewComponentTemplate(ctx, \"myTemplateComponentTemplate\", \u0026elasticstack.ComponentTemplateArgs{\n\t\t\tTemplate: \u0026elasticstack.ComponentTemplateTemplateArgs{\n\t\t\t\tAliases: elasticstack.ComponentTemplateTemplateAliasArray{\n\t\t\t\t\t\u0026elasticstack.ComponentTemplateTemplateAliasArgs{\n\t\t\t\t\t\tName: pulumi.String(\"my_template_test\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSettings: pulumi.String(json0),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIndexTemplate(ctx, \"myTemplateIndexTemplate\", \u0026elasticstack.IndexTemplateArgs{\n\t\t\tIndexPatterns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"stream*\"),\n\t\t\t},\n\t\t\tComposedOfs: pulumi.StringArray{\n\t\t\t\tmyTemplateComponentTemplate.Name,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ComponentTemplate;\nimport com.pulumi.elasticstack.ComponentTemplateArgs;\nimport com.pulumi.elasticstack.inputs.ComponentTemplateTemplateArgs;\nimport com.pulumi.elasticstack.IndexTemplate;\nimport com.pulumi.elasticstack.IndexTemplateArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myTemplateComponentTemplate = new ComponentTemplate(\"myTemplateComponentTemplate\", ComponentTemplateArgs.builder()        \n            .template(ComponentTemplateTemplateArgs.builder()\n                .aliases(ComponentTemplateTemplateAliasArgs.builder()\n                    .name(\"my_template_test\")\n                    .build())\n                .settings(serializeJson(\n                    jsonObject(\n                        jsonProperty(\"number_of_shards\", \"3\")\n                    )))\n                .build())\n            .build());\n\n        var myTemplateIndexTemplate = new IndexTemplate(\"myTemplateIndexTemplate\", IndexTemplateArgs.builder()        \n            .indexPatterns(\"stream*\")\n            .composedOfs(myTemplateComponentTemplate.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myTemplateComponentTemplate:\n    type: elasticstack:ComponentTemplate\n    properties:\n      template:\n        aliases:\n          - name: my_template_test\n        settings:\n          fn::toJSON:\n            number_of_shards: '3'\n  myTemplateIndexTemplate:\n    type: elasticstack:IndexTemplate\n    properties:\n      indexPatterns:\n        - stream*\n      composedOfs:\n        - ${myTemplateComponentTemplate.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/componentTemplate:ComponentTemplate my_template \u003ccluster_uuid\u003e/\u003ccomponent_name\u003e\n```\n\n ",
            "properties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/ComponentTemplateElasticsearchConnection:ComponentTemplateElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Optional user metadata about the component template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the component template to create.\n"
                },
                "template": {
                    "$ref": "#/types/elasticstack:index/ComponentTemplateTemplate:ComponentTemplateTemplate",
                    "description": "Template to be applied. It may optionally include an aliases, mappings, or settings configuration.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "Version number used to manage component templates externally.\n"
                }
            },
            "required": [
                "name",
                "template"
            ],
            "inputProperties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/ComponentTemplateElasticsearchConnection:ComponentTemplateElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Optional user metadata about the component template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the component template to create.\n",
                    "willReplaceOnChanges": true
                },
                "template": {
                    "$ref": "#/types/elasticstack:index/ComponentTemplateTemplate:ComponentTemplateTemplate",
                    "description": "Template to be applied. It may optionally include an aliases, mappings, or settings configuration.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "Version number used to manage component templates externally.\n"
                }
            },
            "requiredInputs": [
                "template"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComponentTemplate resources.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/ComponentTemplateElasticsearchConnection:ComponentTemplateElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Optional user metadata about the component template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the component template to create.\n",
                        "willReplaceOnChanges": true
                    },
                    "template": {
                        "$ref": "#/types/elasticstack:index/ComponentTemplateTemplate:ComponentTemplateTemplate",
                        "description": "Template to be applied. It may optionally include an aliases, mappings, or settings configuration.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "Version number used to manage component templates externally.\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/dataStream:DataStream": {
            "description": "Manages data streams. This resource can create, delete and show the information about the created data stream. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/data-stream-apis.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\n// Create an ILM policy for our data stream\nconst myIlm = new elasticstack.IndexLifecycle(\"myIlm\", {\n    hot: {\n        minAge: \"1h\",\n        setPriority: {\n            priority: 10,\n        },\n        rollover: {\n            maxAge: \"1d\",\n        },\n        readonly: {},\n    },\n    \"delete\": {\n        minAge: \"2d\",\n        \"delete\": {},\n    },\n});\n// First we must have a index template created\nconst myDataStreamTemplate = new elasticstack.IndexTemplate(\"myDataStreamTemplate\", {\n    indexPatterns: [\"my-stream*\"],\n    template: {\n        settings: myIlm.name.apply(name =\u003e JSON.stringify({\n            \"lifecycle.name\": name,\n        })),\n    },\n    dataStream: {},\n});\n// and now we can create data stream based on the index template\nconst myDataStream = new elasticstack.DataStream(\"myDataStream\", {}, {\n    dependsOn: [myDataStreamTemplate],\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_elasticstack as elasticstack\n\n# Create an ILM policy for our data stream\nmy_ilm = elasticstack.IndexLifecycle(\"myIlm\",\n    hot=elasticstack.IndexLifecycleHotArgs(\n        min_age=\"1h\",\n        set_priority=elasticstack.IndexLifecycleHotSetPriorityArgs(\n            priority=10,\n        ),\n        rollover=elasticstack.IndexLifecycleHotRolloverArgs(\n            max_age=\"1d\",\n        ),\n        readonly=elasticstack.IndexLifecycleHotReadonlyArgs(),\n    ),\n    delete=elasticstack.IndexLifecycleDeleteArgs(\n        min_age=\"2d\",\n        delete=elasticstack.IndexLifecycleDeleteDeleteArgs(),\n    ))\n# First we must have a index template created\nmy_data_stream_template = elasticstack.IndexTemplate(\"myDataStreamTemplate\",\n    index_patterns=[\"my-stream*\"],\n    template=elasticstack.IndexTemplateTemplateArgs(\n        settings=my_ilm.name.apply(lambda name: json.dumps({\n            \"lifecycle.name\": name,\n        })),\n    ),\n    data_stream=elasticstack.IndexTemplateDataStreamArgs())\n# and now we can create data stream based on the index template\nmy_data_stream = elasticstack.DataStream(\"myDataStream\", opts=pulumi.ResourceOptions(depends_on=[my_data_stream_template]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create an ILM policy for our data stream\n    var myIlm = new Elasticstack.IndexLifecycle(\"myIlm\", new()\n    {\n        Hot = new Elasticstack.Inputs.IndexLifecycleHotArgs\n        {\n            MinAge = \"1h\",\n            SetPriority = new Elasticstack.Inputs.IndexLifecycleHotSetPriorityArgs\n            {\n                Priority = 10,\n            },\n            Rollover = new Elasticstack.Inputs.IndexLifecycleHotRolloverArgs\n            {\n                MaxAge = \"1d\",\n            },\n            Readonly = null,\n        },\n        Delete = new Elasticstack.Inputs.IndexLifecycleDeleteArgs\n        {\n            MinAge = \"2d\",\n            Delete = null,\n        },\n    });\n\n    // First we must have a index template created\n    var myDataStreamTemplate = new Elasticstack.IndexTemplate(\"myDataStreamTemplate\", new()\n    {\n        IndexPatterns = new[]\n        {\n            \"my-stream*\",\n        },\n        Template = new Elasticstack.Inputs.IndexTemplateTemplateArgs\n        {\n            Settings = myIlm.Name.Apply(name =\u003e JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n            {\n                [\"lifecycle.name\"] = name,\n            })),\n        },\n        DataStream = null,\n    });\n\n    // and now we can create data stream based on the index template\n    var myDataStream = new Elasticstack.DataStream(\"myDataStream\", new()\n    {\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            myDataStreamTemplate,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyIlm, err := elasticstack.NewIndexLifecycle(ctx, \"myIlm\", \u0026elasticstack.IndexLifecycleArgs{\n\t\t\tHot: \u0026elasticstack.IndexLifecycleHotArgs{\n\t\t\t\tMinAge: pulumi.String(\"1h\"),\n\t\t\t\tSetPriority: \u0026elasticstack.IndexLifecycleHotSetPriorityArgs{\n\t\t\t\t\tPriority: pulumi.Int(10),\n\t\t\t\t},\n\t\t\t\tRollover: \u0026elasticstack.IndexLifecycleHotRolloverArgs{\n\t\t\t\t\tMaxAge: pulumi.String(\"1d\"),\n\t\t\t\t},\n\t\t\t\tReadonly: nil,\n\t\t\t},\n\t\t\tDelete: \u0026elasticstack.IndexLifecycleDeleteArgs{\n\t\t\t\tMinAge: pulumi.String(\"2d\"),\n\t\t\t\tDelete: nil,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmyDataStreamTemplate, err := elasticstack.NewIndexTemplate(ctx, \"myDataStreamTemplate\", \u0026elasticstack.IndexTemplateArgs{\n\t\t\tIndexPatterns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"my-stream*\"),\n\t\t\t},\n\t\t\tTemplate: \u0026elasticstack.IndexTemplateTemplateArgs{\n\t\t\t\tSettings: myIlm.Name.ApplyT(func(name string) (pulumi.String, error) {\n\t\t\t\t\tvar _zero pulumi.String\n\t\t\t\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\t\t\t\"lifecycle.name\": name,\n\t\t\t\t\t})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn _zero, err\n\t\t\t\t\t}\n\t\t\t\t\tjson0 := string(tmpJSON0)\n\t\t\t\t\treturn pulumi.String(json0), nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t\tDataStream: nil,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewDataStream(ctx, \"myDataStream\", nil, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tmyDataStreamTemplate,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.IndexLifecycle;\nimport com.pulumi.elasticstack.IndexLifecycleArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleHotArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleHotSetPriorityArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleHotRolloverArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleHotReadonlyArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleDeleteArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleDeleteDeleteArgs;\nimport com.pulumi.elasticstack.IndexTemplate;\nimport com.pulumi.elasticstack.IndexTemplateArgs;\nimport com.pulumi.elasticstack.inputs.IndexTemplateTemplateArgs;\nimport com.pulumi.elasticstack.inputs.IndexTemplateDataStreamArgs;\nimport com.pulumi.elasticstack.DataStream;\nimport com.pulumi.elasticstack.DataStreamArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myIlm = new IndexLifecycle(\"myIlm\", IndexLifecycleArgs.builder()        \n            .hot(IndexLifecycleHotArgs.builder()\n                .minAge(\"1h\")\n                .setPriority(IndexLifecycleHotSetPriorityArgs.builder()\n                    .priority(10)\n                    .build())\n                .rollover(IndexLifecycleHotRolloverArgs.builder()\n                    .maxAge(\"1d\")\n                    .build())\n                .readonly()\n                .build())\n            .delete(IndexLifecycleDeleteArgs.builder()\n                .minAge(\"2d\")\n                .delete()\n                .build())\n            .build());\n\n        var myDataStreamTemplate = new IndexTemplate(\"myDataStreamTemplate\", IndexTemplateArgs.builder()        \n            .indexPatterns(\"my-stream*\")\n            .template(IndexTemplateTemplateArgs.builder()\n                .settings(myIlm.name().applyValue(name -\u003e serializeJson(\n                    jsonObject(\n                        jsonProperty(\"lifecycle.name\", name)\n                    ))))\n                .build())\n            .dataStream()\n            .build());\n\n        var myDataStream = new DataStream(\"myDataStream\", DataStreamArgs.Empty, CustomResourceOptions.builder()\n            .dependsOn(myDataStreamTemplate)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create an ILM policy for our data stream\n  myIlm:\n    type: elasticstack:IndexLifecycle\n    properties:\n      hot:\n        minAge: 1h\n        setPriority:\n          priority: 10\n        rollover:\n          maxAge: 1d\n        readonly: {}\n      delete:\n        minAge: 2d\n        delete: {}\n  # First we must have a index template created\n  myDataStreamTemplate:\n    type: elasticstack:IndexTemplate\n    properties:\n      indexPatterns:\n        - my-stream*\n      template:\n        settings:\n          fn::toJSON:\n            lifecycle.name: ${myIlm.name}\n      dataStream: {}\n  # and now we can create data stream based on the index template\n  myDataStream:\n    type: elasticstack:DataStream\n    options:\n      dependson:\n        - ${myDataStreamTemplate}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/dataStream:DataStream my_data_stream \u003ccluster_uuid\u003e/\u003cdata_stream_name\u003e\n```\n\n ",
            "properties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/DataStreamElasticsearchConnection:DataStreamElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "generation": {
                    "type": "integer",
                    "description": "Current generation for the data stream.\n"
                },
                "hidden": {
                    "type": "boolean",
                    "description": "If `true`, the data stream is hidden.\n"
                },
                "ilmPolicy": {
                    "type": "string",
                    "description": "Name of the current ILM lifecycle policy in the streams matching index template.\n"
                },
                "indices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/DataStreamIndex:DataStreamIndex"
                    },
                    "description": "Array of objects containing information about the data streams backing indices. The last item in this array contains information about the streams current write index.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Custom metadata for the stream, copied from the _meta object of the streams matching index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the data stream to create.\n"
                },
                "replicated": {
                    "type": "boolean",
                    "description": "If `true`, the data stream is created and managed by cross-cluster replication and the local cluster can not write into this data stream or change its mappings.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Health status of the data stream.\n"
                },
                "system": {
                    "type": "boolean",
                    "description": "If `true`, the data stream is created and managed by an Elastic stack component and cannot be modified through normal user interaction.\n"
                },
                "template": {
                    "type": "string",
                    "description": "Name of the index template used to create the data streams backing indices.\n"
                },
                "timestampField": {
                    "type": "string",
                    "description": "Contains information about the data streams @timestamp field.\n"
                }
            },
            "required": [
                "generation",
                "hidden",
                "ilmPolicy",
                "indices",
                "metadata",
                "name",
                "replicated",
                "status",
                "system",
                "template",
                "timestampField"
            ],
            "inputProperties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/DataStreamElasticsearchConnection:DataStreamElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the data stream to create.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DataStream resources.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/DataStreamElasticsearchConnection:DataStreamElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "generation": {
                        "type": "integer",
                        "description": "Current generation for the data stream.\n"
                    },
                    "hidden": {
                        "type": "boolean",
                        "description": "If `true`, the data stream is hidden.\n"
                    },
                    "ilmPolicy": {
                        "type": "string",
                        "description": "Name of the current ILM lifecycle policy in the streams matching index template.\n"
                    },
                    "indices": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/DataStreamIndex:DataStreamIndex"
                        },
                        "description": "Array of objects containing information about the data streams backing indices. The last item in this array contains information about the streams current write index.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Custom metadata for the stream, copied from the _meta object of the streams matching index template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the data stream to create.\n",
                        "willReplaceOnChanges": true
                    },
                    "replicated": {
                        "type": "boolean",
                        "description": "If `true`, the data stream is created and managed by cross-cluster replication and the local cluster can not write into this data stream or change its mappings.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Health status of the data stream.\n"
                    },
                    "system": {
                        "type": "boolean",
                        "description": "If `true`, the data stream is created and managed by an Elastic stack component and cannot be modified through normal user interaction.\n"
                    },
                    "template": {
                        "type": "string",
                        "description": "Name of the index template used to create the data streams backing indices.\n"
                    },
                    "timestampField": {
                        "type": "string",
                        "description": "Contains information about the data streams @timestamp field.\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/index:Index": {
            "description": "Creates or updates an index. This resource can define settings, mappings and aliases. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.Index;\nimport com.pulumi.elasticstack.IndexArgs;\nimport com.pulumi.elasticstack.inputs.IndexAliasArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myIndex = new Index(\"myIndex\", IndexArgs.builder()        \n            .aliases(            \n                IndexAliasArgs.builder()\n                    .name(\"my_alias_1\")\n                    .build(),\n                IndexAliasArgs.builder()\n                    .name(\"my_alias_2\")\n                    .filter(serializeJson(\n                        jsonObject(\n                            jsonProperty(\"term\", jsonObject(\n                                jsonProperty(\"user.id\", \"developer\")\n                            ))\n                        )))\n                    .build())\n            .mappings(serializeJson(\n                jsonObject(\n                    jsonProperty(\"properties\", jsonObject(\n                        jsonProperty(\"field1\", jsonObject(\n                            jsonProperty(\"type\", \"keyword\")\n                        )),\n                        jsonProperty(\"field2\", jsonObject(\n                            jsonProperty(\"type\", \"text\")\n                        )),\n                        jsonProperty(\"field3\", jsonObject(\n                            jsonProperty(\"properties\", jsonObject(\n                                jsonProperty(\"inner_field1\", jsonObject(\n                                    jsonProperty(\"type\", \"text\"),\n                                    jsonProperty(\"index\", false)\n                                )),\n                                jsonProperty(\"inner_field2\", jsonObject(\n                                    jsonProperty(\"type\", \"integer\"),\n                                    jsonProperty(\"index\", false)\n                                ))\n                            ))\n                        ))\n                    ))\n                )))\n            .numberOfShards(1)\n            .numberOfReplicas(2)\n            .searchIdleAfter(\"20s\")\n            .totalShardsPerNode(200)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIndex:\n    type: elasticstack:Index\n    properties:\n      aliases:\n        - name: my_alias_1\n        - name: my_alias_2\n          filter:\n            fn::toJSON:\n              term:\n                user.id: developer\n      mappings:\n        fn::toJSON:\n          properties:\n            field1:\n              type: keyword\n            field2:\n              type: text\n            field3:\n              properties:\n                inner_field1:\n                  type: text\n                  index: false\n                inner_field2:\n                  type: integer\n                  index: false\n      numberOfShards: 1\n      numberOfReplicas: 2\n      searchIdleAfter: 20s\n      totalShardsPerNode: 200\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can later adjust the index configuration to account for those imported settings. Some of the default settings, which could be imported are`index.number_of_replicas`, `index.number_of_shards` and `index.routing.allocation.include._tier_preference`. NOTEwhile importing index resource, keep in mind, that some of the default index settings will be imported into the TF state too You can later adjust the index configuration to account for those imported settings\n\n```sh\n $ pulumi import elasticstack:index/index:Index my_index \u003ccluster_uuid\u003e/\u003cindex_name\u003e\n```\n\n ",
            "properties": {
                "aliases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/IndexAlias:IndexAlias"
                    },
                    "description": "Aliases for the index.\n"
                },
                "analysisAnalyzer": {
                    "type": "string",
                    "description": "A JSON string describing the analyzers applied to the index.\n"
                },
                "analysisCharFilter": {
                    "type": "string",
                    "description": "A JSON string describing the char_filters applied to the index.\n"
                },
                "analysisFilter": {
                    "type": "string",
                    "description": "A JSON string describing the filters applied to the index.\n"
                },
                "analysisNormalizer": {
                    "type": "string",
                    "description": "A JSON string describing the normalizers applied to the index.\n"
                },
                "analysisTokenizer": {
                    "type": "string",
                    "description": "A JSON string describing the tokenizers applied to the index.\n"
                },
                "analyzeMaxTokenCount": {
                    "type": "integer",
                    "description": "The maximum number of tokens that can be produced using _analyze API.\n"
                },
                "autoExpandReplicas": {
                    "type": "string",
                    "description": "Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)\n"
                },
                "blocksMetadata": {
                    "type": "boolean",
                    "description": "Set to `true` to disable index metadata reads and writes.\n"
                },
                "blocksRead": {
                    "type": "boolean",
                    "description": "Set to `true` to disable read operations against the index.\n"
                },
                "blocksReadOnly": {
                    "type": "boolean",
                    "description": "Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.\n"
                },
                "blocksReadOnlyAllowDelete": {
                    "type": "boolean",
                    "description": "Identical to `index.blocks.read_only` but allows deleting the index to free up resources.\n"
                },
                "blocksWrite": {
                    "type": "boolean",
                    "description": "Set to `true` to disable data write operations against the index. This setting does not affect metadata.\n"
                },
                "codec": {
                    "type": "string",
                    "description": "The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.\n"
                },
                "defaultPipeline": {
                    "type": "string",
                    "description": "The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/IndexElasticsearchConnection:IndexElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "finalPipeline": {
                    "type": "string",
                    "description": "Final ingest pipeline for the index. Indexing requests will fail if the final pipeline is set and the pipeline does not exist. The final pipeline always runs after the request pipeline (if specified) and the default pipeline (if it exists). The special pipeline name _none indicates no ingest pipeline will run.\n"
                },
                "gcDeletes": {
                    "type": "string",
                    "description": "The length of time that a deleted document's version number remains available for further versioned operations.\n"
                },
                "highlightMaxAnalyzedOffset": {
                    "type": "integer",
                    "description": "The maximum number of characters that will be analyzed for a highlight request.\n"
                },
                "indexingSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "indexingSlowlogSource": {
                    "type": "string",
                    "description": "Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.\n"
                },
                "indexingSlowlogThresholdIndexDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`\n"
                },
                "indexingSlowlogThresholdIndexInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`\n"
                },
                "indexingSlowlogThresholdIndexTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`\n"
                },
                "indexingSlowlogThresholdIndexWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`\n"
                },
                "loadFixedBitsetFiltersEagerly": {
                    "type": "boolean",
                    "description": "Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.\n"
                },
                "mappings": {
                    "type": "string",
                    "description": "Mapping for fields in the index.\nIf specified, this mapping can include: field names, [field data types](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html), [mapping parameters](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html).\n**NOTE:** changing datatypes in the existing *mappings* will force index to be re-created.\n"
                },
                "maxDocvalueFieldsSearch": {
                    "type": "integer",
                    "description": "The maximum number of `docvalue_fields` that are allowed in a query.\n"
                },
                "maxInnerResultWindow": {
                    "type": "integer",
                    "description": "The maximum value of `from + size` for inner hits definition and top hits aggregations to this index.\n"
                },
                "maxNgramDiff": {
                    "type": "integer",
                    "description": "The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter.\n"
                },
                "maxRefreshListeners": {
                    "type": "integer",
                    "description": "Maximum number of refresh listeners available on each shard of the index.\n"
                },
                "maxRegexLength": {
                    "type": "integer",
                    "description": "The maximum length of regex that can be used in Regexp Query.\n"
                },
                "maxRescoreWindow": {
                    "type": "integer",
                    "description": "The maximum value of `window_size` for `rescore` requests in searches of this index.\n"
                },
                "maxResultWindow": {
                    "type": "integer",
                    "description": "The maximum value of `from + size` for searches to this index.\n"
                },
                "maxScriptFields": {
                    "type": "integer",
                    "description": "The maximum number of `script_fields` that are allowed in a query.\n"
                },
                "maxShingleDiff": {
                    "type": "integer",
                    "description": "The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter.\n"
                },
                "maxTermsCount": {
                    "type": "integer",
                    "description": "The maximum number of terms that can be used in Terms Query.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index you wish to create.\n"
                },
                "numberOfReplicas": {
                    "type": "integer",
                    "description": "Number of shard replicas.\n"
                },
                "numberOfRoutingShards": {
                    "type": "integer",
                    "description": "Value used with number*of*shards to route documents to a primary shard. This can be set only on creation.\n"
                },
                "numberOfShards": {
                    "type": "integer",
                    "description": "Number of shards for the index. This can be set only on creation.\n"
                },
                "queryDefaultFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Wildcard (*) patterns matching one or more fields. Defaults to '*', which matches all fields eligible for term-level queries, excluding metadata fields.\n"
                },
                "refreshInterval": {
                    "type": "string",
                    "description": "How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.\n"
                },
                "routingAllocationEnable": {
                    "type": "string",
                    "description": "Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.\n"
                },
                "routingPartitionSize": {
                    "type": "integer",
                    "description": "The number of shards a custom routing value can go to. This can be set only on creation.\n"
                },
                "routingRebalanceEnable": {
                    "type": "string",
                    "description": "Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.\n"
                },
                "searchIdleAfter": {
                    "type": "string",
                    "description": "How long a shard can not receive a search or get request until its considered search idle.\n"
                },
                "searchSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "searchSlowlogThresholdFetchDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdFetchInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdFetchTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdFetchWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`\n"
                },
                "searchSlowlogThresholdQueryDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdQueryInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdQueryTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdQueryWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`\n"
                },
                "settings": {
                    "$ref": "#/types/elasticstack:index/IndexSettings:IndexSettings",
                    "description": "DEPRECATED: Please use dedicated setting field. Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings.\n**NOTE:** Static index settings (see: https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#*static*index_settings) can be only set on the index creation and later cannot be removed or updated - *apply* will return error\n",
                    "deprecationMessage": "Using settings makes it easier to misconfigure.  Use dedicated field for the each setting instead."
                },
                "settingsRaw": {
                    "type": "string",
                    "description": "All raw settings fetched from the cluster.\n"
                },
                "shardCheckOnStartup": {
                    "type": "string",
                    "description": "Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.\n"
                },
                "sortFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The field to sort shards in this index by.\n"
                },
                "sortOrders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The direction to sort shards in. Accepts `asc`, `desc`.\n"
                },
                "unassignedNodeLeftDelayedTimeout": {
                    "type": "string",
                    "description": "Time to delay the allocation of replica shards which become unassigned because a node has left, in time units, e.g. `10s`\n"
                }
            },
            "required": [
                "name",
                "numberOfReplicas",
                "settingsRaw"
            ],
            "inputProperties": {
                "aliases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/IndexAlias:IndexAlias"
                    },
                    "description": "Aliases for the index.\n"
                },
                "analysisAnalyzer": {
                    "type": "string",
                    "description": "A JSON string describing the analyzers applied to the index.\n"
                },
                "analysisCharFilter": {
                    "type": "string",
                    "description": "A JSON string describing the char_filters applied to the index.\n"
                },
                "analysisFilter": {
                    "type": "string",
                    "description": "A JSON string describing the filters applied to the index.\n"
                },
                "analysisNormalizer": {
                    "type": "string",
                    "description": "A JSON string describing the normalizers applied to the index.\n"
                },
                "analysisTokenizer": {
                    "type": "string",
                    "description": "A JSON string describing the tokenizers applied to the index.\n"
                },
                "analyzeMaxTokenCount": {
                    "type": "integer",
                    "description": "The maximum number of tokens that can be produced using _analyze API.\n"
                },
                "autoExpandReplicas": {
                    "type": "string",
                    "description": "Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)\n"
                },
                "blocksMetadata": {
                    "type": "boolean",
                    "description": "Set to `true` to disable index metadata reads and writes.\n"
                },
                "blocksRead": {
                    "type": "boolean",
                    "description": "Set to `true` to disable read operations against the index.\n"
                },
                "blocksReadOnly": {
                    "type": "boolean",
                    "description": "Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.\n"
                },
                "blocksReadOnlyAllowDelete": {
                    "type": "boolean",
                    "description": "Identical to `index.blocks.read_only` but allows deleting the index to free up resources.\n"
                },
                "blocksWrite": {
                    "type": "boolean",
                    "description": "Set to `true` to disable data write operations against the index. This setting does not affect metadata.\n"
                },
                "codec": {
                    "type": "string",
                    "description": "The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "defaultPipeline": {
                    "type": "string",
                    "description": "The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/IndexElasticsearchConnection:IndexElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "finalPipeline": {
                    "type": "string",
                    "description": "Final ingest pipeline for the index. Indexing requests will fail if the final pipeline is set and the pipeline does not exist. The final pipeline always runs after the request pipeline (if specified) and the default pipeline (if it exists). The special pipeline name _none indicates no ingest pipeline will run.\n"
                },
                "gcDeletes": {
                    "type": "string",
                    "description": "The length of time that a deleted document's version number remains available for further versioned operations.\n"
                },
                "highlightMaxAnalyzedOffset": {
                    "type": "integer",
                    "description": "The maximum number of characters that will be analyzed for a highlight request.\n"
                },
                "indexingSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "indexingSlowlogSource": {
                    "type": "string",
                    "description": "Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.\n"
                },
                "indexingSlowlogThresholdIndexDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`\n"
                },
                "indexingSlowlogThresholdIndexInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`\n"
                },
                "indexingSlowlogThresholdIndexTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`\n"
                },
                "indexingSlowlogThresholdIndexWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`\n"
                },
                "loadFixedBitsetFiltersEagerly": {
                    "type": "boolean",
                    "description": "Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "mappings": {
                    "type": "string",
                    "description": "Mapping for fields in the index.\nIf specified, this mapping can include: field names, [field data types](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html), [mapping parameters](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html).\n**NOTE:** changing datatypes in the existing *mappings* will force index to be re-created.\n"
                },
                "maxDocvalueFieldsSearch": {
                    "type": "integer",
                    "description": "The maximum number of `docvalue_fields` that are allowed in a query.\n"
                },
                "maxInnerResultWindow": {
                    "type": "integer",
                    "description": "The maximum value of `from + size` for inner hits definition and top hits aggregations to this index.\n"
                },
                "maxNgramDiff": {
                    "type": "integer",
                    "description": "The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter.\n"
                },
                "maxRefreshListeners": {
                    "type": "integer",
                    "description": "Maximum number of refresh listeners available on each shard of the index.\n"
                },
                "maxRegexLength": {
                    "type": "integer",
                    "description": "The maximum length of regex that can be used in Regexp Query.\n"
                },
                "maxRescoreWindow": {
                    "type": "integer",
                    "description": "The maximum value of `window_size` for `rescore` requests in searches of this index.\n"
                },
                "maxResultWindow": {
                    "type": "integer",
                    "description": "The maximum value of `from + size` for searches to this index.\n"
                },
                "maxScriptFields": {
                    "type": "integer",
                    "description": "The maximum number of `script_fields` that are allowed in a query.\n"
                },
                "maxShingleDiff": {
                    "type": "integer",
                    "description": "The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter.\n"
                },
                "maxTermsCount": {
                    "type": "integer",
                    "description": "The maximum number of terms that can be used in Terms Query.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index you wish to create.\n",
                    "willReplaceOnChanges": true
                },
                "numberOfReplicas": {
                    "type": "integer",
                    "description": "Number of shard replicas.\n"
                },
                "numberOfRoutingShards": {
                    "type": "integer",
                    "description": "Value used with number*of*shards to route documents to a primary shard. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "numberOfShards": {
                    "type": "integer",
                    "description": "Number of shards for the index. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "queryDefaultFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Wildcard (*) patterns matching one or more fields. Defaults to '*', which matches all fields eligible for term-level queries, excluding metadata fields.\n"
                },
                "refreshInterval": {
                    "type": "string",
                    "description": "How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.\n"
                },
                "routingAllocationEnable": {
                    "type": "string",
                    "description": "Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.\n"
                },
                "routingPartitionSize": {
                    "type": "integer",
                    "description": "The number of shards a custom routing value can go to. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "routingRebalanceEnable": {
                    "type": "string",
                    "description": "Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.\n"
                },
                "searchIdleAfter": {
                    "type": "string",
                    "description": "How long a shard can not receive a search or get request until its considered search idle.\n"
                },
                "searchSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "searchSlowlogThresholdFetchDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdFetchInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdFetchTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdFetchWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`\n"
                },
                "searchSlowlogThresholdQueryDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdQueryInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdQueryTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdQueryWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`\n"
                },
                "settings": {
                    "$ref": "#/types/elasticstack:index/IndexSettings:IndexSettings",
                    "description": "DEPRECATED: Please use dedicated setting field. Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings.\n**NOTE:** Static index settings (see: https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#*static*index_settings) can be only set on the index creation and later cannot be removed or updated - *apply* will return error\n",
                    "deprecationMessage": "Using settings makes it easier to misconfigure.  Use dedicated field for the each setting instead."
                },
                "shardCheckOnStartup": {
                    "type": "string",
                    "description": "Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.\n",
                    "willReplaceOnChanges": true
                },
                "sortFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The field to sort shards in this index by.\n",
                    "willReplaceOnChanges": true
                },
                "sortOrders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The direction to sort shards in. Accepts `asc`, `desc`.\n",
                    "willReplaceOnChanges": true
                },
                "unassignedNodeLeftDelayedTimeout": {
                    "type": "string",
                    "description": "Time to delay the allocation of replica shards which become unassigned because a node has left, in time units, e.g. `10s`\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Index resources.\n",
                "properties": {
                    "aliases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/IndexAlias:IndexAlias"
                        },
                        "description": "Aliases for the index.\n"
                    },
                    "analysisAnalyzer": {
                        "type": "string",
                        "description": "A JSON string describing the analyzers applied to the index.\n"
                    },
                    "analysisCharFilter": {
                        "type": "string",
                        "description": "A JSON string describing the char_filters applied to the index.\n"
                    },
                    "analysisFilter": {
                        "type": "string",
                        "description": "A JSON string describing the filters applied to the index.\n"
                    },
                    "analysisNormalizer": {
                        "type": "string",
                        "description": "A JSON string describing the normalizers applied to the index.\n"
                    },
                    "analysisTokenizer": {
                        "type": "string",
                        "description": "A JSON string describing the tokenizers applied to the index.\n"
                    },
                    "analyzeMaxTokenCount": {
                        "type": "integer",
                        "description": "The maximum number of tokens that can be produced using _analyze API.\n"
                    },
                    "autoExpandReplicas": {
                        "type": "string",
                        "description": "Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)\n"
                    },
                    "blocksMetadata": {
                        "type": "boolean",
                        "description": "Set to `true` to disable index metadata reads and writes.\n"
                    },
                    "blocksRead": {
                        "type": "boolean",
                        "description": "Set to `true` to disable read operations against the index.\n"
                    },
                    "blocksReadOnly": {
                        "type": "boolean",
                        "description": "Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.\n"
                    },
                    "blocksReadOnlyAllowDelete": {
                        "type": "boolean",
                        "description": "Identical to `index.blocks.read_only` but allows deleting the index to free up resources.\n"
                    },
                    "blocksWrite": {
                        "type": "boolean",
                        "description": "Set to `true` to disable data write operations against the index. This setting does not affect metadata.\n"
                    },
                    "codec": {
                        "type": "string",
                        "description": "The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "defaultPipeline": {
                        "type": "string",
                        "description": "The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.\n"
                    },
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/IndexElasticsearchConnection:IndexElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "finalPipeline": {
                        "type": "string",
                        "description": "Final ingest pipeline for the index. Indexing requests will fail if the final pipeline is set and the pipeline does not exist. The final pipeline always runs after the request pipeline (if specified) and the default pipeline (if it exists). The special pipeline name _none indicates no ingest pipeline will run.\n"
                    },
                    "gcDeletes": {
                        "type": "string",
                        "description": "The length of time that a deleted document's version number remains available for further versioned operations.\n"
                    },
                    "highlightMaxAnalyzedOffset": {
                        "type": "integer",
                        "description": "The maximum number of characters that will be analyzed for a highlight request.\n"
                    },
                    "indexingSlowlogLevel": {
                        "type": "string",
                        "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                    },
                    "indexingSlowlogSource": {
                        "type": "string",
                        "description": "Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.\n"
                    },
                    "indexingSlowlogThresholdIndexDebug": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`\n"
                    },
                    "indexingSlowlogThresholdIndexInfo": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`\n"
                    },
                    "indexingSlowlogThresholdIndexTrace": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`\n"
                    },
                    "indexingSlowlogThresholdIndexWarn": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`\n"
                    },
                    "loadFixedBitsetFiltersEagerly": {
                        "type": "boolean",
                        "description": "Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "mappings": {
                        "type": "string",
                        "description": "Mapping for fields in the index.\nIf specified, this mapping can include: field names, [field data types](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html), [mapping parameters](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html).\n**NOTE:** changing datatypes in the existing *mappings* will force index to be re-created.\n"
                    },
                    "maxDocvalueFieldsSearch": {
                        "type": "integer",
                        "description": "The maximum number of `docvalue_fields` that are allowed in a query.\n"
                    },
                    "maxInnerResultWindow": {
                        "type": "integer",
                        "description": "The maximum value of `from + size` for inner hits definition and top hits aggregations to this index.\n"
                    },
                    "maxNgramDiff": {
                        "type": "integer",
                        "description": "The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter.\n"
                    },
                    "maxRefreshListeners": {
                        "type": "integer",
                        "description": "Maximum number of refresh listeners available on each shard of the index.\n"
                    },
                    "maxRegexLength": {
                        "type": "integer",
                        "description": "The maximum length of regex that can be used in Regexp Query.\n"
                    },
                    "maxRescoreWindow": {
                        "type": "integer",
                        "description": "The maximum value of `window_size` for `rescore` requests in searches of this index.\n"
                    },
                    "maxResultWindow": {
                        "type": "integer",
                        "description": "The maximum value of `from + size` for searches to this index.\n"
                    },
                    "maxScriptFields": {
                        "type": "integer",
                        "description": "The maximum number of `script_fields` that are allowed in a query.\n"
                    },
                    "maxShingleDiff": {
                        "type": "integer",
                        "description": "The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter.\n"
                    },
                    "maxTermsCount": {
                        "type": "integer",
                        "description": "The maximum number of terms that can be used in Terms Query.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the index you wish to create.\n",
                        "willReplaceOnChanges": true
                    },
                    "numberOfReplicas": {
                        "type": "integer",
                        "description": "Number of shard replicas.\n"
                    },
                    "numberOfRoutingShards": {
                        "type": "integer",
                        "description": "Value used with number*of*shards to route documents to a primary shard. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "numberOfShards": {
                        "type": "integer",
                        "description": "Number of shards for the index. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "queryDefaultFields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Wildcard (*) patterns matching one or more fields. Defaults to '*', which matches all fields eligible for term-level queries, excluding metadata fields.\n"
                    },
                    "refreshInterval": {
                        "type": "string",
                        "description": "How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.\n"
                    },
                    "routingAllocationEnable": {
                        "type": "string",
                        "description": "Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.\n"
                    },
                    "routingPartitionSize": {
                        "type": "integer",
                        "description": "The number of shards a custom routing value can go to. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "routingRebalanceEnable": {
                        "type": "string",
                        "description": "Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.\n"
                    },
                    "searchIdleAfter": {
                        "type": "string",
                        "description": "How long a shard can not receive a search or get request until its considered search idle.\n"
                    },
                    "searchSlowlogLevel": {
                        "type": "string",
                        "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                    },
                    "searchSlowlogThresholdFetchDebug": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`\n"
                    },
                    "searchSlowlogThresholdFetchInfo": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`\n"
                    },
                    "searchSlowlogThresholdFetchTrace": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`\n"
                    },
                    "searchSlowlogThresholdFetchWarn": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`\n"
                    },
                    "searchSlowlogThresholdQueryDebug": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`\n"
                    },
                    "searchSlowlogThresholdQueryInfo": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`\n"
                    },
                    "searchSlowlogThresholdQueryTrace": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`\n"
                    },
                    "searchSlowlogThresholdQueryWarn": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`\n"
                    },
                    "settings": {
                        "$ref": "#/types/elasticstack:index/IndexSettings:IndexSettings",
                        "description": "DEPRECATED: Please use dedicated setting field. Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings.\n**NOTE:** Static index settings (see: https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#*static*index_settings) can be only set on the index creation and later cannot be removed or updated - *apply* will return error\n",
                        "deprecationMessage": "Using settings makes it easier to misconfigure.  Use dedicated field for the each setting instead."
                    },
                    "settingsRaw": {
                        "type": "string",
                        "description": "All raw settings fetched from the cluster.\n"
                    },
                    "shardCheckOnStartup": {
                        "type": "string",
                        "description": "Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.\n",
                        "willReplaceOnChanges": true
                    },
                    "sortFields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The field to sort shards in this index by.\n",
                        "willReplaceOnChanges": true
                    },
                    "sortOrders": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The direction to sort shards in. Accepts `asc`, `desc`.\n",
                        "willReplaceOnChanges": true
                    },
                    "unassignedNodeLeftDelayedTimeout": {
                        "type": "string",
                        "description": "Time to delay the allocation of replica shards which become unassigned because a node has left, in time units, e.g. `10s`\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/indexLifecycle:IndexLifecycle": {
            "description": "Creates or updates lifecycle policy. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-put-lifecycle.html and https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-index-lifecycle.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst myIlm = new elasticstack.IndexLifecycle(\"myIlm\", {\n    hot: {\n        minAge: \"1h\",\n        setPriority: {\n            priority: 0,\n        },\n        rollover: {\n            maxAge: \"1d\",\n        },\n        readonly: {},\n    },\n    warm: {\n        minAge: \"0ms\",\n        setPriority: {\n            priority: 10,\n        },\n        readonly: {},\n        allocate: {\n            exclude: JSON.stringify({\n                box_type: \"hot\",\n            }),\n            numberOfReplicas: 1,\n            totalShardsPerNode: 200,\n        },\n    },\n    \"delete\": {\n        minAge: \"2d\",\n        \"delete\": {},\n    },\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_elasticstack as elasticstack\n\nmy_ilm = elasticstack.IndexLifecycle(\"myIlm\",\n    hot=elasticstack.IndexLifecycleHotArgs(\n        min_age=\"1h\",\n        set_priority=elasticstack.IndexLifecycleHotSetPriorityArgs(\n            priority=0,\n        ),\n        rollover=elasticstack.IndexLifecycleHotRolloverArgs(\n            max_age=\"1d\",\n        ),\n        readonly=elasticstack.IndexLifecycleHotReadonlyArgs(),\n    ),\n    warm=elasticstack.IndexLifecycleWarmArgs(\n        min_age=\"0ms\",\n        set_priority=elasticstack.IndexLifecycleWarmSetPriorityArgs(\n            priority=10,\n        ),\n        readonly=elasticstack.IndexLifecycleWarmReadonlyArgs(),\n        allocate=elasticstack.IndexLifecycleWarmAllocateArgs(\n            exclude=json.dumps({\n                \"box_type\": \"hot\",\n            }),\n            number_of_replicas=1,\n            total_shards_per_node=200,\n        ),\n    ),\n    delete=elasticstack.IndexLifecycleDeleteArgs(\n        min_age=\"2d\",\n        delete=elasticstack.IndexLifecycleDeleteDeleteArgs(),\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myIlm = new Elasticstack.IndexLifecycle(\"myIlm\", new()\n    {\n        Hot = new Elasticstack.Inputs.IndexLifecycleHotArgs\n        {\n            MinAge = \"1h\",\n            SetPriority = new Elasticstack.Inputs.IndexLifecycleHotSetPriorityArgs\n            {\n                Priority = 0,\n            },\n            Rollover = new Elasticstack.Inputs.IndexLifecycleHotRolloverArgs\n            {\n                MaxAge = \"1d\",\n            },\n            Readonly = null,\n        },\n        Warm = new Elasticstack.Inputs.IndexLifecycleWarmArgs\n        {\n            MinAge = \"0ms\",\n            SetPriority = new Elasticstack.Inputs.IndexLifecycleWarmSetPriorityArgs\n            {\n                Priority = 10,\n            },\n            Readonly = null,\n            Allocate = new Elasticstack.Inputs.IndexLifecycleWarmAllocateArgs\n            {\n                Exclude = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"box_type\"] = \"hot\",\n                }),\n                NumberOfReplicas = 1,\n                TotalShardsPerNode = 200,\n            },\n        },\n        Delete = new Elasticstack.Inputs.IndexLifecycleDeleteArgs\n        {\n            MinAge = \"2d\",\n            Delete = null,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"box_type\": \"hot\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = elasticstack.NewIndexLifecycle(ctx, \"myIlm\", \u0026elasticstack.IndexLifecycleArgs{\n\t\t\tHot: \u0026elasticstack.IndexLifecycleHotArgs{\n\t\t\t\tMinAge: pulumi.String(\"1h\"),\n\t\t\t\tSetPriority: \u0026elasticstack.IndexLifecycleHotSetPriorityArgs{\n\t\t\t\t\tPriority: pulumi.Int(0),\n\t\t\t\t},\n\t\t\t\tRollover: \u0026elasticstack.IndexLifecycleHotRolloverArgs{\n\t\t\t\t\tMaxAge: pulumi.String(\"1d\"),\n\t\t\t\t},\n\t\t\t\tReadonly: nil,\n\t\t\t},\n\t\t\tWarm: \u0026elasticstack.IndexLifecycleWarmArgs{\n\t\t\t\tMinAge: pulumi.String(\"0ms\"),\n\t\t\t\tSetPriority: \u0026elasticstack.IndexLifecycleWarmSetPriorityArgs{\n\t\t\t\t\tPriority: pulumi.Int(10),\n\t\t\t\t},\n\t\t\t\tReadonly: nil,\n\t\t\t\tAllocate: \u0026elasticstack.IndexLifecycleWarmAllocateArgs{\n\t\t\t\t\tExclude:            pulumi.String(json0),\n\t\t\t\t\tNumberOfReplicas:   pulumi.Int(1),\n\t\t\t\t\tTotalShardsPerNode: pulumi.Int(200),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDelete: \u0026elasticstack.IndexLifecycleDeleteArgs{\n\t\t\t\tMinAge: pulumi.String(\"2d\"),\n\t\t\t\tDelete: nil,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.IndexLifecycle;\nimport com.pulumi.elasticstack.IndexLifecycleArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleHotArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleHotSetPriorityArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleHotRolloverArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleHotReadonlyArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleWarmArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleWarmSetPriorityArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleWarmReadonlyArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleWarmAllocateArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleDeleteArgs;\nimport com.pulumi.elasticstack.inputs.IndexLifecycleDeleteDeleteArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myIlm = new IndexLifecycle(\"myIlm\", IndexLifecycleArgs.builder()        \n            .hot(IndexLifecycleHotArgs.builder()\n                .minAge(\"1h\")\n                .setPriority(IndexLifecycleHotSetPriorityArgs.builder()\n                    .priority(0)\n                    .build())\n                .rollover(IndexLifecycleHotRolloverArgs.builder()\n                    .maxAge(\"1d\")\n                    .build())\n                .readonly()\n                .build())\n            .warm(IndexLifecycleWarmArgs.builder()\n                .minAge(\"0ms\")\n                .setPriority(IndexLifecycleWarmSetPriorityArgs.builder()\n                    .priority(10)\n                    .build())\n                .readonly()\n                .allocate(IndexLifecycleWarmAllocateArgs.builder()\n                    .exclude(serializeJson(\n                        jsonObject(\n                            jsonProperty(\"box_type\", \"hot\")\n                        )))\n                    .numberOfReplicas(1)\n                    .totalShardsPerNode(200)\n                    .build())\n                .build())\n            .delete(IndexLifecycleDeleteArgs.builder()\n                .minAge(\"2d\")\n                .delete()\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIlm:\n    type: elasticstack:IndexLifecycle\n    properties:\n      hot:\n        minAge: 1h\n        setPriority:\n          priority: 0\n        rollover:\n          maxAge: 1d\n        readonly: {}\n      warm:\n        minAge: 0ms\n        setPriority:\n          priority: 10\n        readonly: {}\n        allocate:\n          exclude:\n            fn::toJSON:\n              box_type: hot\n          numberOfReplicas: 1\n          totalShardsPerNode: 200\n      delete:\n        minAge: 2d\n        delete: {}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/indexLifecycle:IndexLifecycle my_ilm \u003ccluster_uuid\u003e/\u003cilm_name\u003e\n```\n\n ",
            "properties": {
                "cold": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleCold:IndexLifecycleCold",
                    "description": "The index is no longer being updated and is queried infrequently. The information still needs to be searchable, but its okay if those queries are slower.\n"
                },
                "delete": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleDelete:IndexLifecycleDelete",
                    "description": "The index is no longer needed and can safely be removed.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleElasticsearchConnection:IndexLifecycleElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "frozen": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleFrozen:IndexLifecycleFrozen",
                    "description": "The index is no longer being updated and is queried rarely. The information still needs to be searchable, but its okay if those queries are extremely slow.\n"
                },
                "hot": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleHot:IndexLifecycleHot",
                    "description": "The index is actively being updated and queried.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Optional user metadata about the ilm policy. Must be valid JSON document.\n"
                },
                "modifiedDate": {
                    "type": "string",
                    "description": "The DateTime of the last modification.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the policy.\n"
                },
                "warm": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleWarm:IndexLifecycleWarm",
                    "description": "The index is no longer being updated but is still being queried.\n"
                }
            },
            "required": [
                "modifiedDate",
                "name"
            ],
            "inputProperties": {
                "cold": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleCold:IndexLifecycleCold",
                    "description": "The index is no longer being updated and is queried infrequently. The information still needs to be searchable, but its okay if those queries are slower.\n"
                },
                "delete": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleDelete:IndexLifecycleDelete",
                    "description": "The index is no longer needed and can safely be removed.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleElasticsearchConnection:IndexLifecycleElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "frozen": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleFrozen:IndexLifecycleFrozen",
                    "description": "The index is no longer being updated and is queried rarely. The information still needs to be searchable, but its okay if those queries are extremely slow.\n"
                },
                "hot": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleHot:IndexLifecycleHot",
                    "description": "The index is actively being updated and queried.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Optional user metadata about the ilm policy. Must be valid JSON document.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the policy.\n",
                    "willReplaceOnChanges": true
                },
                "warm": {
                    "$ref": "#/types/elasticstack:index/IndexLifecycleWarm:IndexLifecycleWarm",
                    "description": "The index is no longer being updated but is still being queried.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IndexLifecycle resources.\n",
                "properties": {
                    "cold": {
                        "$ref": "#/types/elasticstack:index/IndexLifecycleCold:IndexLifecycleCold",
                        "description": "The index is no longer being updated and is queried infrequently. The information still needs to be searchable, but its okay if those queries are slower.\n"
                    },
                    "delete": {
                        "$ref": "#/types/elasticstack:index/IndexLifecycleDelete:IndexLifecycleDelete",
                        "description": "The index is no longer needed and can safely be removed.\n"
                    },
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/IndexLifecycleElasticsearchConnection:IndexLifecycleElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "frozen": {
                        "$ref": "#/types/elasticstack:index/IndexLifecycleFrozen:IndexLifecycleFrozen",
                        "description": "The index is no longer being updated and is queried rarely. The information still needs to be searchable, but its okay if those queries are extremely slow.\n"
                    },
                    "hot": {
                        "$ref": "#/types/elasticstack:index/IndexLifecycleHot:IndexLifecycleHot",
                        "description": "The index is actively being updated and queried.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Optional user metadata about the ilm policy. Must be valid JSON document.\n"
                    },
                    "modifiedDate": {
                        "type": "string",
                        "description": "The DateTime of the last modification.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Identifier for the policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "warm": {
                        "$ref": "#/types/elasticstack:index/IndexLifecycleWarm:IndexLifecycleWarm",
                        "description": "The index is no longer being updated but is still being queried.\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/indexTemplate:IndexTemplate": {
            "description": "Creates or updates an index template. Index templates define settings, mappings, and aliases that can be applied automatically to new indices. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-template.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst myTemplate = new elasticstack.IndexTemplate(\"myTemplate\", {\n    priority: 42,\n    indexPatterns: [\n        \"logstash*\",\n        \"filebeat*\",\n    ],\n    template: {\n        aliases: [\n            {\n                name: \"my_template_test\",\n            },\n            {\n                name: \"another_test\",\n            },\n        ],\n        settings: JSON.stringify({\n            number_of_shards: \"3\",\n        }),\n    },\n});\nconst myDataStream = new elasticstack.IndexTemplate(\"myDataStream\", {\n    indexPatterns: [\"stream*\"],\n    dataStream: {},\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_elasticstack as elasticstack\n\nmy_template = elasticstack.IndexTemplate(\"myTemplate\",\n    priority=42,\n    index_patterns=[\n        \"logstash*\",\n        \"filebeat*\",\n    ],\n    template=elasticstack.IndexTemplateTemplateArgs(\n        aliases=[\n            elasticstack.IndexTemplateTemplateAliasArgs(\n                name=\"my_template_test\",\n            ),\n            elasticstack.IndexTemplateTemplateAliasArgs(\n                name=\"another_test\",\n            ),\n        ],\n        settings=json.dumps({\n            \"number_of_shards\": \"3\",\n        }),\n    ))\nmy_data_stream = elasticstack.IndexTemplate(\"myDataStream\",\n    index_patterns=[\"stream*\"],\n    data_stream=elasticstack.IndexTemplateDataStreamArgs())\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myTemplate = new Elasticstack.IndexTemplate(\"myTemplate\", new()\n    {\n        Priority = 42,\n        IndexPatterns = new[]\n        {\n            \"logstash*\",\n            \"filebeat*\",\n        },\n        Template = new Elasticstack.Inputs.IndexTemplateTemplateArgs\n        {\n            Aliases = new[]\n            {\n                new Elasticstack.Inputs.IndexTemplateTemplateAliasArgs\n                {\n                    Name = \"my_template_test\",\n                },\n                new Elasticstack.Inputs.IndexTemplateTemplateAliasArgs\n                {\n                    Name = \"another_test\",\n                },\n            },\n            Settings = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n            {\n                [\"number_of_shards\"] = \"3\",\n            }),\n        },\n    });\n\n    var myDataStream = new Elasticstack.IndexTemplate(\"myDataStream\", new()\n    {\n        IndexPatterns = new[]\n        {\n            \"stream*\",\n        },\n        DataStream = null,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"number_of_shards\": \"3\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = elasticstack.NewIndexTemplate(ctx, \"myTemplate\", \u0026elasticstack.IndexTemplateArgs{\n\t\t\tPriority: pulumi.Int(42),\n\t\t\tIndexPatterns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"logstash*\"),\n\t\t\t\tpulumi.String(\"filebeat*\"),\n\t\t\t},\n\t\t\tTemplate: \u0026elasticstack.IndexTemplateTemplateArgs{\n\t\t\t\tAliases: elasticstack.IndexTemplateTemplateAliasArray{\n\t\t\t\t\t\u0026elasticstack.IndexTemplateTemplateAliasArgs{\n\t\t\t\t\t\tName: pulumi.String(\"my_template_test\"),\n\t\t\t\t\t},\n\t\t\t\t\t\u0026elasticstack.IndexTemplateTemplateAliasArgs{\n\t\t\t\t\t\tName: pulumi.String(\"another_test\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSettings: pulumi.String(json0),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIndexTemplate(ctx, \"myDataStream\", \u0026elasticstack.IndexTemplateArgs{\n\t\t\tIndexPatterns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"stream*\"),\n\t\t\t},\n\t\t\tDataStream: nil,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.IndexTemplate;\nimport com.pulumi.elasticstack.IndexTemplateArgs;\nimport com.pulumi.elasticstack.inputs.IndexTemplateTemplateArgs;\nimport com.pulumi.elasticstack.inputs.IndexTemplateDataStreamArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myTemplate = new IndexTemplate(\"myTemplate\", IndexTemplateArgs.builder()        \n            .priority(42)\n            .indexPatterns(            \n                \"logstash*\",\n                \"filebeat*\")\n            .template(IndexTemplateTemplateArgs.builder()\n                .aliases(                \n                    IndexTemplateTemplateAliasArgs.builder()\n                        .name(\"my_template_test\")\n                        .build(),\n                    IndexTemplateTemplateAliasArgs.builder()\n                        .name(\"another_test\")\n                        .build())\n                .settings(serializeJson(\n                    jsonObject(\n                        jsonProperty(\"number_of_shards\", \"3\")\n                    )))\n                .build())\n            .build());\n\n        var myDataStream = new IndexTemplate(\"myDataStream\", IndexTemplateArgs.builder()        \n            .indexPatterns(\"stream*\")\n            .dataStream()\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myTemplate:\n    type: elasticstack:IndexTemplate\n    properties:\n      priority: 42\n      indexPatterns:\n        - logstash*\n        - filebeat*\n      template:\n        aliases:\n          - name: my_template_test\n          - name: another_test\n        settings:\n          fn::toJSON:\n            number_of_shards: '3'\n  myDataStream:\n    type: elasticstack:IndexTemplate\n    properties:\n      indexPatterns:\n        - stream*\n      dataStream: {}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/indexTemplate:IndexTemplate my_template \u003ccluster_uuid\u003e/\u003ctemplate_name\u003e\n```\n\n ",
            "properties": {
                "composedOfs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An ordered list of component template names.\n"
                },
                "dataStream": {
                    "$ref": "#/types/elasticstack:index/IndexTemplateDataStream:IndexTemplateDataStream",
                    "description": "If this object is included, the template is used to create data streams and their backing indices. Supports an empty object.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/IndexTemplateElasticsearchConnection:IndexTemplateElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "indexPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of wildcard (*) expressions used to match the names of data streams and indices during creation.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Optional user metadata about the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index template to create.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority to determine index template precedence when a new data stream or index is created.\n"
                },
                "template": {
                    "$ref": "#/types/elasticstack:index/IndexTemplateTemplate:IndexTemplateTemplate",
                    "description": "Template to be applied. It may optionally include an aliases, mappings, or settings configuration.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "Version number used to manage index templates externally.\n"
                }
            },
            "required": [
                "composedOfs",
                "indexPatterns",
                "name"
            ],
            "inputProperties": {
                "composedOfs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An ordered list of component template names.\n"
                },
                "dataStream": {
                    "$ref": "#/types/elasticstack:index/IndexTemplateDataStream:IndexTemplateDataStream",
                    "description": "If this object is included, the template is used to create data streams and their backing indices. Supports an empty object.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/IndexTemplateElasticsearchConnection:IndexTemplateElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "indexPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of wildcard (*) expressions used to match the names of data streams and indices during creation.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Optional user metadata about the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index template to create.\n",
                    "willReplaceOnChanges": true
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority to determine index template precedence when a new data stream or index is created.\n"
                },
                "template": {
                    "$ref": "#/types/elasticstack:index/IndexTemplateTemplate:IndexTemplateTemplate",
                    "description": "Template to be applied. It may optionally include an aliases, mappings, or settings configuration.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "Version number used to manage index templates externally.\n"
                }
            },
            "requiredInputs": [
                "indexPatterns"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IndexTemplate resources.\n",
                "properties": {
                    "composedOfs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An ordered list of component template names.\n"
                    },
                    "dataStream": {
                        "$ref": "#/types/elasticstack:index/IndexTemplateDataStream:IndexTemplateDataStream",
                        "description": "If this object is included, the template is used to create data streams and their backing indices. Supports an empty object.\n"
                    },
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/IndexTemplateElasticsearchConnection:IndexTemplateElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "indexPatterns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of wildcard (*) expressions used to match the names of data streams and indices during creation.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Optional user metadata about the index template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the index template to create.\n",
                        "willReplaceOnChanges": true
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority to determine index template precedence when a new data stream or index is created.\n"
                    },
                    "template": {
                        "$ref": "#/types/elasticstack:index/IndexTemplateTemplate:IndexTemplateTemplate",
                        "description": "Template to be applied. It may optionally include an aliases, mappings, or settings configuration.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "Version number used to manage index templates externally.\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/ingestPipeline:IngestPipeline": {
            "description": "\n\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/ingestPipeline:IngestPipeline my_ingest_pipeline \u003ccluster_uuid\u003e/\u003cingest pipeline name\u003e\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the ingest pipeline.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/IngestPipelineElasticsearchConnection:IngestPipelineElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Optional user metadata about the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ingest pipeline.\n"
                },
                "onFailures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Processors to run immediately after a processor failure. Each processor supports a processor-level `on_failure` value. If a processor without an `on_failure` value fails, Elasticsearch uses this pipeline-level parameter as a fallback. The processors in this parameter run sequentially in the order specified. Elasticsearch will not attempt to run the pipelines remaining processors. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/processors.html. Each record must be a valid JSON document\n"
                },
                "processors": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Processors used to perform transformations on documents before indexing. Processors run sequentially in the order specified. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/processors.html. Each record must be a valid JSON document.\n"
                }
            },
            "required": [
                "name",
                "processors"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the ingest pipeline.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/IngestPipelineElasticsearchConnection:IngestPipelineElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Optional user metadata about the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ingest pipeline.\n",
                    "willReplaceOnChanges": true
                },
                "onFailures": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Processors to run immediately after a processor failure. Each processor supports a processor-level `on_failure` value. If a processor without an `on_failure` value fails, Elasticsearch uses this pipeline-level parameter as a fallback. The processors in this parameter run sequentially in the order specified. Elasticsearch will not attempt to run the pipelines remaining processors. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/processors.html. Each record must be a valid JSON document\n"
                },
                "processors": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Processors used to perform transformations on documents before indexing. Processors run sequentially in the order specified. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/processors.html. Each record must be a valid JSON document.\n"
                }
            },
            "requiredInputs": [
                "processors"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IngestPipeline resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the ingest pipeline.\n"
                    },
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/IngestPipelineElasticsearchConnection:IngestPipelineElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Optional user metadata about the index template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ingest pipeline.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Processors to run immediately after a processor failure. Each processor supports a processor-level `on_failure` value. If a processor without an `on_failure` value fails, Elasticsearch uses this pipeline-level parameter as a fallback. The processors in this parameter run sequentially in the order specified. Elasticsearch will not attempt to run the pipelines remaining processors. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/processors.html. Each record must be a valid JSON document\n"
                    },
                    "processors": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Processors used to perform transformations on documents before indexing. Processors run sequentially in the order specified. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/processors.html. Each record must be a valid JSON document.\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/logstashPipeline:LogstashPipeline": {
            "description": "Creates or updates centrally managed logstash pipelines. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/logstash-apis.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst example = new elasticstack.LogstashPipeline(\"example\", {\n    pipelineId: \"test_pipeline\",\n    description: \"This is an example pipeline\",\n    pipeline: `input{}\nfilter{}\noutput{}\n`,\n    pipelineMetadata: {\n        type: \"logstash_pipeline\",\n        version: \"1\",\n    },\n    pipelineBatchDelay: 50,\n    pipelineBatchSize: 125,\n    pipelineEcsCompatibility: \"disabled\",\n    pipelineOrdered: \"auto\",\n    pipelinePluginClassloaders: false,\n    pipelineUnsafeShutdown: false,\n    pipelineWorkers: 1,\n    queueCheckpointAcks: 1024,\n    queueCheckpointRetry: true,\n    queueCheckpointWrites: 1024,\n    queueDrain: false,\n    queueMaxBytesNumber: 1,\n    queueMaxBytesUnits: \"gb\",\n    queueMaxEvents: 0,\n    queuePageCapacity: \"64mb\",\n    queueType: \"persisted\",\n});\nexport const pipeline = example.pipelineId;\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nexample = elasticstack.LogstashPipeline(\"example\",\n    pipeline_id=\"test_pipeline\",\n    description=\"This is an example pipeline\",\n    pipeline=\"\"\"input{}\nfilter{}\noutput{}\n\"\"\",\n    pipeline_metadata={\n        \"type\": \"logstash_pipeline\",\n        \"version\": \"1\",\n    },\n    pipeline_batch_delay=50,\n    pipeline_batch_size=125,\n    pipeline_ecs_compatibility=\"disabled\",\n    pipeline_ordered=\"auto\",\n    pipeline_plugin_classloaders=False,\n    pipeline_unsafe_shutdown=False,\n    pipeline_workers=1,\n    queue_checkpoint_acks=1024,\n    queue_checkpoint_retry=True,\n    queue_checkpoint_writes=1024,\n    queue_drain=False,\n    queue_max_bytes_number=1,\n    queue_max_bytes_units=\"gb\",\n    queue_max_events=0,\n    queue_page_capacity=\"64mb\",\n    queue_type=\"persisted\")\npulumi.export(\"pipeline\", example.pipeline_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Elasticstack.LogstashPipeline(\"example\", new()\n    {\n        PipelineId = \"test_pipeline\",\n        Description = \"This is an example pipeline\",\n        Pipeline = @\"input{}\nfilter{}\noutput{}\n\",\n        PipelineMetadata = \n        {\n            { \"type\", \"logstash_pipeline\" },\n            { \"version\", \"1\" },\n        },\n        PipelineBatchDelay = 50,\n        PipelineBatchSize = 125,\n        PipelineEcsCompatibility = \"disabled\",\n        PipelineOrdered = \"auto\",\n        PipelinePluginClassloaders = false,\n        PipelineUnsafeShutdown = false,\n        PipelineWorkers = 1,\n        QueueCheckpointAcks = 1024,\n        QueueCheckpointRetry = true,\n        QueueCheckpointWrites = 1024,\n        QueueDrain = false,\n        QueueMaxBytesNumber = 1,\n        QueueMaxBytesUnits = \"gb\",\n        QueueMaxEvents = 0,\n        QueuePageCapacity = \"64mb\",\n        QueueType = \"persisted\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"pipeline\"] = example.PipelineId,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := elasticstack.NewLogstashPipeline(ctx, \"example\", \u0026elasticstack.LogstashPipelineArgs{\n\t\t\tPipelineId:  pulumi.String(\"test_pipeline\"),\n\t\t\tDescription: pulumi.String(\"This is an example pipeline\"),\n\t\t\tPipeline:    pulumi.String(fmt.Sprintf(\"input{}\\nfilter{}\\noutput{}\\n\")),\n\t\t\tPipelineMetadata: pulumi.StringMap{\n\t\t\t\t\"type\":    pulumi.String(\"logstash_pipeline\"),\n\t\t\t\t\"version\": pulumi.String(\"1\"),\n\t\t\t},\n\t\t\tPipelineBatchDelay:         pulumi.Int(50),\n\t\t\tPipelineBatchSize:          pulumi.Int(125),\n\t\t\tPipelineEcsCompatibility:   pulumi.String(\"disabled\"),\n\t\t\tPipelineOrdered:            pulumi.String(\"auto\"),\n\t\t\tPipelinePluginClassloaders: pulumi.Bool(false),\n\t\t\tPipelineUnsafeShutdown:     pulumi.Bool(false),\n\t\t\tPipelineWorkers:            pulumi.Int(1),\n\t\t\tQueueCheckpointAcks:        pulumi.Int(1024),\n\t\t\tQueueCheckpointRetry:       pulumi.Bool(true),\n\t\t\tQueueCheckpointWrites:      pulumi.Int(1024),\n\t\t\tQueueDrain:                 pulumi.Bool(false),\n\t\t\tQueueMaxBytesNumber:        pulumi.Int(1),\n\t\t\tQueueMaxBytesUnits:         pulumi.String(\"gb\"),\n\t\t\tQueueMaxEvents:             pulumi.Int(0),\n\t\t\tQueuePageCapacity:          pulumi.String(\"64mb\"),\n\t\t\tQueueType:                  pulumi.String(\"persisted\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"pipeline\", example.PipelineId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.LogstashPipeline;\nimport com.pulumi.elasticstack.LogstashPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new LogstashPipeline(\"example\", LogstashPipelineArgs.builder()        \n            .pipelineId(\"test_pipeline\")\n            .description(\"This is an example pipeline\")\n            .pipeline(\"\"\"\ninput{}\nfilter{}\noutput{}\n            \"\"\")\n            .pipelineMetadata(Map.ofEntries(\n                Map.entry(\"type\", \"logstash_pipeline\"),\n                Map.entry(\"version\", 1)\n            ))\n            .pipelineBatchDelay(50)\n            .pipelineBatchSize(125)\n            .pipelineEcsCompatibility(\"disabled\")\n            .pipelineOrdered(\"auto\")\n            .pipelinePluginClassloaders(false)\n            .pipelineUnsafeShutdown(false)\n            .pipelineWorkers(1)\n            .queueCheckpointAcks(1024)\n            .queueCheckpointRetry(true)\n            .queueCheckpointWrites(1024)\n            .queueDrain(false)\n            .queueMaxBytesNumber(1)\n            .queueMaxBytesUnits(\"gb\")\n            .queueMaxEvents(0)\n            .queuePageCapacity(\"64mb\")\n            .queueType(\"persisted\")\n            .build());\n\n        ctx.export(\"pipeline\", example.pipelineId());\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: elasticstack:LogstashPipeline\n    properties:\n      pipelineId: test_pipeline\n      description: This is an example pipeline\n      pipeline: |\n        input{}\n        filter{}\n        output{}\n      pipelineMetadata:\n        type: logstash_pipeline\n        version: 1\n      pipelineBatchDelay: 50\n      pipelineBatchSize: 125\n      pipelineEcsCompatibility: disabled\n      pipelineOrdered: auto\n      pipelinePluginClassloaders: false\n      pipelineUnsafeShutdown: false\n      pipelineWorkers: 1\n      queueCheckpointAcks: 1024\n      queueCheckpointRetry: true\n      queueCheckpointWrites: 1024\n      queueDrain: false\n      queueMaxBytesNumber: 1\n      queueMaxBytesUnits: gb\n      queueMaxEvents: 0\n      queuePageCapacity: 64mb\n      queueType: persisted\noutputs:\n  pipeline: ${example.pipelineId}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/logstashPipeline:LogstashPipeline my_pipeline \u003ccluster_uuid\u003e/\u003cpipeline ID\u003e\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the pipeline.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/LogstashPipelineElasticsearchConnection:LogstashPipelineElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "lastModified": {
                    "type": "string",
                    "description": "Date the pipeline was last updated.\n"
                },
                "pipeline": {
                    "type": "string",
                    "description": "Configuration for the pipeline.\n"
                },
                "pipelineBatchDelay": {
                    "type": "integer",
                    "description": "Time in milliseconds to wait for each event before sending an undersized batch to pipeline workers.\n"
                },
                "pipelineBatchSize": {
                    "type": "integer",
                    "description": "The maximum number of events an individual worker thread collects before executing filters and outputs.\n"
                },
                "pipelineEcsCompatibility": {
                    "type": "string",
                    "description": "Sets the pipeline default value for ecs_compatibility, a setting that is available to plugins that implement an ECS compatibility mode for use with the Elastic Common Schema.\n"
                },
                "pipelineId": {
                    "type": "string",
                    "description": "Identifier for the pipeline.\n"
                },
                "pipelineMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Optional metadata about the pipeline.\n"
                },
                "pipelineOrdered": {
                    "type": "string",
                    "description": "Set the pipeline event ordering.\n"
                },
                "pipelinePluginClassloaders": {
                    "type": "boolean",
                    "description": "(Beta) Load Java plugins in independent classloaders to isolate their dependencies.\n"
                },
                "pipelineUnsafeShutdown": {
                    "type": "boolean",
                    "description": "Forces Logstash to exit during shutdown even if there are still inflight events in memory.\n"
                },
                "pipelineWorkers": {
                    "type": "integer",
                    "description": "The number of parallel workers used to run the filter and output stages of the pipeline.\n"
                },
                "queueCheckpointAcks": {
                    "type": "integer",
                    "description": "The maximum number of ACKed events before forcing a checkpoint when persistent queues are enabled.\n"
                },
                "queueCheckpointRetry": {
                    "type": "boolean",
                    "description": "When enabled, Logstash will retry four times per attempted checkpoint write for any checkpoint writes that fail. Any subsequent errors are not retried.\n"
                },
                "queueCheckpointWrites": {
                    "type": "integer",
                    "description": "The maximum number of written events before forcing a checkpoint when persistent queues are enabled.\n"
                },
                "queueDrain": {
                    "type": "boolean",
                    "description": "When enabled, Logstash waits until the persistent queue is drained before shutting down.\n"
                },
                "queueMaxBytesNumber": {
                    "type": "integer",
                    "description": "The total capacity of the queue when persistent queues are enabled.\n"
                },
                "queueMaxBytesUnits": {
                    "type": "string",
                    "description": "Units for the total capacity of the queue when persistent queues are enabled.\n"
                },
                "queueMaxEvents": {
                    "type": "integer",
                    "description": "The maximum number of unread events in the queue when persistent queues are enabled.\n"
                },
                "queuePageCapacity": {
                    "type": "string",
                    "description": "The size of the page data files used when persistent queues are enabled. The queue data consists of append-only data files separated into pages.\n"
                },
                "queueType": {
                    "type": "string",
                    "description": "The internal queueing model for event buffering. Options are memory for in-memory queueing, or persisted for disk-based acknowledged queueing.\n"
                },
                "username": {
                    "type": "string",
                    "description": "User who last updated the pipeline.\n"
                }
            },
            "required": [
                "lastModified",
                "pipeline",
                "pipelineId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the pipeline.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/LogstashPipelineElasticsearchConnection:LogstashPipelineElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "pipeline": {
                    "type": "string",
                    "description": "Configuration for the pipeline.\n"
                },
                "pipelineBatchDelay": {
                    "type": "integer",
                    "description": "Time in milliseconds to wait for each event before sending an undersized batch to pipeline workers.\n"
                },
                "pipelineBatchSize": {
                    "type": "integer",
                    "description": "The maximum number of events an individual worker thread collects before executing filters and outputs.\n"
                },
                "pipelineEcsCompatibility": {
                    "type": "string",
                    "description": "Sets the pipeline default value for ecs_compatibility, a setting that is available to plugins that implement an ECS compatibility mode for use with the Elastic Common Schema.\n"
                },
                "pipelineId": {
                    "type": "string",
                    "description": "Identifier for the pipeline.\n",
                    "willReplaceOnChanges": true
                },
                "pipelineMetadata": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Optional metadata about the pipeline.\n"
                },
                "pipelineOrdered": {
                    "type": "string",
                    "description": "Set the pipeline event ordering.\n"
                },
                "pipelinePluginClassloaders": {
                    "type": "boolean",
                    "description": "(Beta) Load Java plugins in independent classloaders to isolate their dependencies.\n"
                },
                "pipelineUnsafeShutdown": {
                    "type": "boolean",
                    "description": "Forces Logstash to exit during shutdown even if there are still inflight events in memory.\n"
                },
                "pipelineWorkers": {
                    "type": "integer",
                    "description": "The number of parallel workers used to run the filter and output stages of the pipeline.\n"
                },
                "queueCheckpointAcks": {
                    "type": "integer",
                    "description": "The maximum number of ACKed events before forcing a checkpoint when persistent queues are enabled.\n"
                },
                "queueCheckpointRetry": {
                    "type": "boolean",
                    "description": "When enabled, Logstash will retry four times per attempted checkpoint write for any checkpoint writes that fail. Any subsequent errors are not retried.\n"
                },
                "queueCheckpointWrites": {
                    "type": "integer",
                    "description": "The maximum number of written events before forcing a checkpoint when persistent queues are enabled.\n"
                },
                "queueDrain": {
                    "type": "boolean",
                    "description": "When enabled, Logstash waits until the persistent queue is drained before shutting down.\n"
                },
                "queueMaxBytesNumber": {
                    "type": "integer",
                    "description": "The total capacity of the queue when persistent queues are enabled.\n"
                },
                "queueMaxBytesUnits": {
                    "type": "string",
                    "description": "Units for the total capacity of the queue when persistent queues are enabled.\n"
                },
                "queueMaxEvents": {
                    "type": "integer",
                    "description": "The maximum number of unread events in the queue when persistent queues are enabled.\n"
                },
                "queuePageCapacity": {
                    "type": "string",
                    "description": "The size of the page data files used when persistent queues are enabled. The queue data consists of append-only data files separated into pages.\n"
                },
                "queueType": {
                    "type": "string",
                    "description": "The internal queueing model for event buffering. Options are memory for in-memory queueing, or persisted for disk-based acknowledged queueing.\n"
                },
                "username": {
                    "type": "string",
                    "description": "User who last updated the pipeline.\n"
                }
            },
            "requiredInputs": [
                "pipeline",
                "pipelineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LogstashPipeline resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the pipeline.\n"
                    },
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/LogstashPipelineElasticsearchConnection:LogstashPipelineElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "lastModified": {
                        "type": "string",
                        "description": "Date the pipeline was last updated.\n"
                    },
                    "pipeline": {
                        "type": "string",
                        "description": "Configuration for the pipeline.\n"
                    },
                    "pipelineBatchDelay": {
                        "type": "integer",
                        "description": "Time in milliseconds to wait for each event before sending an undersized batch to pipeline workers.\n"
                    },
                    "pipelineBatchSize": {
                        "type": "integer",
                        "description": "The maximum number of events an individual worker thread collects before executing filters and outputs.\n"
                    },
                    "pipelineEcsCompatibility": {
                        "type": "string",
                        "description": "Sets the pipeline default value for ecs_compatibility, a setting that is available to plugins that implement an ECS compatibility mode for use with the Elastic Common Schema.\n"
                    },
                    "pipelineId": {
                        "type": "string",
                        "description": "Identifier for the pipeline.\n",
                        "willReplaceOnChanges": true
                    },
                    "pipelineMetadata": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Optional metadata about the pipeline.\n"
                    },
                    "pipelineOrdered": {
                        "type": "string",
                        "description": "Set the pipeline event ordering.\n"
                    },
                    "pipelinePluginClassloaders": {
                        "type": "boolean",
                        "description": "(Beta) Load Java plugins in independent classloaders to isolate their dependencies.\n"
                    },
                    "pipelineUnsafeShutdown": {
                        "type": "boolean",
                        "description": "Forces Logstash to exit during shutdown even if there are still inflight events in memory.\n"
                    },
                    "pipelineWorkers": {
                        "type": "integer",
                        "description": "The number of parallel workers used to run the filter and output stages of the pipeline.\n"
                    },
                    "queueCheckpointAcks": {
                        "type": "integer",
                        "description": "The maximum number of ACKed events before forcing a checkpoint when persistent queues are enabled.\n"
                    },
                    "queueCheckpointRetry": {
                        "type": "boolean",
                        "description": "When enabled, Logstash will retry four times per attempted checkpoint write for any checkpoint writes that fail. Any subsequent errors are not retried.\n"
                    },
                    "queueCheckpointWrites": {
                        "type": "integer",
                        "description": "The maximum number of written events before forcing a checkpoint when persistent queues are enabled.\n"
                    },
                    "queueDrain": {
                        "type": "boolean",
                        "description": "When enabled, Logstash waits until the persistent queue is drained before shutting down.\n"
                    },
                    "queueMaxBytesNumber": {
                        "type": "integer",
                        "description": "The total capacity of the queue when persistent queues are enabled.\n"
                    },
                    "queueMaxBytesUnits": {
                        "type": "string",
                        "description": "Units for the total capacity of the queue when persistent queues are enabled.\n"
                    },
                    "queueMaxEvents": {
                        "type": "integer",
                        "description": "The maximum number of unread events in the queue when persistent queues are enabled.\n"
                    },
                    "queuePageCapacity": {
                        "type": "string",
                        "description": "The size of the page data files used when persistent queues are enabled. The queue data consists of append-only data files separated into pages.\n"
                    },
                    "queueType": {
                        "type": "string",
                        "description": "The internal queueing model for event buffering. Options are memory for in-memory queueing, or persisted for disk-based acknowledged queueing.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "User who last updated the pipeline.\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/script:Script": {
            "description": "Creates or updates a stored script or search template. See https://www.elastic.co/guide/en/elasticsearch/reference/current/create-stored-script-api.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst myScript = new elasticstack.Script(\"myScript\", {\n    scriptId: \"my_script\",\n    lang: \"painless\",\n    source: \"Math.log(_score * 2) + params['my_modifier']\",\n    context: \"score\",\n});\nconst mySearchTemplate = new elasticstack.Script(\"mySearchTemplate\", {\n    scriptId: \"my_search_template\",\n    lang: \"mustache\",\n    source: JSON.stringify({\n        query: {\n            match: {\n                message: \"{{query_string}}\",\n            },\n        },\n        from: \"{{from}}\",\n        size: \"{{size}}\",\n    }),\n    params: JSON.stringify({\n        query_string: \"My query string\",\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_elasticstack as elasticstack\n\nmy_script = elasticstack.Script(\"myScript\",\n    script_id=\"my_script\",\n    lang=\"painless\",\n    source=\"Math.log(_score * 2) + params['my_modifier']\",\n    context=\"score\")\nmy_search_template = elasticstack.Script(\"mySearchTemplate\",\n    script_id=\"my_search_template\",\n    lang=\"mustache\",\n    source=json.dumps({\n        \"query\": {\n            \"match\": {\n                \"message\": \"{{query_string}}\",\n            },\n        },\n        \"from\": \"{{from}}\",\n        \"size\": \"{{size}}\",\n    }),\n    params=json.dumps({\n        \"query_string\": \"My query string\",\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myScript = new Elasticstack.Script(\"myScript\", new()\n    {\n        ScriptId = \"my_script\",\n        Lang = \"painless\",\n        Source = \"Math.log(_score * 2) + params['my_modifier']\",\n        Context = \"score\",\n    });\n\n    var mySearchTemplate = new Elasticstack.Script(\"mySearchTemplate\", new()\n    {\n        ScriptId = \"my_search_template\",\n        Lang = \"mustache\",\n        Source = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"query\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"match\"] = new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"message\"] = \"{{query_string}}\",\n                },\n            },\n            [\"from\"] = \"{{from}}\",\n            [\"size\"] = \"{{size}}\",\n        }),\n        Params = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"query_string\"] = \"My query string\",\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := elasticstack.NewScript(ctx, \"myScript\", \u0026elasticstack.ScriptArgs{\n\t\t\tScriptId: pulumi.String(\"my_script\"),\n\t\t\tLang:     pulumi.String(\"painless\"),\n\t\t\tSource:   pulumi.String(\"Math.log(_score * 2) + params['my_modifier']\"),\n\t\t\tContext:  pulumi.String(\"score\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"query\": map[string]interface{}{\n\t\t\t\t\"match\": map[string]interface{}{\n\t\t\t\t\t\"message\": \"{{query_string}}\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"from\": \"{{from}}\",\n\t\t\t\"size\": \"{{size}}\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\ttmpJSON1, err := json.Marshal(map[string]interface{}{\n\t\t\t\"query_string\": \"My query string\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson1 := string(tmpJSON1)\n\t\t_, err = elasticstack.NewScript(ctx, \"mySearchTemplate\", \u0026elasticstack.ScriptArgs{\n\t\t\tScriptId: pulumi.String(\"my_search_template\"),\n\t\t\tLang:     pulumi.String(\"mustache\"),\n\t\t\tSource:   pulumi.String(json0),\n\t\t\tParams:   pulumi.String(json1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.Script;\nimport com.pulumi.elasticstack.ScriptArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myScript = new Script(\"myScript\", ScriptArgs.builder()        \n            .scriptId(\"my_script\")\n            .lang(\"painless\")\n            .source(\"Math.log(_score * 2) + params['my_modifier']\")\n            .context(\"score\")\n            .build());\n\n        var mySearchTemplate = new Script(\"mySearchTemplate\", ScriptArgs.builder()        \n            .scriptId(\"my_search_template\")\n            .lang(\"mustache\")\n            .source(serializeJson(\n                jsonObject(\n                    jsonProperty(\"query\", jsonObject(\n                        jsonProperty(\"match\", jsonObject(\n                            jsonProperty(\"message\", \"{{query_string}}\")\n                        ))\n                    )),\n                    jsonProperty(\"from\", \"{{from}}\"),\n                    jsonProperty(\"size\", \"{{size}}\")\n                )))\n            .params(serializeJson(\n                jsonObject(\n                    jsonProperty(\"query_string\", \"My query string\")\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myScript:\n    type: elasticstack:Script\n    properties:\n      scriptId: my_script\n      lang: painless\n      source: Math.log(_score * 2) + params['my_modifier']\n      context: score\n  mySearchTemplate:\n    type: elasticstack:Script\n    properties:\n      scriptId: my_search_template\n      lang: mustache\n      source:\n        fn::toJSON:\n          query:\n            match:\n              message: '{{query_string}}'\n          from: '{{from}}'\n          size: '{{size}}'\n      params:\n        fn::toJSON:\n          query_string: My query string\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/script:Script my_script \u003ccluster_uuid\u003e/\u003cscript id\u003e\n```\n\n ",
            "properties": {
                "context": {
                    "type": "string",
                    "description": "Context in which the script or search template should run.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/ScriptElasticsearchConnection:ScriptElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "lang": {
                    "type": "string",
                    "description": "Script language. For search templates, use `mustache`.\n"
                },
                "params": {
                    "type": "string",
                    "description": "Parameters for the script or search template.\n"
                },
                "scriptId": {
                    "type": "string",
                    "description": "Identifier for the stored script. Must be unique within the cluster.\n"
                },
                "source": {
                    "type": "string",
                    "description": "For scripts, a string containing the script. For search templates, an object containing the search template.\n"
                }
            },
            "required": [
                "lang",
                "scriptId",
                "source"
            ],
            "inputProperties": {
                "context": {
                    "type": "string",
                    "description": "Context in which the script or search template should run.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/ScriptElasticsearchConnection:ScriptElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "lang": {
                    "type": "string",
                    "description": "Script language. For search templates, use `mustache`.\n"
                },
                "params": {
                    "type": "string",
                    "description": "Parameters for the script or search template.\n"
                },
                "scriptId": {
                    "type": "string",
                    "description": "Identifier for the stored script. Must be unique within the cluster.\n",
                    "willReplaceOnChanges": true
                },
                "source": {
                    "type": "string",
                    "description": "For scripts, a string containing the script. For search templates, an object containing the search template.\n"
                }
            },
            "requiredInputs": [
                "lang",
                "scriptId",
                "source"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Script resources.\n",
                "properties": {
                    "context": {
                        "type": "string",
                        "description": "Context in which the script or search template should run.\n"
                    },
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/ScriptElasticsearchConnection:ScriptElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "lang": {
                        "type": "string",
                        "description": "Script language. For search templates, use `mustache`.\n"
                    },
                    "params": {
                        "type": "string",
                        "description": "Parameters for the script or search template.\n"
                    },
                    "scriptId": {
                        "type": "string",
                        "description": "Identifier for the stored script. Must be unique within the cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "source": {
                        "type": "string",
                        "description": "For scripts, a string containing the script. For search templates, an object containing the search template.\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/securityApiKey:SecurityApiKey": {
            "description": "Creates an API key for access without requiring basic authentication. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst apiKeySecurityApiKey = new elasticstack.SecurityApiKey(\"apiKeySecurityApiKey\", {\n    roleDescriptors: JSON.stringify({\n        \"role-a\": {\n            cluster: [\"all\"],\n            indices: [{\n                names: [\"index-a*\"],\n                privileges: [\"read\"],\n            }],\n        },\n    }),\n    expiration: \"1d\",\n    metadata: JSON.stringify({\n        env: \"testing\",\n        open: false,\n        number: 49,\n    }),\n});\nexport const apiKey = apiKeySecurityApiKey;\n```\n```python\nimport pulumi\nimport json\nimport pulumi_elasticstack as elasticstack\n\napi_key_security_api_key = elasticstack.SecurityApiKey(\"apiKeySecurityApiKey\",\n    role_descriptors=json.dumps({\n        \"role-a\": {\n            \"cluster\": [\"all\"],\n            \"indices\": [{\n                \"names\": [\"index-a*\"],\n                \"privileges\": [\"read\"],\n            }],\n        },\n    }),\n    expiration=\"1d\",\n    metadata=json.dumps({\n        \"env\": \"testing\",\n        \"open\": False,\n        \"number\": 49,\n    }))\npulumi.export(\"apiKey\", api_key_security_api_key)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var apiKeySecurityApiKey = new Elasticstack.SecurityApiKey(\"apiKeySecurityApiKey\", new()\n    {\n        RoleDescriptors = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"role-a\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"cluster\"] = new[]\n                {\n                    \"all\",\n                },\n                [\"indices\"] = new[]\n                {\n                    new Dictionary\u003cstring, object?\u003e\n                    {\n                        [\"names\"] = new[]\n                        {\n                            \"index-a*\",\n                        },\n                        [\"privileges\"] = new[]\n                        {\n                            \"read\",\n                        },\n                    },\n                },\n            },\n        }),\n        Expiration = \"1d\",\n        Metadata = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"env\"] = \"testing\",\n            [\"open\"] = false,\n            [\"number\"] = 49,\n        }),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"apiKey\"] = apiKeySecurityApiKey,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"role-a\": map[string]interface{}{\n\t\t\t\t\"cluster\": []string{\n\t\t\t\t\t\"all\",\n\t\t\t\t},\n\t\t\t\t\"indices\": []map[string]interface{}{\n\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\"names\": []string{\n\t\t\t\t\t\t\t\"index-a*\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"privileges\": []string{\n\t\t\t\t\t\t\t\"read\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\ttmpJSON1, err := json.Marshal(map[string]interface{}{\n\t\t\t\"env\":    \"testing\",\n\t\t\t\"open\":   false,\n\t\t\t\"number\": 49,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson1 := string(tmpJSON1)\n\t\tapiKeySecurityApiKey, err := elasticstack.NewSecurityApiKey(ctx, \"apiKeySecurityApiKey\", \u0026elasticstack.SecurityApiKeyArgs{\n\t\t\tRoleDescriptors: pulumi.String(json0),\n\t\t\tExpiration:      pulumi.String(\"1d\"),\n\t\t\tMetadata:        pulumi.String(json1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"apiKey\", apiKeySecurityApiKey)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.SecurityApiKey;\nimport com.pulumi.elasticstack.SecurityApiKeyArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var apiKeySecurityApiKey = new SecurityApiKey(\"apiKeySecurityApiKey\", SecurityApiKeyArgs.builder()        \n            .roleDescriptors(serializeJson(\n                jsonObject(\n                    jsonProperty(\"role-a\", jsonObject(\n                        jsonProperty(\"cluster\", jsonArray(\"all\")),\n                        jsonProperty(\"indices\", jsonArray(jsonObject(\n                            jsonProperty(\"names\", jsonArray(\"index-a*\")),\n                            jsonProperty(\"privileges\", jsonArray(\"read\"))\n                        )))\n                    ))\n                )))\n            .expiration(\"1d\")\n            .metadata(serializeJson(\n                jsonObject(\n                    jsonProperty(\"env\", \"testing\"),\n                    jsonProperty(\"open\", false),\n                    jsonProperty(\"number\", 49)\n                )))\n            .build());\n\n        ctx.export(\"apiKey\", apiKeySecurityApiKey);\n    }\n}\n```\n```yaml\nresources:\n  apiKeySecurityApiKey:\n    type: elasticstack:SecurityApiKey\n    properties:\n      # Set the role descriptors\n      roleDescriptors:\n        fn::toJSON:\n          role-a:\n            cluster:\n              - all\n            indices:\n              - names:\n                  - index-a*\n                privileges:\n                  - read\n      # Set the expiration for the API key\n      expiration: 1d\n      # Set the custom metadata for this user\n      metadata:\n        fn::toJSON:\n          env: testing\n          open: false\n          number: 49\noutputs:\n  apiKey: ${apiKeySecurityApiKey}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport is not supported due to the generated API key only being visible on create. ",
            "properties": {
                "apiKey": {
                    "type": "string",
                    "description": "Generated API Key.\n",
                    "secret": true
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SecurityApiKeyElasticsearchConnection:SecurityApiKeyElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "encoded": {
                    "type": "string",
                    "description": "API key credentials which is the Base64-encoding of the UTF-8 representation of the id and api_key joined by a colon (:).\n",
                    "secret": true
                },
                "expiration": {
                    "type": "string",
                    "description": "Expiration time for the API key. By default, API keys never expire.\n"
                },
                "expirationTimestamp": {
                    "type": "integer",
                    "description": "Expiration time in milliseconds for the API key. By default, API keys never expire.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Arbitrary metadata that you want to associate with the API key.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name for this API key.\n"
                },
                "roleDescriptors": {
                    "type": "string",
                    "description": "Role descriptors for this API key.\n"
                }
            },
            "required": [
                "apiKey",
                "encoded",
                "expirationTimestamp",
                "metadata",
                "name"
            ],
            "inputProperties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SecurityApiKeyElasticsearchConnection:SecurityApiKeyElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "expiration": {
                    "type": "string",
                    "description": "Expiration time for the API key. By default, API keys never expire.\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "string",
                    "description": "Arbitrary metadata that you want to associate with the API key.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name for this API key.\n",
                    "willReplaceOnChanges": true
                },
                "roleDescriptors": {
                    "type": "string",
                    "description": "Role descriptors for this API key.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecurityApiKey resources.\n",
                "properties": {
                    "apiKey": {
                        "type": "string",
                        "description": "Generated API Key.\n",
                        "secret": true
                    },
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/SecurityApiKeyElasticsearchConnection:SecurityApiKeyElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "encoded": {
                        "type": "string",
                        "description": "API key credentials which is the Base64-encoding of the UTF-8 representation of the id and api_key joined by a colon (:).\n",
                        "secret": true
                    },
                    "expiration": {
                        "type": "string",
                        "description": "Expiration time for the API key. By default, API keys never expire.\n",
                        "willReplaceOnChanges": true
                    },
                    "expirationTimestamp": {
                        "type": "integer",
                        "description": "Expiration time in milliseconds for the API key. By default, API keys never expire.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Arbitrary metadata that you want to associate with the API key.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name for this API key.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleDescriptors": {
                        "type": "string",
                        "description": "Role descriptors for this API key.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/securityRole:SecurityRole": {
            "description": "Adds and updates roles in the native realm. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst roleSecurityRole = new elasticstack.SecurityRole(\"roleSecurityRole\", {\n    clusters: [\"all\"],\n    indices: [{\n        names: [\n            \"index1\",\n            \"index2\",\n        ],\n        privileges: [\"all\"],\n    }],\n    applications: [{\n        application: \"myapp\",\n        privileges: [\n            \"admin\",\n            \"read\",\n        ],\n        resources: [\"*\"],\n    }],\n    runAs: [\"other_user\"],\n    metadata: JSON.stringify({\n        version: 1,\n    }),\n});\nexport const role = roleSecurityRole;\n```\n```python\nimport pulumi\nimport json\nimport pulumi_elasticstack as elasticstack\n\nrole_security_role = elasticstack.SecurityRole(\"roleSecurityRole\",\n    clusters=[\"all\"],\n    indices=[elasticstack.SecurityRoleIndexArgs(\n        names=[\n            \"index1\",\n            \"index2\",\n        ],\n        privileges=[\"all\"],\n    )],\n    applications=[elasticstack.SecurityRoleApplicationArgs(\n        application=\"myapp\",\n        privileges=[\n            \"admin\",\n            \"read\",\n        ],\n        resources=[\"*\"],\n    )],\n    run_as=[\"other_user\"],\n    metadata=json.dumps({\n        \"version\": 1,\n    }))\npulumi.export(\"role\", role_security_role)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var roleSecurityRole = new Elasticstack.SecurityRole(\"roleSecurityRole\", new()\n    {\n        Clusters = new[]\n        {\n            \"all\",\n        },\n        Indices = new[]\n        {\n            new Elasticstack.Inputs.SecurityRoleIndexArgs\n            {\n                Names = new[]\n                {\n                    \"index1\",\n                    \"index2\",\n                },\n                Privileges = new[]\n                {\n                    \"all\",\n                },\n            },\n        },\n        Applications = new[]\n        {\n            new Elasticstack.Inputs.SecurityRoleApplicationArgs\n            {\n                Application = \"myapp\",\n                Privileges = new[]\n                {\n                    \"admin\",\n                    \"read\",\n                },\n                Resources = new[]\n                {\n                    \"*\",\n                },\n            },\n        },\n        RunAs = new[]\n        {\n            \"other_user\",\n        },\n        Metadata = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"version\"] = 1,\n        }),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"role\"] = roleSecurityRole,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"version\": 1,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\troleSecurityRole, err := elasticstack.NewSecurityRole(ctx, \"roleSecurityRole\", \u0026elasticstack.SecurityRoleArgs{\n\t\t\tClusters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"all\"),\n\t\t\t},\n\t\t\tIndices: elasticstack.SecurityRoleIndexArray{\n\t\t\t\t\u0026elasticstack.SecurityRoleIndexArgs{\n\t\t\t\t\tNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"index1\"),\n\t\t\t\t\t\tpulumi.String(\"index2\"),\n\t\t\t\t\t},\n\t\t\t\t\tPrivileges: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"all\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tApplications: elasticstack.SecurityRoleApplicationArray{\n\t\t\t\t\u0026elasticstack.SecurityRoleApplicationArgs{\n\t\t\t\t\tApplication: pulumi.String(\"myapp\"),\n\t\t\t\t\tPrivileges: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"admin\"),\n\t\t\t\t\t\tpulumi.String(\"read\"),\n\t\t\t\t\t},\n\t\t\t\t\tResources: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"*\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRunAs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"other_user\"),\n\t\t\t},\n\t\t\tMetadata: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"role\", roleSecurityRole)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.SecurityRole;\nimport com.pulumi.elasticstack.SecurityRoleArgs;\nimport com.pulumi.elasticstack.inputs.SecurityRoleIndexArgs;\nimport com.pulumi.elasticstack.inputs.SecurityRoleApplicationArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var roleSecurityRole = new SecurityRole(\"roleSecurityRole\", SecurityRoleArgs.builder()        \n            .clusters(\"all\")\n            .indices(SecurityRoleIndexArgs.builder()\n                .names(                \n                    \"index1\",\n                    \"index2\")\n                .privileges(\"all\")\n                .build())\n            .applications(SecurityRoleApplicationArgs.builder()\n                .application(\"myapp\")\n                .privileges(                \n                    \"admin\",\n                    \"read\")\n                .resources(\"*\")\n                .build())\n            .runAs(\"other_user\")\n            .metadata(serializeJson(\n                jsonObject(\n                    jsonProperty(\"version\", 1)\n                )))\n            .build());\n\n        ctx.export(\"role\", roleSecurityRole);\n    }\n}\n```\n```yaml\nresources:\n  roleSecurityRole:\n    type: elasticstack:SecurityRole\n    properties:\n      clusters:\n        - all\n      indices:\n        - names:\n            - index1\n            - index2\n          privileges:\n            - all\n      applications:\n        - application: myapp\n          privileges:\n            - admin\n            - read\n          resources:\n            - '*'\n      runAs:\n        - other_user\n      metadata:\n        fn::toJSON:\n          version: 1\noutputs:\n  role: ${roleSecurityRole}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/securityRole:SecurityRole my_role \u003ccluster_uuid\u003e/\u003crole name\u003e\n```\n\n ",
            "properties": {
                "applications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/SecurityRoleApplication:SecurityRoleApplication"
                    },
                    "description": "A list of application privilege entries.\n"
                },
                "clusters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of cluster privileges. These privileges define the cluster level actions that users with this role are able to execute.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SecurityRoleElasticsearchConnection:SecurityRoleElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "global": {
                    "type": "string",
                    "description": "An object defining global privileges.\n"
                },
                "indices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/SecurityRoleIndex:SecurityRoleIndex"
                    },
                    "description": "A list of indices permissions entries.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Optional meta-data.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "runAs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of users that the owners of this role can impersonate.\n"
                }
            },
            "required": [
                "metadata",
                "name"
            ],
            "inputProperties": {
                "applications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/SecurityRoleApplication:SecurityRoleApplication"
                    },
                    "description": "A list of application privilege entries.\n"
                },
                "clusters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of cluster privileges. These privileges define the cluster level actions that users with this role are able to execute.\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SecurityRoleElasticsearchConnection:SecurityRoleElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "global": {
                    "type": "string",
                    "description": "An object defining global privileges.\n"
                },
                "indices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/elasticstack:index/SecurityRoleIndex:SecurityRoleIndex"
                    },
                    "description": "A list of indices permissions entries.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Optional meta-data.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n",
                    "willReplaceOnChanges": true
                },
                "runAs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of users that the owners of this role can impersonate.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecurityRole resources.\n",
                "properties": {
                    "applications": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/SecurityRoleApplication:SecurityRoleApplication"
                        },
                        "description": "A list of application privilege entries.\n"
                    },
                    "clusters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of cluster privileges. These privileges define the cluster level actions that users with this role are able to execute.\n"
                    },
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/SecurityRoleElasticsearchConnection:SecurityRoleElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "global": {
                        "type": "string",
                        "description": "An object defining global privileges.\n"
                    },
                    "indices": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/SecurityRoleIndex:SecurityRoleIndex"
                        },
                        "description": "A list of indices permissions entries.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Optional meta-data.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "runAs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of users that the owners of this role can impersonate.\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/securityRoleMapping:SecurityRoleMapping": {
            "description": "Manage role mappings. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role-mapping.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst example = new elasticstack.SecurityRoleMapping(\"example\", {\n    enabled: true,\n    roles: [\"admin\"],\n    rules: JSON.stringify({\n        any: [\n            {\n                field: {\n                    username: \"esadmin\",\n                },\n            },\n            {\n                field: {\n                    groups: \"cn=admins,dc=example,dc=com\",\n                },\n            },\n        ],\n    }),\n});\nexport const role = example.name;\n```\n```python\nimport pulumi\nimport json\nimport pulumi_elasticstack as elasticstack\n\nexample = elasticstack.SecurityRoleMapping(\"example\",\n    enabled=True,\n    roles=[\"admin\"],\n    rules=json.dumps({\n        \"any\": [\n            {\n                \"field\": {\n                    \"username\": \"esadmin\",\n                },\n            },\n            {\n                \"field\": {\n                    \"groups\": \"cn=admins,dc=example,dc=com\",\n                },\n            },\n        ],\n    }))\npulumi.export(\"role\", example.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Elasticstack.SecurityRoleMapping(\"example\", new()\n    {\n        Enabled = true,\n        Roles = new[]\n        {\n            \"admin\",\n        },\n        Rules = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"any\"] = new[]\n            {\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"field\"] = new Dictionary\u003cstring, object?\u003e\n                    {\n                        [\"username\"] = \"esadmin\",\n                    },\n                },\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"field\"] = new Dictionary\u003cstring, object?\u003e\n                    {\n                        [\"groups\"] = \"cn=admins,dc=example,dc=com\",\n                    },\n                },\n            },\n        }),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"role\"] = example.Name,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"any\": []interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"field\": map[string]interface{}{\n\t\t\t\t\t\t\"username\": \"esadmin\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"field\": map[string]interface{}{\n\t\t\t\t\t\t\"groups\": \"cn=admins,dc=example,dc=com\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\texample, err := elasticstack.NewSecurityRoleMapping(ctx, \"example\", \u0026elasticstack.SecurityRoleMappingArgs{\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"admin\"),\n\t\t\t},\n\t\t\tRules: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"role\", example.Name)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.SecurityRoleMapping;\nimport com.pulumi.elasticstack.SecurityRoleMappingArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new SecurityRoleMapping(\"example\", SecurityRoleMappingArgs.builder()        \n            .enabled(true)\n            .roles(\"admin\")\n            .rules(serializeJson(\n                jsonObject(\n                    jsonProperty(\"any\", jsonArray(\n                        jsonObject(\n                            jsonProperty(\"field\", jsonObject(\n                                jsonProperty(\"username\", \"esadmin\")\n                            ))\n                        ), \n                        jsonObject(\n                            jsonProperty(\"field\", jsonObject(\n                                jsonProperty(\"groups\", \"cn=admins,dc=example,dc=com\")\n                            ))\n                        )\n                    ))\n                )))\n            .build());\n\n        ctx.export(\"role\", example.name());\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: elasticstack:SecurityRoleMapping\n    properties:\n      enabled: true\n      roles:\n        - admin\n      rules:\n        fn::toJSON:\n          any:\n            - field:\n                username: esadmin\n            - field:\n                groups: cn=admins,dc=example,dc=com\noutputs:\n  role: ${example.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/securityRoleMapping:SecurityRoleMapping my_role_mapping \u003ccluster_uuid\u003e/\u003crole mapping name\u003e\n```\n\n ",
            "properties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SecurityRoleMappingElasticsearchConnection:SecurityRoleMappingElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Mappings that have `enabled` set to `false` are ignored when role mapping is performed.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Additional metadata that helps define which roles are assigned to each user. Keys beginning with `_` are reserved for system usage.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The distinct name that identifies the role mapping, used solely as an identifier.\n"
                },
                "roleTemplates": {
                    "type": "string",
                    "description": "A list of mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role names that are granted to the users that match the role mapping rules.\n"
                },
                "rules": {
                    "type": "string",
                    "description": "The rules that determine which users should be matched by the mapping. A rule is a logical condition that is expressed by using a JSON DSL.\n"
                }
            },
            "required": [
                "name",
                "rules"
            ],
            "inputProperties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SecurityRoleMappingElasticsearchConnection:SecurityRoleMappingElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Mappings that have `enabled` set to `false` are ignored when role mapping is performed.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Additional metadata that helps define which roles are assigned to each user. Keys beginning with `_` are reserved for system usage.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The distinct name that identifies the role mapping, used solely as an identifier.\n"
                },
                "roleTemplates": {
                    "type": "string",
                    "description": "A list of mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role names that are granted to the users that match the role mapping rules.\n"
                },
                "rules": {
                    "type": "string",
                    "description": "The rules that determine which users should be matched by the mapping. A rule is a logical condition that is expressed by using a JSON DSL.\n"
                }
            },
            "requiredInputs": [
                "rules"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecurityRoleMapping resources.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/SecurityRoleMappingElasticsearchConnection:SecurityRoleMappingElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Mappings that have `enabled` set to `false` are ignored when role mapping is performed.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Additional metadata that helps define which roles are assigned to each user. Keys beginning with `_` are reserved for system usage.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The distinct name that identifies the role mapping, used solely as an identifier.\n"
                    },
                    "roleTemplates": {
                        "type": "string",
                        "description": "A list of mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of role names that are granted to the users that match the role mapping rules.\n"
                    },
                    "rules": {
                        "type": "string",
                        "description": "The rules that determine which users should be matched by the mapping. A rule is a logical condition that is expressed by using a JSON DSL.\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/securitySystemUser:SecuritySystemUser": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst kibanaSystem = new elasticstack.SecuritySystemUser(\"kibanaSystem\", {\n    elasticsearchConnection: {\n        endpoints: [\"http://localhost:9200\"],\n        password: \"changeme\",\n        username: \"elastic\",\n    },\n    passwordHash: `$2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO`,\n    username: \"kibana_system\",\n});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nkibana_system = elasticstack.SecuritySystemUser(\"kibanaSystem\",\n    elasticsearch_connection=elasticstack.SecuritySystemUserElasticsearchConnectionArgs(\n        endpoints=[\"http://localhost:9200\"],\n        password=\"changeme\",\n        username=\"elastic\",\n    ),\n    password_hash=\"$2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO\",\n    username=\"kibana_system\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kibanaSystem = new Elasticstack.SecuritySystemUser(\"kibanaSystem\", new()\n    {\n        ElasticsearchConnection = new Elasticstack.Inputs.SecuritySystemUserElasticsearchConnectionArgs\n        {\n            Endpoints = new[]\n            {\n                \"http://localhost:9200\",\n            },\n            Password = \"changeme\",\n            Username = \"elastic\",\n        },\n        PasswordHash = \"$2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO\",\n        Username = \"kibana_system\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := elasticstack.NewSecuritySystemUser(ctx, \"kibanaSystem\", \u0026elasticstack.SecuritySystemUserArgs{\n\t\t\tElasticsearchConnection: \u0026elasticstack.SecuritySystemUserElasticsearchConnectionArgs{\n\t\t\t\tEndpoints: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"http://localhost:9200\"),\n\t\t\t\t},\n\t\t\t\tPassword: pulumi.String(\"changeme\"),\n\t\t\t\tUsername: pulumi.String(\"elastic\"),\n\t\t\t},\n\t\t\tPasswordHash: pulumi.String(fmt.Sprintf(\"$2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO\")),\n\t\t\tUsername:     pulumi.String(\"kibana_system\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.SecuritySystemUser;\nimport com.pulumi.elasticstack.SecuritySystemUserArgs;\nimport com.pulumi.elasticstack.inputs.SecuritySystemUserElasticsearchConnectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kibanaSystem = new SecuritySystemUser(\"kibanaSystem\", SecuritySystemUserArgs.builder()        \n            .elasticsearchConnection(SecuritySystemUserElasticsearchConnectionArgs.builder()\n                .endpoints(\"http://localhost:9200\")\n                .password(\"changeme\")\n                .username(\"elastic\")\n                .build())\n            .passwordHash(\"$2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO\")\n            .username(\"kibana_system\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kibanaSystem:\n    type: elasticstack:SecuritySystemUser\n    properties:\n      elasticsearchConnection:\n        endpoints:\n          - http://localhost:9200\n        password: changeme\n        username: elastic\n      # For details on how to generate the hashed password see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-user.html#security-api-put-user-request-body\n      passwordHash: $2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO\n      username: kibana_system\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SecuritySystemUserElasticsearchConnection:SecuritySystemUserElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether the user is enabled. The default value is true.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The users password. Passwords must be at least 6 characters long.\n",
                    "secret": true
                },
                "passwordHash": {
                    "type": "string",
                    "description": "A hash of the users password. This must be produced using the same hashing algorithm as has been configured for password storage (see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-settings.html#hashing-settings).\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "An identifier for the system user (see https://www.elastic.co/guide/en/elasticsearch/reference/current/built-in-users.html).\n"
                }
            },
            "required": [
                "username"
            ],
            "inputProperties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SecuritySystemUserElasticsearchConnection:SecuritySystemUserElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether the user is enabled. The default value is true.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The users password. Passwords must be at least 6 characters long.\n",
                    "secret": true
                },
                "passwordHash": {
                    "type": "string",
                    "description": "A hash of the users password. This must be produced using the same hashing algorithm as has been configured for password storage (see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-settings.html#hashing-settings).\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "An identifier for the system user (see https://www.elastic.co/guide/en/elasticsearch/reference/current/built-in-users.html).\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecuritySystemUser resources.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/SecuritySystemUserElasticsearchConnection:SecuritySystemUserElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies whether the user is enabled. The default value is true.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "The users password. Passwords must be at least 6 characters long.\n",
                        "secret": true
                    },
                    "passwordHash": {
                        "type": "string",
                        "description": "A hash of the users password. This must be produced using the same hashing algorithm as has been configured for password storage (see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-settings.html#hashing-settings).\n",
                        "secret": true
                    },
                    "username": {
                        "type": "string",
                        "description": "An identifier for the system user (see https://www.elastic.co/guide/en/elasticsearch/reference/current/built-in-users.html).\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/securityUser:SecurityUser": {
            "description": "Adds and updates users in the native realm. These users are commonly referred to as native users. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-user.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst user = new elasticstack.SecurityUser(\"user\", {\n    username: \"testuser\",\n    passwordHash: `$2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO`,\n    roles: [\"kibana_user\"],\n    metadata: JSON.stringify({\n        env: \"testing\",\n        open: false,\n        number: 49,\n    }),\n    elasticsearchConnection: {\n        endpoints: [\"http://localhost:9200\"],\n        username: \"elastic\",\n        password: \"changeme\",\n    },\n});\nconst dev = new elasticstack.SecurityUser(\"dev\", {\n    username: \"devuser\",\n    password: \"1234567890\",\n    roles: [\"kibana_user\"],\n    metadata: JSON.stringify({\n        env: \"testing\",\n        open: false,\n        number: 49,\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_elasticstack as elasticstack\n\nuser = elasticstack.SecurityUser(\"user\",\n    username=\"testuser\",\n    password_hash=\"$2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO\",\n    roles=[\"kibana_user\"],\n    metadata=json.dumps({\n        \"env\": \"testing\",\n        \"open\": False,\n        \"number\": 49,\n    }),\n    elasticsearch_connection=elasticstack.SecurityUserElasticsearchConnectionArgs(\n        endpoints=[\"http://localhost:9200\"],\n        username=\"elastic\",\n        password=\"changeme\",\n    ))\ndev = elasticstack.SecurityUser(\"dev\",\n    username=\"devuser\",\n    password=\"1234567890\",\n    roles=[\"kibana_user\"],\n    metadata=json.dumps({\n        \"env\": \"testing\",\n        \"open\": False,\n        \"number\": 49,\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var user = new Elasticstack.SecurityUser(\"user\", new()\n    {\n        Username = \"testuser\",\n        PasswordHash = \"$2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO\",\n        Roles = new[]\n        {\n            \"kibana_user\",\n        },\n        Metadata = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"env\"] = \"testing\",\n            [\"open\"] = false,\n            [\"number\"] = 49,\n        }),\n        ElasticsearchConnection = new Elasticstack.Inputs.SecurityUserElasticsearchConnectionArgs\n        {\n            Endpoints = new[]\n            {\n                \"http://localhost:9200\",\n            },\n            Username = \"elastic\",\n            Password = \"changeme\",\n        },\n    });\n\n    var dev = new Elasticstack.SecurityUser(\"dev\", new()\n    {\n        Username = \"devuser\",\n        Password = \"1234567890\",\n        Roles = new[]\n        {\n            \"kibana_user\",\n        },\n        Metadata = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"env\"] = \"testing\",\n            [\"open\"] = false,\n            [\"number\"] = 49,\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"env\":    \"testing\",\n\t\t\t\"open\":   false,\n\t\t\t\"number\": 49,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = elasticstack.NewSecurityUser(ctx, \"user\", \u0026elasticstack.SecurityUserArgs{\n\t\t\tUsername:     pulumi.String(\"testuser\"),\n\t\t\tPasswordHash: pulumi.String(fmt.Sprintf(\"$2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO\")),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"kibana_user\"),\n\t\t\t},\n\t\t\tMetadata: pulumi.String(json0),\n\t\t\tElasticsearchConnection: \u0026elasticstack.SecurityUserElasticsearchConnectionArgs{\n\t\t\t\tEndpoints: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"http://localhost:9200\"),\n\t\t\t\t},\n\t\t\t\tUsername: pulumi.String(\"elastic\"),\n\t\t\t\tPassword: pulumi.String(\"changeme\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON1, err := json.Marshal(map[string]interface{}{\n\t\t\t\"env\":    \"testing\",\n\t\t\t\"open\":   false,\n\t\t\t\"number\": 49,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson1 := string(tmpJSON1)\n\t\t_, err = elasticstack.NewSecurityUser(ctx, \"dev\", \u0026elasticstack.SecurityUserArgs{\n\t\t\tUsername: pulumi.String(\"devuser\"),\n\t\t\tPassword: pulumi.String(\"1234567890\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"kibana_user\"),\n\t\t\t},\n\t\t\tMetadata: pulumi.String(json1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.SecurityUser;\nimport com.pulumi.elasticstack.SecurityUserArgs;\nimport com.pulumi.elasticstack.inputs.SecurityUserElasticsearchConnectionArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var user = new SecurityUser(\"user\", SecurityUserArgs.builder()        \n            .username(\"testuser\")\n            .passwordHash(\"$2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO\")\n            .roles(\"kibana_user\")\n            .metadata(serializeJson(\n                jsonObject(\n                    jsonProperty(\"env\", \"testing\"),\n                    jsonProperty(\"open\", false),\n                    jsonProperty(\"number\", 49)\n                )))\n            .elasticsearchConnection(SecurityUserElasticsearchConnectionArgs.builder()\n                .endpoints(\"http://localhost:9200\")\n                .username(\"elastic\")\n                .password(\"changeme\")\n                .build())\n            .build());\n\n        var dev = new SecurityUser(\"dev\", SecurityUserArgs.builder()        \n            .username(\"devuser\")\n            .password(\"1234567890\")\n            .roles(\"kibana_user\")\n            .metadata(serializeJson(\n                jsonObject(\n                    jsonProperty(\"env\", \"testing\"),\n                    jsonProperty(\"open\", false),\n                    jsonProperty(\"number\", 49)\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  user:\n    type: elasticstack:SecurityUser\n    properties:\n      username: testuser\n      # use hashed password: see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-user.html#security-api-put-user-request-body\n      passwordHash: $2a$10$rMZe6TdsUwBX/TA8vRDz0OLwKAZeCzXM4jT3tfCjpSTB8HoFuq8xO\n      roles:\n        - kibana_user\n      # set the custom metadata for this user\n      metadata:\n        fn::toJSON:\n          env: testing\n          open: false\n          number: 49\n      elasticsearchConnection:\n        endpoints:\n          - http://localhost:9200\n        username: elastic\n        password: changeme\n  dev:\n    type: elasticstack:SecurityUser\n    properties:\n      username: devuser\n      password: '1234567890'\n      roles:\n        - kibana_user\n      # set the custom metadata for this user\n      metadata:\n        fn::toJSON:\n          env: testing\n          open: false\n          number: 49\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/securityUser:SecurityUser user \u003ccluster_uuid\u003e/elastic\n```\n\n ",
            "properties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SecurityUserElasticsearchConnection:SecurityUserElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The email of the user.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether the user is enabled. The default value is true.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The full name of the user.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Arbitrary metadata that you want to associate with the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The users password. Passwords must be at least 6 characters long.\n",
                    "secret": true
                },
                "passwordHash": {
                    "type": "string",
                    "description": "A hash of the users password. This must be produced using the same hashing algorithm as has been configured for password storage (see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-settings.html#hashing-settings).\n",
                    "secret": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of roles the user has. The roles determine the users access permissions. Default is [].\n"
                },
                "username": {
                    "type": "string",
                    "description": "An identifier for the user (see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-user.html#security-api-put-user-path-params).\n"
                }
            },
            "required": [
                "metadata",
                "roles",
                "username"
            ],
            "inputProperties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SecurityUserElasticsearchConnection:SecurityUserElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The email of the user.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether the user is enabled. The default value is true.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The full name of the user.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Arbitrary metadata that you want to associate with the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The users password. Passwords must be at least 6 characters long.\n",
                    "secret": true
                },
                "passwordHash": {
                    "type": "string",
                    "description": "A hash of the users password. This must be produced using the same hashing algorithm as has been configured for password storage (see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-settings.html#hashing-settings).\n",
                    "secret": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of roles the user has. The roles determine the users access permissions. Default is [].\n"
                },
                "username": {
                    "type": "string",
                    "description": "An identifier for the user (see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-user.html#security-api-put-user-path-params).\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "roles",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SecurityUser resources.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/SecurityUserElasticsearchConnection:SecurityUserElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The email of the user.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies whether the user is enabled. The default value is true.\n"
                    },
                    "fullName": {
                        "type": "string",
                        "description": "The full name of the user.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Arbitrary metadata that you want to associate with the user.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "The users password. Passwords must be at least 6 characters long.\n",
                        "secret": true
                    },
                    "passwordHash": {
                        "type": "string",
                        "description": "A hash of the users password. This must be produced using the same hashing algorithm as has been configured for password storage (see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-settings.html#hashing-settings).\n",
                        "secret": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of roles the user has. The roles determine the users access permissions. Default is [].\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "An identifier for the user (see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-user.html#security-api-put-user-path-params).\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/snapshotLifecycle:SnapshotLifecycle": {
            "description": "Creates or updates a snapshot lifecycle policy. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/slm-api-put-policy.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\n// create a repository for snapshots\nconst repo = new elasticstack.SnapshotRepository(\"repo\", {fs: {\n    location: \"/tmp/snapshots\",\n    compress: true,\n    maxRestoreBytesPerSec: \"20mb\",\n}});\n// create a SLM policy and use the above created repository\nconst slmPolicy = new elasticstack.SnapshotLifecycle(\"slmPolicy\", {\n    schedule: \"0 30 1 * * ?\",\n    snapshotName: \"\u003cdaily-snap-{now/d}\u003e\",\n    repository: repo.name,\n    indices: [\n        \"data-*\",\n        \"important\",\n    ],\n    ignoreUnavailable: false,\n    includeGlobalState: false,\n    expireAfter: \"30d\",\n    minCount: 5,\n    maxCount: 50,\n});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\n# create a repository for snapshots\nrepo = elasticstack.SnapshotRepository(\"repo\", fs=elasticstack.SnapshotRepositoryFsArgs(\n    location=\"/tmp/snapshots\",\n    compress=True,\n    max_restore_bytes_per_sec=\"20mb\",\n))\n# create a SLM policy and use the above created repository\nslm_policy = elasticstack.SnapshotLifecycle(\"slmPolicy\",\n    schedule=\"0 30 1 * * ?\",\n    snapshot_name=\"\u003cdaily-snap-{now/d}\u003e\",\n    repository=repo.name,\n    indices=[\n        \"data-*\",\n        \"important\",\n    ],\n    ignore_unavailable=False,\n    include_global_state=False,\n    expire_after=\"30d\",\n    min_count=5,\n    max_count=50)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // create a repository for snapshots\n    var repo = new Elasticstack.SnapshotRepository(\"repo\", new()\n    {\n        Fs = new Elasticstack.Inputs.SnapshotRepositoryFsArgs\n        {\n            Location = \"/tmp/snapshots\",\n            Compress = true,\n            MaxRestoreBytesPerSec = \"20mb\",\n        },\n    });\n\n    // create a SLM policy and use the above created repository\n    var slmPolicy = new Elasticstack.SnapshotLifecycle(\"slmPolicy\", new()\n    {\n        Schedule = \"0 30 1 * * ?\",\n        SnapshotName = \"\u003cdaily-snap-{now/d}\u003e\",\n        Repository = repo.Name,\n        Indices = new[]\n        {\n            \"data-*\",\n            \"important\",\n        },\n        IgnoreUnavailable = false,\n        IncludeGlobalState = false,\n        ExpireAfter = \"30d\",\n        MinCount = 5,\n        MaxCount = 50,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trepo, err := elasticstack.NewSnapshotRepository(ctx, \"repo\", \u0026elasticstack.SnapshotRepositoryArgs{\n\t\t\tFs: \u0026elasticstack.SnapshotRepositoryFsArgs{\n\t\t\t\tLocation:              pulumi.String(\"/tmp/snapshots\"),\n\t\t\t\tCompress:              pulumi.Bool(true),\n\t\t\t\tMaxRestoreBytesPerSec: pulumi.String(\"20mb\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewSnapshotLifecycle(ctx, \"slmPolicy\", \u0026elasticstack.SnapshotLifecycleArgs{\n\t\t\tSchedule:     pulumi.String(\"0 30 1 * * ?\"),\n\t\t\tSnapshotName: pulumi.String(\"\u003cdaily-snap-{now/d}\u003e\"),\n\t\t\tRepository:   repo.Name,\n\t\t\tIndices: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"data-*\"),\n\t\t\t\tpulumi.String(\"important\"),\n\t\t\t},\n\t\t\tIgnoreUnavailable:  pulumi.Bool(false),\n\t\t\tIncludeGlobalState: pulumi.Bool(false),\n\t\t\tExpireAfter:        pulumi.String(\"30d\"),\n\t\t\tMinCount:           pulumi.Int(5),\n\t\t\tMaxCount:           pulumi.Int(50),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.SnapshotRepository;\nimport com.pulumi.elasticstack.SnapshotRepositoryArgs;\nimport com.pulumi.elasticstack.inputs.SnapshotRepositoryFsArgs;\nimport com.pulumi.elasticstack.SnapshotLifecycle;\nimport com.pulumi.elasticstack.SnapshotLifecycleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var repo = new SnapshotRepository(\"repo\", SnapshotRepositoryArgs.builder()        \n            .fs(SnapshotRepositoryFsArgs.builder()\n                .location(\"/tmp/snapshots\")\n                .compress(true)\n                .maxRestoreBytesPerSec(\"20mb\")\n                .build())\n            .build());\n\n        var slmPolicy = new SnapshotLifecycle(\"slmPolicy\", SnapshotLifecycleArgs.builder()        \n            .schedule(\"0 30 1 * * ?\")\n            .snapshotName(\"\u003cdaily-snap-{now/d}\u003e\")\n            .repository(repo.name())\n            .indices(            \n                \"data-*\",\n                \"important\")\n            .ignoreUnavailable(false)\n            .includeGlobalState(false)\n            .expireAfter(\"30d\")\n            .minCount(5)\n            .maxCount(50)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # create a repository for snapshots\n  repo:\n    type: elasticstack:SnapshotRepository\n    properties:\n      fs:\n        location: /tmp/snapshots\n        compress: true\n        maxRestoreBytesPerSec: 20mb\n  # create a SLM policy and use the above created repository\n  slmPolicy:\n    type: elasticstack:SnapshotLifecycle\n    properties:\n      schedule: 0 30 1 * * ?\n      snapshotName: \u003cdaily-snap-{now/d}\u003e\n      repository: ${repo.name}\n      indices:\n        - data-*\n        - important\n      ignoreUnavailable: false\n      includeGlobalState: false\n      expireAfter: 30d\n      minCount: 5\n      maxCount: 50\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/snapshotLifecycle:SnapshotLifecycle my_policy \u003ccluster_uuid\u003e/\u003cslm policy name\u003e\n```\n\n ",
            "properties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SnapshotLifecycleElasticsearchConnection:SnapshotLifecycleElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "expandWildcards": {
                    "type": "string",
                    "description": "Determines how wildcard patterns in the `indices` parameter match data streams and indices. Supports comma-separated values, such as `closed,hidden`.\n"
                },
                "expireAfter": {
                    "type": "string",
                    "description": "Time period after which a snapshot is considered expired and eligible for deletion.\n"
                },
                "featureStates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Feature states to include in the snapshot.\n"
                },
                "ignoreUnavailable": {
                    "type": "boolean",
                    "description": "If `false`, the snapshot fails if any data stream or index in indices is missing or closed. If `true`, the snapshot ignores missing or closed data streams and indices.\n"
                },
                "includeGlobalState": {
                    "type": "boolean",
                    "description": "If `true`, include the cluster state in the snapshot.\n"
                },
                "indices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Comma-separated list of data streams and indices to include in the snapshot.\n"
                },
                "maxCount": {
                    "type": "integer",
                    "description": "Maximum number of snapshots to retain, even if the snapshots have not yet expired.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Attaches arbitrary metadata to the snapshot.\n"
                },
                "minCount": {
                    "type": "integer",
                    "description": "Minimum number of snapshots to retain, even if the snapshots have expired.\n"
                },
                "name": {
                    "type": "string",
                    "description": "ID for the snapshot lifecycle policy you want to create or update.\n"
                },
                "partial": {
                    "type": "boolean",
                    "description": "If `false`, the entire snapshot will fail if one or more indices included in the snapshot do not have all primary shards available.\n"
                },
                "repository": {
                    "type": "string",
                    "description": "Repository used to store snapshots created by this policy.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "Periodic or absolute schedule at which the policy creates snapshots.\n"
                },
                "snapshotName": {
                    "type": "string",
                    "description": "Name automatically assigned to each snapshot created by the policy.\n"
                }
            },
            "required": [
                "featureStates",
                "indices",
                "metadata",
                "name",
                "repository",
                "schedule"
            ],
            "inputProperties": {
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SnapshotLifecycleElasticsearchConnection:SnapshotLifecycleElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "expandWildcards": {
                    "type": "string",
                    "description": "Determines how wildcard patterns in the `indices` parameter match data streams and indices. Supports comma-separated values, such as `closed,hidden`.\n"
                },
                "expireAfter": {
                    "type": "string",
                    "description": "Time period after which a snapshot is considered expired and eligible for deletion.\n"
                },
                "featureStates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Feature states to include in the snapshot.\n"
                },
                "ignoreUnavailable": {
                    "type": "boolean",
                    "description": "If `false`, the snapshot fails if any data stream or index in indices is missing or closed. If `true`, the snapshot ignores missing or closed data streams and indices.\n"
                },
                "includeGlobalState": {
                    "type": "boolean",
                    "description": "If `true`, include the cluster state in the snapshot.\n"
                },
                "indices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Comma-separated list of data streams and indices to include in the snapshot.\n"
                },
                "maxCount": {
                    "type": "integer",
                    "description": "Maximum number of snapshots to retain, even if the snapshots have not yet expired.\n"
                },
                "metadata": {
                    "type": "string",
                    "description": "Attaches arbitrary metadata to the snapshot.\n"
                },
                "minCount": {
                    "type": "integer",
                    "description": "Minimum number of snapshots to retain, even if the snapshots have expired.\n"
                },
                "name": {
                    "type": "string",
                    "description": "ID for the snapshot lifecycle policy you want to create or update.\n",
                    "willReplaceOnChanges": true
                },
                "partial": {
                    "type": "boolean",
                    "description": "If `false`, the entire snapshot will fail if one or more indices included in the snapshot do not have all primary shards available.\n"
                },
                "repository": {
                    "type": "string",
                    "description": "Repository used to store snapshots created by this policy.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "Periodic or absolute schedule at which the policy creates snapshots.\n"
                },
                "snapshotName": {
                    "type": "string",
                    "description": "Name automatically assigned to each snapshot created by the policy.\n"
                }
            },
            "requiredInputs": [
                "repository",
                "schedule"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SnapshotLifecycle resources.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/SnapshotLifecycleElasticsearchConnection:SnapshotLifecycleElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "expandWildcards": {
                        "type": "string",
                        "description": "Determines how wildcard patterns in the `indices` parameter match data streams and indices. Supports comma-separated values, such as `closed,hidden`.\n"
                    },
                    "expireAfter": {
                        "type": "string",
                        "description": "Time period after which a snapshot is considered expired and eligible for deletion.\n"
                    },
                    "featureStates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Feature states to include in the snapshot.\n"
                    },
                    "ignoreUnavailable": {
                        "type": "boolean",
                        "description": "If `false`, the snapshot fails if any data stream or index in indices is missing or closed. If `true`, the snapshot ignores missing or closed data streams and indices.\n"
                    },
                    "includeGlobalState": {
                        "type": "boolean",
                        "description": "If `true`, include the cluster state in the snapshot.\n"
                    },
                    "indices": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Comma-separated list of data streams and indices to include in the snapshot.\n"
                    },
                    "maxCount": {
                        "type": "integer",
                        "description": "Maximum number of snapshots to retain, even if the snapshots have not yet expired.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Attaches arbitrary metadata to the snapshot.\n"
                    },
                    "minCount": {
                        "type": "integer",
                        "description": "Minimum number of snapshots to retain, even if the snapshots have expired.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "ID for the snapshot lifecycle policy you want to create or update.\n",
                        "willReplaceOnChanges": true
                    },
                    "partial": {
                        "type": "boolean",
                        "description": "If `false`, the entire snapshot will fail if one or more indices included in the snapshot do not have all primary shards available.\n"
                    },
                    "repository": {
                        "type": "string",
                        "description": "Repository used to store snapshots created by this policy.\n"
                    },
                    "schedule": {
                        "type": "string",
                        "description": "Periodic or absolute schedule at which the policy creates snapshots.\n"
                    },
                    "snapshotName": {
                        "type": "string",
                        "description": "Name automatically assigned to each snapshot created by the policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "elasticstack:index/snapshotRepository:SnapshotRepository": {
            "description": "Registers or updates a snapshot repository. See: https://www.elastic.co/guide/en/elasticsearch/reference/current/put-snapshot-repo-api.html and https://www.elastic.co/guide/en/elasticsearch/reference/current/snapshots-register-repository.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst myUrlRepo = new elasticstack.SnapshotRepository(\"myUrlRepo\", {url: {\n    url: \"https://example.com/repo\",\n}});\nconst myFsRepo = new elasticstack.SnapshotRepository(\"myFsRepo\", {fs: {\n    compress: true,\n    location: \"/tmp\",\n    maxRestoreBytesPerSec: \"10mb\",\n}});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nmy_url_repo = elasticstack.SnapshotRepository(\"myUrlRepo\", url=elasticstack.SnapshotRepositoryUrlArgs(\n    url=\"https://example.com/repo\",\n))\nmy_fs_repo = elasticstack.SnapshotRepository(\"myFsRepo\", fs=elasticstack.SnapshotRepositoryFsArgs(\n    compress=True,\n    location=\"/tmp\",\n    max_restore_bytes_per_sec=\"10mb\",\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myUrlRepo = new Elasticstack.SnapshotRepository(\"myUrlRepo\", new()\n    {\n        Url = new Elasticstack.Inputs.SnapshotRepositoryUrlArgs\n        {\n            Url = \"https://example.com/repo\",\n        },\n    });\n\n    var myFsRepo = new Elasticstack.SnapshotRepository(\"myFsRepo\", new()\n    {\n        Fs = new Elasticstack.Inputs.SnapshotRepositoryFsArgs\n        {\n            Compress = true,\n            Location = \"/tmp\",\n            MaxRestoreBytesPerSec = \"10mb\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := elasticstack.NewSnapshotRepository(ctx, \"myUrlRepo\", \u0026elasticstack.SnapshotRepositoryArgs{\n\t\t\tUrl: \u0026elasticstack.SnapshotRepositoryUrlArgs{\n\t\t\t\tUrl: pulumi.String(\"https://example.com/repo\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewSnapshotRepository(ctx, \"myFsRepo\", \u0026elasticstack.SnapshotRepositoryArgs{\n\t\t\tFs: \u0026elasticstack.SnapshotRepositoryFsArgs{\n\t\t\t\tCompress:              pulumi.Bool(true),\n\t\t\t\tLocation:              pulumi.String(\"/tmp\"),\n\t\t\t\tMaxRestoreBytesPerSec: pulumi.String(\"10mb\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.SnapshotRepository;\nimport com.pulumi.elasticstack.SnapshotRepositoryArgs;\nimport com.pulumi.elasticstack.inputs.SnapshotRepositoryUrlArgs;\nimport com.pulumi.elasticstack.inputs.SnapshotRepositoryFsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myUrlRepo = new SnapshotRepository(\"myUrlRepo\", SnapshotRepositoryArgs.builder()        \n            .url(SnapshotRepositoryUrlArgs.builder()\n                .url(\"https://example.com/repo\")\n                .build())\n            .build());\n\n        var myFsRepo = new SnapshotRepository(\"myFsRepo\", SnapshotRepositoryArgs.builder()        \n            .fs(SnapshotRepositoryFsArgs.builder()\n                .compress(true)\n                .location(\"/tmp\")\n                .maxRestoreBytesPerSec(\"10mb\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myUrlRepo:\n    type: elasticstack:SnapshotRepository\n    properties:\n      url:\n        url: https://example.com/repo\n  myFsRepo:\n    type: elasticstack:SnapshotRepository\n    properties:\n      fs:\n        compress: true\n        location: /tmp\n        maxRestoreBytesPerSec: 10mb\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import elasticstack:index/snapshotRepository:SnapshotRepository my_repository \u003ccluster_uuid\u003e/\u003crepository name\u003e\n```\n\n ",
            "properties": {
                "azure": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryAzure:SnapshotRepositoryAzure",
                    "description": "Support for using Azure Blob storage as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-azure.html\n"
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryElasticsearchConnection:SnapshotRepositoryElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "fs": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryFs:SnapshotRepositoryFs",
                    "description": "Shared filesystem repository. Repositories of this type use a shared filesystem to store snapshots. This filesystem must be accessible to all master and data nodes in the cluster.\n"
                },
                "gcs": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryGcs:SnapshotRepositoryGcs",
                    "description": "Support for using the Google Cloud Storage service as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-gcs.html\n"
                },
                "hdfs": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryHdfs:SnapshotRepositoryHdfs",
                    "description": "Support for using HDFS File System as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-hdfs.html\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the snapshot repository to register or update.\n"
                },
                "s3": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryS3:SnapshotRepositoryS3",
                    "description": "Support for using AWS S3 as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-s3-repository.html\n"
                },
                "url": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryUrl:SnapshotRepositoryUrl",
                    "description": "URL repository. Repositories of this type are read-only for the cluster. This means the cluster can retrieve or restore snapshots from the repository but cannot write or create snapshots in it.\n"
                },
                "verify": {
                    "type": "boolean",
                    "description": "If true, the request verifies the repository is functional on all master and data nodes in the cluster.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "azure": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryAzure:SnapshotRepositoryAzure",
                    "description": "Support for using Azure Blob storage as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-azure.html\n",
                    "willReplaceOnChanges": true
                },
                "elasticsearchConnection": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryElasticsearchConnection:SnapshotRepositoryElasticsearchConnection",
                    "description": "Elasticsearch connection configuration block.\n"
                },
                "fs": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryFs:SnapshotRepositoryFs",
                    "description": "Shared filesystem repository. Repositories of this type use a shared filesystem to store snapshots. This filesystem must be accessible to all master and data nodes in the cluster.\n",
                    "willReplaceOnChanges": true
                },
                "gcs": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryGcs:SnapshotRepositoryGcs",
                    "description": "Support for using the Google Cloud Storage service as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-gcs.html\n",
                    "willReplaceOnChanges": true
                },
                "hdfs": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryHdfs:SnapshotRepositoryHdfs",
                    "description": "Support for using HDFS File System as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-hdfs.html\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of the snapshot repository to register or update.\n",
                    "willReplaceOnChanges": true
                },
                "s3": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryS3:SnapshotRepositoryS3",
                    "description": "Support for using AWS S3 as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-s3-repository.html\n",
                    "willReplaceOnChanges": true
                },
                "url": {
                    "$ref": "#/types/elasticstack:index/SnapshotRepositoryUrl:SnapshotRepositoryUrl",
                    "description": "URL repository. Repositories of this type are read-only for the cluster. This means the cluster can retrieve or restore snapshots from the repository but cannot write or create snapshots in it.\n",
                    "willReplaceOnChanges": true
                },
                "verify": {
                    "type": "boolean",
                    "description": "If true, the request verifies the repository is functional on all master and data nodes in the cluster.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SnapshotRepository resources.\n",
                "properties": {
                    "azure": {
                        "$ref": "#/types/elasticstack:index/SnapshotRepositoryAzure:SnapshotRepositoryAzure",
                        "description": "Support for using Azure Blob storage as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-azure.html\n",
                        "willReplaceOnChanges": true
                    },
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/SnapshotRepositoryElasticsearchConnection:SnapshotRepositoryElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "fs": {
                        "$ref": "#/types/elasticstack:index/SnapshotRepositoryFs:SnapshotRepositoryFs",
                        "description": "Shared filesystem repository. Repositories of this type use a shared filesystem to store snapshots. This filesystem must be accessible to all master and data nodes in the cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "gcs": {
                        "$ref": "#/types/elasticstack:index/SnapshotRepositoryGcs:SnapshotRepositoryGcs",
                        "description": "Support for using the Google Cloud Storage service as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-gcs.html\n",
                        "willReplaceOnChanges": true
                    },
                    "hdfs": {
                        "$ref": "#/types/elasticstack:index/SnapshotRepositoryHdfs:SnapshotRepositoryHdfs",
                        "description": "Support for using HDFS File System as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-hdfs.html\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the snapshot repository to register or update.\n",
                        "willReplaceOnChanges": true
                    },
                    "s3": {
                        "$ref": "#/types/elasticstack:index/SnapshotRepositoryS3:SnapshotRepositoryS3",
                        "description": "Support for using AWS S3 as a repository for Snapshot/Restore. See: https://www.elastic.co/guide/en/elasticsearch/plugins/current/repository-s3-repository.html\n",
                        "willReplaceOnChanges": true
                    },
                    "url": {
                        "$ref": "#/types/elasticstack:index/SnapshotRepositoryUrl:SnapshotRepositoryUrl",
                        "description": "URL repository. Repositories of this type are read-only for the cluster. This means the cluster can retrieve or restore snapshots from the repository but cannot write or create snapshots in it.\n",
                        "willReplaceOnChanges": true
                    },
                    "verify": {
                        "type": "boolean",
                        "description": "If true, the request verifies the repository is functional on all master and data nodes in the cluster.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "elasticstack:index/getIngestProcessorAppend:getIngestProcessorAppend": {
            "description": "Helper data source to which can be used to create a processor to append one or more values to an existing array if the field already exists and it is an array.\nConverts a scalar to an array and appends one or more values to it if the field exists and it is a scalar. Creates an array containing the provided values if the field doesnt exist.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/append-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst tags = elasticstack.getIngestProcessorAppend({\n    field: \"tags\",\n    values: [\n        \"production\",\n        \"{{{app}}}\",\n        \"{{{owner}}}\",\n    ],\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [tags.then(tags =\u003e tags.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ntags = elasticstack.get_ingest_processor_append(field=\"tags\",\n    values=[\n        \"production\",\n        \"{{{app}}}\",\n        \"{{{owner}}}\",\n    ])\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[tags.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tags = Elasticstack.GetIngestProcessorAppend.Invoke(new()\n    {\n        Field = \"tags\",\n        Values = new[]\n        {\n            \"production\",\n            \"{{{app}}}\",\n            \"{{{owner}}}\",\n        },\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            tags.Apply(getIngestProcessorAppendResult =\u003e getIngestProcessorAppendResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttags, err := elasticstack.GetIngestProcessorAppend(ctx, \u0026elasticstack.GetIngestProcessorAppendArgs{\n\t\t\tField: \"tags\",\n\t\t\tValues: []string{\n\t\t\t\t\"production\",\n\t\t\t\t\"{{{app}}}\",\n\t\t\t\t\"{{{owner}}}\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(tags.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorAppendArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var tags = ElasticstackFunctions.getIngestProcessorAppend(GetIngestProcessorAppendArgs.builder()\n            .field(\"tags\")\n            .values(            \n                \"production\",\n                \"{{{app}}}\",\n                \"{{{owner}}}\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(tags.applyValue(getIngestProcessorAppendResult -\u003e getIngestProcessorAppendResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${tags.json}\nvariables:\n  tags:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorAppend\n      Arguments:\n        field: tags\n        values:\n          - production\n          - '{{{app}}}'\n          - '{{{owner}}}'\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorAppend.\n",
                "properties": {
                    "allowDuplicates": {
                        "type": "boolean",
                        "description": "If `false`, the processor does not append values already present in the field.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to be appended to.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "mediaType": {
                        "type": "string",
                        "description": "The media type for encoding value. Applies only when value is a template snippet. Must be one of `application/json`, `text/plain`, or `application/x-www-form-urlencoded`. Supported only from Elasticsearch version **7.15**.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "values": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The value to be appended.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "values"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorAppend.\n",
                "properties": {
                    "allowDuplicates": {
                        "type": "boolean",
                        "description": "If `false`, the processor does not append values already present in the field.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to be appended to.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "mediaType": {
                        "type": "string",
                        "description": "The media type for encoding value. Applies only when value is a template snippet. Must be one of `application/json`, `text/plain`, or `application/x-www-form-urlencoded`. Supported only from Elasticsearch version **7.15**.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "values": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The value to be appended.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json",
                    "values"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorBytes:getIngestProcessorBytes": {
            "description": "Helper data source to which can be used to create a processor to convert a human readable byte value (e.g. 1kb) to its value in bytes (e.g. 1024). If the field is an array of strings, all members of the array will be converted.\n\nSupported human readable units are \"b\", \"kb\", \"mb\", \"gb\", \"tb\", \"pb\" case insensitive. An error will occur if the field is not a supported format or resultant value exceeds 2^63.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/bytes-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst bytes = elasticstack.getIngestProcessorBytes({\n    field: \"file.size\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [bytes.then(bytes =\u003e bytes.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nbytes = elasticstack.get_ingest_processor_bytes(field=\"file.size\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[bytes.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var bytes = Elasticstack.GetIngestProcessorBytes.Invoke(new()\n    {\n        Field = \"file.size\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            bytes.Apply(getIngestProcessorBytesResult =\u003e getIngestProcessorBytesResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tbytes, err := elasticstack.GetIngestProcessorBytes(ctx, \u0026elasticstack.GetIngestProcessorBytesArgs{\n\t\t\tField: \"file.size\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(bytes.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorBytesArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var bytes = ElasticstackFunctions.getIngestProcessorBytes(GetIngestProcessorBytesArgs.builder()\n            .field(\"file.size\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(bytes.applyValue(getIngestProcessorBytesResult -\u003e getIngestProcessorBytesResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${bytes.json}\nvariables:\n  bytes:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorBytes\n      Arguments:\n        field: file.size\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorBytes.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to convert\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorBytes.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to convert\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorCircle:getIngestProcessorCircle": {
            "description": "Helper data source to which can be used to create a processor to convert circle definitions of shapes to regular polygons which approximate them.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest-circle-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst circle = elasticstack.getIngestProcessorCircle({\n    field: \"circle\",\n    errorDistance: 28.1,\n    shapeType: \"geo_shape\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [circle.then(circle =\u003e circle.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ncircle = elasticstack.get_ingest_processor_circle(field=\"circle\",\n    error_distance=28.1,\n    shape_type=\"geo_shape\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[circle.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var circle = Elasticstack.GetIngestProcessorCircle.Invoke(new()\n    {\n        Field = \"circle\",\n        ErrorDistance = 28.1,\n        ShapeType = \"geo_shape\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            circle.Apply(getIngestProcessorCircleResult =\u003e getIngestProcessorCircleResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcircle, err := elasticstack.GetIngestProcessorCircle(ctx, \u0026elasticstack.GetIngestProcessorCircleArgs{\n\t\t\tField:         \"circle\",\n\t\t\tErrorDistance: 28.1,\n\t\t\tShapeType:     \"geo_shape\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(circle.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorCircleArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var circle = ElasticstackFunctions.getIngestProcessorCircle(GetIngestProcessorCircleArgs.builder()\n            .field(\"circle\")\n            .errorDistance(28.1)\n            .shapeType(\"geo_shape\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(circle.applyValue(getIngestProcessorCircleResult -\u003e getIngestProcessorCircleResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${circle.json}\nvariables:\n  circle:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorCircle\n      Arguments:\n        field: circle\n        errorDistance: 28.1\n        shapeType: geo_shape\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorCircle.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "errorDistance": {
                        "type": "number",
                        "description": "The difference between the resulting inscribed distance from center to side and the circles radius (measured in meters for `geo_shape`, unit-less for `shape`)\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The string-valued field to trim whitespace from.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "shapeType": {
                        "type": "string",
                        "description": "Which field mapping type is to be used when processing the circle.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place\n"
                    }
                },
                "type": "object",
                "required": [
                    "errorDistance",
                    "field",
                    "shapeType"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorCircle.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "errorDistance": {
                        "type": "number",
                        "description": "The difference between the resulting inscribed distance from center to side and the circles radius (measured in meters for `geo_shape`, unit-less for `shape`)\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The string-valued field to trim whitespace from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "shapeType": {
                        "type": "string",
                        "description": "Which field mapping type is to be used when processing the circle.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place\n"
                    }
                },
                "type": "object",
                "required": [
                    "errorDistance",
                    "field",
                    "id",
                    "json",
                    "shapeType"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorCommunityId:getIngestProcessorCommunityId": {
            "description": "Helper data source to which can be used to create a processor to compute the Community ID for network flow data as defined in the [Community ID Specification](https://github.com/corelight/community-id-spec). \nYou can use a community ID to correlate network events related to a single flow.\n\nThe community ID processor reads network flow data from related [Elastic Common Schema (ECS)](https://www.elastic.co/guide/en/ecs/1.12) fields by default. If you use the ECS, no configuration is required.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/community-id-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst community = elasticstack.getIngestProcessorCommunityId({});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [community.then(community =\u003e community.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ncommunity = elasticstack.get_ingest_processor_community_id()\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[community.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var community = Elasticstack.GetIngestProcessorCommunityId.Invoke();\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            community.Apply(getIngestProcessorCommunityIdResult =\u003e getIngestProcessorCommunityIdResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcommunity, err := elasticstack.GetIngestProcessorCommunityId(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(community.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorCommunityIdArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var community = ElasticstackFunctions.getIngestProcessorCommunityId();\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(community.applyValue(getIngestProcessorCommunityIdResult -\u003e getIngestProcessorCommunityIdResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${community.json}\nvariables:\n  community:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorCommunityId\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorCommunityId.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "destinationIp": {
                        "type": "string",
                        "description": "Field containing the destination IP address.\n"
                    },
                    "destinationPort": {
                        "type": "integer",
                        "description": "Field containing the destination port.\n"
                    },
                    "ianaNumber": {
                        "type": "integer",
                        "description": "Field containing the IANA number.\n"
                    },
                    "icmpCode": {
                        "type": "integer",
                        "description": "Field containing the ICMP code.\n"
                    },
                    "icmpType": {
                        "type": "integer",
                        "description": "Field containing the ICMP type.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "seed": {
                        "type": "integer",
                        "description": "Seed for the community ID hash. Must be between 0 and 65535 (inclusive). The seed can prevent hash collisions between network domains, such as a staging and production network that use the same addressing scheme.\n"
                    },
                    "sourceIp": {
                        "type": "string",
                        "description": "Field containing the source IP address.\n"
                    },
                    "sourcePort": {
                        "type": "integer",
                        "description": "Field containing the source port.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Output field for the community ID.\n"
                    },
                    "transport": {
                        "type": "string",
                        "description": "Field containing the transport protocol. Used only when the `iana_number` field is not present.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorCommunityId.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "destinationIp": {
                        "type": "string",
                        "description": "Field containing the destination IP address.\n"
                    },
                    "destinationPort": {
                        "type": "integer",
                        "description": "Field containing the destination port.\n"
                    },
                    "ianaNumber": {
                        "type": "integer",
                        "description": "Field containing the IANA number.\n"
                    },
                    "icmpCode": {
                        "type": "integer",
                        "description": "Field containing the ICMP code.\n"
                    },
                    "icmpType": {
                        "type": "integer",
                        "description": "Field containing the ICMP type.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "seed": {
                        "type": "integer",
                        "description": "Seed for the community ID hash. Must be between 0 and 65535 (inclusive). The seed can prevent hash collisions between network domains, such as a staging and production network that use the same addressing scheme.\n"
                    },
                    "sourceIp": {
                        "type": "string",
                        "description": "Field containing the source IP address.\n"
                    },
                    "sourcePort": {
                        "type": "integer",
                        "description": "Field containing the source port.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Output field for the community ID.\n"
                    },
                    "transport": {
                        "type": "string",
                        "description": "Field containing the transport protocol. Used only when the `iana_number` field is not present.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorConvert:getIngestProcessorConvert": {
            "description": "Helper data source to which can be used to convert a field in the currently ingested document to a different type, such as converting a string to an integer. If the field value is an array, all members will be converted.\n\nThe supported types include: `integer`, `long`, `float`, `double`, `string`, `boolean`, `ip`, and `auto`.\n\nSpecifying `boolean` will set the field to true if its string value is equal to true (ignore case), to false if its string value is equal to false (ignore case), or it will throw an exception otherwise.\n\nSpecifying `ip` will set the target field to the value of `field` if it contains a valid IPv4 or IPv6 address that can be indexed into an IP field type.\n\nSpecifying `auto` will attempt to convert the string-valued `field` into the closest non-string, non-IP type. For example, a field whose value is \"true\" will be converted to its respective boolean type: true. Do note that float takes precedence of double in auto. A value of \"242.15\" will \"automatically\" be converted to 242.15 of type `float`. If a provided field cannot be appropriately converted, the processor will still process successfully and leave the field value as-is. In such a case, `target_field` will be updated with the unconverted field value.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/convert-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst convert = elasticstack.getIngestProcessorConvert({\n    description: \"converts the content of the id field to an integer\",\n    field: \"id\",\n    type: \"integer\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [convert.then(convert =\u003e convert.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nconvert = elasticstack.get_ingest_processor_convert(description=\"converts the content of the id field to an integer\",\n    field=\"id\",\n    type=\"integer\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[convert.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var convert = Elasticstack.GetIngestProcessorConvert.Invoke(new()\n    {\n        Description = \"converts the content of the id field to an integer\",\n        Field = \"id\",\n        Type = \"integer\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            convert.Apply(getIngestProcessorConvertResult =\u003e getIngestProcessorConvertResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconvert, err := elasticstack.GetIngestProcessorConvert(ctx, \u0026elasticstack.GetIngestProcessorConvertArgs{\n\t\t\tDescription: pulumi.StringRef(\"converts the content of the id field to an integer\"),\n\t\t\tField:       \"id\",\n\t\t\tType:        \"integer\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(convert.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorConvertArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var convert = ElasticstackFunctions.getIngestProcessorConvert(GetIngestProcessorConvertArgs.builder()\n            .description(\"converts the content of the id field to an integer\")\n            .field(\"id\")\n            .type(\"integer\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(convert.applyValue(getIngestProcessorConvertResult -\u003e getIngestProcessorConvertResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${convert.json}\nvariables:\n  convert:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorConvert\n      Arguments:\n        description: converts the content of the id field to an integer\n        field: id\n        type: integer\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorConvert.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field whose value is to be converted.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type to convert the existing value to\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "type"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorConvert.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field whose value is to be converted.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type to convert the existing value to\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json",
                    "type"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorCsv:getIngestProcessorCsv": {
            "description": "Helper data source to which can be used to extract fields from CSV line out of a single text field within a document. Any empty field in CSV will be skipped.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/csv-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst csv = elasticstack.getIngestProcessorCsv({\n    field: \"my_field\",\n    targetFields: [\n        \"field1\",\n        \"field2\",\n    ],\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [csv.then(csv =\u003e csv.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ncsv = elasticstack.get_ingest_processor_csv(field=\"my_field\",\n    target_fields=[\n        \"field1\",\n        \"field2\",\n    ])\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[csv.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var csv = Elasticstack.GetIngestProcessorCsv.Invoke(new()\n    {\n        Field = \"my_field\",\n        TargetFields = new[]\n        {\n            \"field1\",\n            \"field2\",\n        },\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            csv.Apply(getIngestProcessorCsvResult =\u003e getIngestProcessorCsvResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcsv, err := elasticstack.GetIngestProcessorCsv(ctx, \u0026elasticstack.GetIngestProcessorCsvArgs{\n\t\t\tField: \"my_field\",\n\t\t\tTargetFields: []string{\n\t\t\t\t\"field1\",\n\t\t\t\t\"field2\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(csv.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorCsvArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var csv = ElasticstackFunctions.getIngestProcessorCsv(GetIngestProcessorCsvArgs.builder()\n            .field(\"my_field\")\n            .targetFields(            \n                \"field1\",\n                \"field2\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(csv.applyValue(getIngestProcessorCsvResult -\u003e getIngestProcessorCsvResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${csv.json}\nvariables:\n  csv:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorCsv\n      Arguments:\n        field: my_field\n        targetFields:\n          - field1\n          - field2\n```\n\nIf the `trim` option is enabled then any whitespace in the beginning and in the end of each unquoted field will be trimmed. For example with configuration above, a value of A, B will result in field field2 having value {nbsp}B (with space at the beginning). If trim is enabled A, B will result in field field2 having value B (no whitespace). Quoted fields will be left untouched.\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorCsv.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "emptyValue": {
                        "type": "string",
                        "description": "Value used to fill empty fields, empty fields will be skipped if this is not provided.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to extract data from.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "quote": {
                        "type": "string",
                        "description": "Quote used in CSV, has to be single character string\n"
                    },
                    "separator": {
                        "type": "string",
                        "description": "Separator used in CSV, has to be single character string.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetFields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The array of fields to assign extracted values to.\n"
                    },
                    "trim": {
                        "type": "boolean",
                        "description": "Trim whitespaces in unquoted fields.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "targetFields"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorCsv.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "emptyValue": {
                        "type": "string",
                        "description": "Value used to fill empty fields, empty fields will be skipped if this is not provided.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to extract data from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "quote": {
                        "type": "string",
                        "description": "Quote used in CSV, has to be single character string\n"
                    },
                    "separator": {
                        "type": "string",
                        "description": "Separator used in CSV, has to be single character string.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetFields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The array of fields to assign extracted values to.\n"
                    },
                    "trim": {
                        "type": "boolean",
                        "description": "Trim whitespaces in unquoted fields.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json",
                    "targetFields"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorDate:getIngestProcessorDate": {
            "description": "Helper data source to which can be used to parse dates from fields, and then uses the date or timestamp as the timestamp for the document. \nBy default, the date processor adds the parsed date as a new field called `@timestamp`. You can specify a different field by setting the `target_field` configuration parameter. Multiple date formats are supported as part of the same date processor definition. They will be used sequentially to attempt parsing the date field, in the same order they were defined as part of the processor definition.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/date-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nHere is an example that adds the parsed date to the `timestamp` field based on the `initial_date` field:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst date = elasticstack.getIngestProcessorDate({\n    field: \"initial_date\",\n    targetField: \"timestamp\",\n    formats: [\"dd/MM/yyyy HH:mm:ss\"],\n    timezone: \"Europe/Amsterdam\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [date.then(date =\u003e date.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ndate = elasticstack.get_ingest_processor_date(field=\"initial_date\",\n    target_field=\"timestamp\",\n    formats=[\"dd/MM/yyyy HH:mm:ss\"],\n    timezone=\"Europe/Amsterdam\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[date.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var date = Elasticstack.GetIngestProcessorDate.Invoke(new()\n    {\n        Field = \"initial_date\",\n        TargetField = \"timestamp\",\n        Formats = new[]\n        {\n            \"dd/MM/yyyy HH:mm:ss\",\n        },\n        Timezone = \"Europe/Amsterdam\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            date.Apply(getIngestProcessorDateResult =\u003e getIngestProcessorDateResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdate, err := elasticstack.GetIngestProcessorDate(ctx, \u0026elasticstack.GetIngestProcessorDateArgs{\n\t\t\tField:       \"initial_date\",\n\t\t\tTargetField: pulumi.StringRef(\"timestamp\"),\n\t\t\tFormats: []string{\n\t\t\t\t\"dd/MM/yyyy HH:mm:ss\",\n\t\t\t},\n\t\t\tTimezone: pulumi.StringRef(\"Europe/Amsterdam\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(date.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorDateArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var date = ElasticstackFunctions.getIngestProcessorDate(GetIngestProcessorDateArgs.builder()\n            .field(\"initial_date\")\n            .targetField(\"timestamp\")\n            .formats(\"dd/MM/yyyy HH:mm:ss\")\n            .timezone(\"Europe/Amsterdam\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(date.applyValue(getIngestProcessorDateResult -\u003e getIngestProcessorDateResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${date.json}\nvariables:\n  date:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorDate\n      Arguments:\n        field: initial_date\n        targetField: timestamp\n        formats:\n          - dd/MM/yyyy HH:mm:ss\n        timezone: Europe/Amsterdam\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorDate.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to get the date from.\n"
                    },
                    "formats": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of the expected date formats.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "locale": {
                        "type": "string",
                        "description": "The locale to use when parsing the date, relevant when parsing month names or week days.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "outputFormat": {
                        "type": "string",
                        "description": "The format to use when writing the date to `target_field`.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field that will hold the parsed date.\n"
                    },
                    "timezone": {
                        "type": "string",
                        "description": "The timezone to use when parsing the date.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "formats"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorDate.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to get the date from.\n"
                    },
                    "formats": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of the expected date formats.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "locale": {
                        "type": "string",
                        "description": "The locale to use when parsing the date, relevant when parsing month names or week days.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "outputFormat": {
                        "type": "string",
                        "description": "The format to use when writing the date to `target_field`.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field that will hold the parsed date.\n"
                    },
                    "timezone": {
                        "type": "string",
                        "description": "The timezone to use when parsing the date.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "formats",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorDateIndexName:getIngestProcessorDateIndexName": {
            "description": "The purpose of this processor is to point documents to the right time based index based on a date or timestamp field in a document by using the date math index name support.\n\nThe processor sets the _index metadata field with a date math index name expression based on the provided index name prefix, a date or timestamp field in the documents being processed and the provided date rounding.\n\nFirst, this processor fetches the date or timestamp from a field in the document being processed. Optionally, date formatting can be configured on how the fields value should be parsed into a date. Then this date, the provided index name prefix and the provided date rounding get formatted into a date math index name expression. Also here optionally date formatting can be specified on how the date should be formatted into a date math index name expression.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/date-index-name-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst dateIndexName = elasticstack.getIngestProcessorDateIndexName({\n    description: \"monthly date-time index naming\",\n    field: \"date1\",\n    indexNamePrefix: \"my-index-\",\n    dateRounding: \"M\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [dateIndexName.then(dateIndexName =\u003e dateIndexName.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ndate_index_name = elasticstack.get_ingest_processor_date_index_name(description=\"monthly date-time index naming\",\n    field=\"date1\",\n    index_name_prefix=\"my-index-\",\n    date_rounding=\"M\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[date_index_name.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dateIndexName = Elasticstack.GetIngestProcessorDateIndexName.Invoke(new()\n    {\n        Description = \"monthly date-time index naming\",\n        Field = \"date1\",\n        IndexNamePrefix = \"my-index-\",\n        DateRounding = \"M\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            dateIndexName.Apply(getIngestProcessorDateIndexNameResult =\u003e getIngestProcessorDateIndexNameResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdateIndexName, err := elasticstack.GetIngestProcessorDateIndexName(ctx, \u0026elasticstack.GetIngestProcessorDateIndexNameArgs{\n\t\t\tDescription:     pulumi.StringRef(\"monthly date-time index naming\"),\n\t\t\tField:           \"date1\",\n\t\t\tIndexNamePrefix: pulumi.StringRef(\"my-index-\"),\n\t\t\tDateRounding:    \"M\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(dateIndexName.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorDateIndexNameArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dateIndexName = ElasticstackFunctions.getIngestProcessorDateIndexName(GetIngestProcessorDateIndexNameArgs.builder()\n            .description(\"monthly date-time index naming\")\n            .field(\"date1\")\n            .indexNamePrefix(\"my-index-\")\n            .dateRounding(\"M\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(dateIndexName.applyValue(getIngestProcessorDateIndexNameResult -\u003e getIngestProcessorDateIndexNameResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${dateIndexName.json}\nvariables:\n  dateIndexName:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorDateIndexName\n      Arguments:\n        description: monthly date-time index naming\n        field: date1\n        indexNamePrefix: my-index-\n        dateRounding: M\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorDateIndexName.\n",
                "properties": {
                    "dateFormats": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of the expected date formats for parsing dates / timestamps in the document being preprocessed.\n"
                    },
                    "dateRounding": {
                        "type": "string",
                        "description": "How to round the date when formatting the date into the index name.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to get the date or timestamp from.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "indexNameFormat": {
                        "type": "string",
                        "description": "The format to be used when printing the parsed date into the index name.\n"
                    },
                    "indexNamePrefix": {
                        "type": "string",
                        "description": "A prefix of the index name to be prepended before the printed date.\n"
                    },
                    "locale": {
                        "type": "string",
                        "description": "The locale to use when parsing the date from the document being preprocessed, relevant when parsing month names or week days.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "timezone": {
                        "type": "string",
                        "description": "The timezone to use when parsing the date and when date math index supports resolves expressions into concrete index names.\n"
                    }
                },
                "type": "object",
                "required": [
                    "dateRounding",
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorDateIndexName.\n",
                "properties": {
                    "dateFormats": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of the expected date formats for parsing dates / timestamps in the document being preprocessed.\n"
                    },
                    "dateRounding": {
                        "type": "string",
                        "description": "How to round the date when formatting the date into the index name.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to get the date or timestamp from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "indexNameFormat": {
                        "type": "string",
                        "description": "The format to be used when printing the parsed date into the index name.\n"
                    },
                    "indexNamePrefix": {
                        "type": "string",
                        "description": "A prefix of the index name to be prepended before the printed date.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "locale": {
                        "type": "string",
                        "description": "The locale to use when parsing the date from the document being preprocessed, relevant when parsing month names or week days.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "timezone": {
                        "type": "string",
                        "description": "The timezone to use when parsing the date and when date math index supports resolves expressions into concrete index names.\n"
                    }
                },
                "type": "object",
                "required": [
                    "dateRounding",
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorDissect:getIngestProcessorDissect": {
            "description": "Similar to the Grok Processor, dissect also extracts structured fields out of a single text field within a document. However unlike the Grok Processor, dissect does not use Regular Expressions. This allows dissects syntax to be simple and for some cases faster than the Grok Processor.\n\nDissect matches a single text field against a defined pattern.\n\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/dissect-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst dissect = elasticstack.getIngestProcessorDissect({\n    field: \"message\",\n    pattern: `%{clientip} %{ident} %{auth} [%{@timestamp}] \"%{verb} %{request} HTTP/%{httpversion}\" %{status} %{size}`,\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [dissect.then(dissect =\u003e dissect.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ndissect = elasticstack.get_ingest_processor_dissect(field=\"message\",\n    pattern=\"%{clientip} %{ident} %{auth} [%{@timestamp}] \\\"%{verb} %{request} HTTP/%{httpversion}\\\" %{status} %{size}\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[dissect.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dissect = Elasticstack.GetIngestProcessorDissect.Invoke(new()\n    {\n        Field = \"message\",\n        Pattern = \"%{clientip} %{ident} %{auth} [%{@timestamp}] \\\"%{verb} %{request} HTTP/%{httpversion}\\\" %{status} %{size}\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            dissect.Apply(getIngestProcessorDissectResult =\u003e getIngestProcessorDissectResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdissect, err := elasticstack.GetIngestProcessorDissect(ctx, \u0026elasticstack.GetIngestProcessorDissectArgs{\n\t\t\tField:   \"message\",\n\t\t\tPattern: fmt.Sprintf(\"%vclientip} %vident} %vauth} [%v@timestamp}] \\\"%vverb} %vrequest} HTTP/%vhttpversion}\\\" %vstatus} %vsize}\", \"%{\", \"%{\", \"%{\", \"%{\", \"%{\", \"%{\", \"%{\", \"%{\", \"%{\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(dissect.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorDissectArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dissect = ElasticstackFunctions.getIngestProcessorDissect(GetIngestProcessorDissectArgs.builder()\n            .field(\"message\")\n            .pattern(\"%{clientip} %{ident} %{auth} [%{@timestamp}] \\\"%{verb} %{request} HTTP/%{httpversion}\\\" %{status} %{size}\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(dissect.applyValue(getIngestProcessorDissectResult -\u003e getIngestProcessorDissectResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${dissect.json}\nvariables:\n  dissect:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorDissect\n      Arguments:\n        field: message\n        pattern: '%{clientip} %{ident} %{auth} [%{@timestamp}] \"%{verb} %{request} HTTP/%{httpversion}\" %{status} %{size}'\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorDissect.\n",
                "properties": {
                    "appendSeparator": {
                        "type": "string",
                        "description": "The character(s) that separate the appended fields.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to dissect.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "The pattern to apply to the field.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "pattern"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorDissect.\n",
                "properties": {
                    "appendSeparator": {
                        "type": "string",
                        "description": "The character(s) that separate the appended fields.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to dissect.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "The pattern to apply to the field.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json",
                    "pattern"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorDotExpander:getIngestProcessorDotExpander": {
            "description": "Expands a field with dots into an object field. This processor allows fields with dots in the name to be accessible by other processors in the pipeline. Otherwise these fields cant be accessed by any processor.\n\nSee: elastic.co/guide/en/elasticsearch/reference/current/dot-expand-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst dotExpander = elasticstack.getIngestProcessorDotExpander({\n    field: \"foo.bar\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [dotExpander.then(dotExpander =\u003e dotExpander.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ndot_expander = elasticstack.get_ingest_processor_dot_expander(field=\"foo.bar\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[dot_expander.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dotExpander = Elasticstack.GetIngestProcessorDotExpander.Invoke(new()\n    {\n        Field = \"foo.bar\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            dotExpander.Apply(getIngestProcessorDotExpanderResult =\u003e getIngestProcessorDotExpanderResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdotExpander, err := elasticstack.GetIngestProcessorDotExpander(ctx, \u0026elasticstack.GetIngestProcessorDotExpanderArgs{\n\t\t\tField: \"foo.bar\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(dotExpander.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorDotExpanderArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dotExpander = ElasticstackFunctions.getIngestProcessorDotExpander(GetIngestProcessorDotExpanderArgs.builder()\n            .field(\"foo.bar\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(dotExpander.applyValue(getIngestProcessorDotExpanderResult -\u003e getIngestProcessorDotExpanderResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${dotExpander.json}\nvariables:\n  dotExpander:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorDotExpander\n      Arguments:\n        field: foo.bar\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorDotExpander.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to expand into an object field. If set to *, all top-level fields will be expanded.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "override": {
                        "type": "boolean",
                        "description": "Controls the behavior when there is already an existing nested object that conflicts with the expanded field.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The field that contains the field to expand.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorDotExpander.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to expand into an object field. If set to *, all top-level fields will be expanded.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "override": {
                        "type": "boolean",
                        "description": "Controls the behavior when there is already an existing nested object that conflicts with the expanded field.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The field that contains the field to expand.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorDrop:getIngestProcessorDrop": {
            "description": "Drops the document without raising any errors. This is useful to prevent the document from getting indexed based on some condition.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/drop-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst drop = elasticstack.getIngestProcessorDrop({\n    \"if\": \"ctx.network_name == 'Guest'\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [drop.then(drop =\u003e drop.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ndrop = elasticstack.get_ingest_processor_drop(if_=\"ctx.network_name == 'Guest'\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[drop.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var drop = Elasticstack.GetIngestProcessorDrop.Invoke(new()\n    {\n        If = \"ctx.network_name == 'Guest'\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            drop.Apply(getIngestProcessorDropResult =\u003e getIngestProcessorDropResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdrop, err := elasticstack.GetIngestProcessorDrop(ctx, \u0026elasticstack.GetIngestProcessorDropArgs{\n\t\t\tIf: pulumi.StringRef(\"ctx.network_name == 'Guest'\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(drop.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorDropArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var drop = ElasticstackFunctions.getIngestProcessorDrop(GetIngestProcessorDropArgs.builder()\n            .if_(\"ctx.network_name == 'Guest'\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(drop.applyValue(getIngestProcessorDropResult -\u003e getIngestProcessorDropResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${drop.json}\nvariables:\n  drop:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorDrop\n      Arguments:\n        if: ctx.network_name == 'Guest'\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorDrop.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorDrop.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorEnrich:getIngestProcessorEnrich": {
            "description": "The enrich processor can enrich documents with data from another index. See enrich data section for more information about how to set this up.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest-enriching-data.html and https://www.elastic.co/guide/en/elasticsearch/reference/current/enrich-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst enrich = elasticstack.getIngestProcessorEnrich({\n    policyName: \"users-policy\",\n    field: \"email\",\n    targetField: \"user\",\n    maxMatches: 1,\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [enrich.then(enrich =\u003e enrich.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nenrich = elasticstack.get_ingest_processor_enrich(policy_name=\"users-policy\",\n    field=\"email\",\n    target_field=\"user\",\n    max_matches=1)\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[enrich.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var enrich = Elasticstack.GetIngestProcessorEnrich.Invoke(new()\n    {\n        PolicyName = \"users-policy\",\n        Field = \"email\",\n        TargetField = \"user\",\n        MaxMatches = 1,\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            enrich.Apply(getIngestProcessorEnrichResult =\u003e getIngestProcessorEnrichResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tenrich, err := elasticstack.GetIngestProcessorEnrich(ctx, \u0026elasticstack.GetIngestProcessorEnrichArgs{\n\t\t\tPolicyName:  \"users-policy\",\n\t\t\tField:       \"email\",\n\t\t\tTargetField: \"user\",\n\t\t\tMaxMatches:  pulumi.IntRef(1),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(enrich.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorEnrichArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var enrich = ElasticstackFunctions.getIngestProcessorEnrich(GetIngestProcessorEnrichArgs.builder()\n            .policyName(\"users-policy\")\n            .field(\"email\")\n            .targetField(\"user\")\n            .maxMatches(1)\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(enrich.applyValue(getIngestProcessorEnrichResult -\u003e getIngestProcessorEnrichResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${enrich.json}\nvariables:\n  enrich:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorEnrich\n      Arguments:\n        policyName: users-policy\n        field: email\n        targetField: user\n        maxMatches: 1\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorEnrich.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field in the input document that matches the policies match_field used to retrieve the enrichment data.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "maxMatches": {
                        "type": "integer",
                        "description": "The maximum number of matched documents to include under the configured target field.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "override": {
                        "type": "boolean",
                        "description": "If processor will update fields with pre-existing non-null-valued field.\n"
                    },
                    "policyName": {
                        "type": "string",
                        "description": "The name of the enrich policy to use.\n"
                    },
                    "shapeRelation": {
                        "type": "string",
                        "description": "A spatial relation operator used to match the geoshape of incoming documents to documents in the enrich index.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Field added to incoming documents to contain enrich data.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "policyName",
                    "targetField"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorEnrich.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field in the input document that matches the policies match_field used to retrieve the enrichment data.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "maxMatches": {
                        "type": "integer",
                        "description": "The maximum number of matched documents to include under the configured target field.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "override": {
                        "type": "boolean",
                        "description": "If processor will update fields with pre-existing non-null-valued field.\n"
                    },
                    "policyName": {
                        "type": "string",
                        "description": "The name of the enrich policy to use.\n"
                    },
                    "shapeRelation": {
                        "type": "string",
                        "description": "A spatial relation operator used to match the geoshape of incoming documents to documents in the enrich index.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Field added to incoming documents to contain enrich data.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json",
                    "policyName",
                    "targetField"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorFail:getIngestProcessorFail": {
            "description": "Raises an exception. This is useful for when you expect a pipeline to fail and want to relay a specific message to the requester.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/fail-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst fail = elasticstack.getIngestProcessorFail({\n    \"if\": \"ctx.tags.contains('production') != true\",\n    message: \"The production tag is not present, found tags: {{{tags}}}\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [fail.then(fail =\u003e fail.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nfail = elasticstack.get_ingest_processor_fail(if_=\"ctx.tags.contains('production') != true\",\n    message=\"The production tag is not present, found tags: {{{tags}}}\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[fail.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var fail = Elasticstack.GetIngestProcessorFail.Invoke(new()\n    {\n        If = \"ctx.tags.contains('production') != true\",\n        Message = \"The production tag is not present, found tags: {{{tags}}}\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            fail.Apply(getIngestProcessorFailResult =\u003e getIngestProcessorFailResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfail, err := elasticstack.GetIngestProcessorFail(ctx, \u0026elasticstack.GetIngestProcessorFailArgs{\n\t\t\tIf:      pulumi.StringRef(\"ctx.tags.contains('production') != true\"),\n\t\t\tMessage: \"The production tag is not present, found tags: {{{tags}}}\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(fail.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorFailArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var fail = ElasticstackFunctions.getIngestProcessorFail(GetIngestProcessorFailArgs.builder()\n            .if_(\"ctx.tags.contains('production') != true\")\n            .message(\"The production tag is not present, found tags: {{{tags}}}\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(fail.applyValue(getIngestProcessorFailResult -\u003e getIngestProcessorFailResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${fail.json}\nvariables:\n  fail:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorFail\n      Arguments:\n        if: ctx.tags.contains('production') != true\n        message: 'The production tag is not present, found tags: {{{tags}}}'\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorFail.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "message": {
                        "type": "string",
                        "description": "The error message thrown by the processor.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "message"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorFail.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "message": {
                        "type": "string",
                        "description": "The error message thrown by the processor.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id",
                    "json",
                    "message"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorFingerprint:getIngestProcessorFingerprint": {
            "description": "Computes a hash of the documents content. You can use this hash for content fingerprinting.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/fingerprint-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst fingerprint = elasticstack.getIngestProcessorFingerprint({\n    fields: [\"user\"],\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [fingerprint.then(fingerprint =\u003e fingerprint.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nfingerprint = elasticstack.get_ingest_processor_fingerprint(fields=[\"user\"])\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[fingerprint.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var fingerprint = Elasticstack.GetIngestProcessorFingerprint.Invoke(new()\n    {\n        Fields = new[]\n        {\n            \"user\",\n        },\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            fingerprint.Apply(getIngestProcessorFingerprintResult =\u003e getIngestProcessorFingerprintResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfingerprint, err := elasticstack.GetIngestProcessorFingerprint(ctx, \u0026elasticstack.GetIngestProcessorFingerprintArgs{\n\t\t\tFields: []string{\n\t\t\t\t\"user\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(fingerprint.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorFingerprintArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var fingerprint = ElasticstackFunctions.getIngestProcessorFingerprint(GetIngestProcessorFingerprintArgs.builder()\n            .fields(\"user\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(fingerprint.applyValue(getIngestProcessorFingerprintResult -\u003e getIngestProcessorFingerprintResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${fingerprint.json}\nvariables:\n  fingerprint:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorFingerprint\n      Arguments:\n        fields:\n          - user\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorFingerprint.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "fields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of fields to include in the fingerprint.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true`, the processor ignores any missing `fields`. If all fields are missing, the processor silently exits without modifying the document.\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "The hash method used to compute the fingerprint.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "salt": {
                        "type": "string",
                        "description": "Salt value for the hash function.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Output field for the fingerprint.\n"
                    }
                },
                "type": "object",
                "required": [
                    "fields"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorFingerprint.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "fields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of fields to include in the fingerprint.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true`, the processor ignores any missing `fields`. If all fields are missing, the processor silently exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "method": {
                        "type": "string",
                        "description": "The hash method used to compute the fingerprint.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "salt": {
                        "type": "string",
                        "description": "Salt value for the hash function.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Output field for the fingerprint.\n"
                    }
                },
                "type": "object",
                "required": [
                    "fields",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorForeach:getIngestProcessorForeach": {
            "description": "Runs an ingest processor on each element of an array or object.\n\nAll ingest processors can run on array or object elements. However, if the number of elements is unknown, it can be cumbersome to process each one in the same way.\n\nThe `foreach` processor lets you specify a `field` containing array or object values and a `processor` to run on each element in the field.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/foreach-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst convert = elasticstack.getIngestProcessorConvert({\n    field: \"_ingest._value\",\n    type: \"integer\",\n});\nconst foreach = convert.then(convert =\u003e elasticstack.getIngestProcessorForeach({\n    field: \"values\",\n    processor: convert.json,\n}));\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [foreach.then(foreach =\u003e foreach.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nconvert = elasticstack.get_ingest_processor_convert(field=\"_ingest._value\",\n    type=\"integer\")\nforeach = elasticstack.get_ingest_processor_foreach(field=\"values\",\n    processor=convert.json)\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[foreach.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var convert = Elasticstack.GetIngestProcessorConvert.Invoke(new()\n    {\n        Field = \"_ingest._value\",\n        Type = \"integer\",\n    });\n\n    var @foreach = Elasticstack.GetIngestProcessorForeach.Invoke(new()\n    {\n        Field = \"values\",\n        Processor = convert.Apply(getIngestProcessorConvertResult =\u003e getIngestProcessorConvertResult.Json),\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            @foreach.Apply(getIngestProcessorForeachResult =\u003e getIngestProcessorForeachResult).Apply(@foreach =\u003e @foreach.Apply(getIngestProcessorForeachResult =\u003e getIngestProcessorForeachResult.Json)),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tconvert, err := elasticstack.GetIngestProcessorConvert(ctx, \u0026elasticstack.GetIngestProcessorConvertArgs{\n\t\t\tField: \"_ingest._value\",\n\t\t\tType:  \"integer\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tforeach, err := elasticstack.GetIngestProcessorForeach(ctx, \u0026elasticstack.GetIngestProcessorForeachArgs{\n\t\t\tField:     \"values\",\n\t\t\tProcessor: convert.Json,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(foreach.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorConvertArgs;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorForeachArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var convert = ElasticstackFunctions.getIngestProcessorConvert(GetIngestProcessorConvertArgs.builder()\n            .field(\"_ingest._value\")\n            .type(\"integer\")\n            .build());\n\n        final var foreach = ElasticstackFunctions.getIngestProcessorForeach(GetIngestProcessorForeachArgs.builder()\n            .field(\"values\")\n            .processor(convert.applyValue(getIngestProcessorConvertResult -\u003e getIngestProcessorConvertResult.json()))\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(foreach.applyValue(getIngestProcessorForeachResult -\u003e getIngestProcessorForeachResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${foreach.json}\nvariables:\n  convert:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorConvert\n      Arguments:\n        field: _ingest._value\n        type: integer\n  foreach:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorForeach\n      Arguments:\n        field: values\n        processor: ${convert.json}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorForeach.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "Field containing array or object values.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true`, the processor silently exits without changing the document if the `field` is `null` or missing.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "processor": {
                        "type": "string",
                        "description": "Ingest processor to run on each element.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "processor"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorForeach.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "Field containing array or object values.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true`, the processor silently exits without changing the document if the `field` is `null` or missing.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "processor": {
                        "type": "string",
                        "description": "Ingest processor to run on each element.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json",
                    "processor"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorGeoip:getIngestProcessorGeoip": {
            "description": "The geoip processor adds information about the geographical location of an IPv4 or IPv6 address.\n\nBy default, the processor uses the GeoLite2 City, GeoLite2 Country, and GeoLite2 ASN GeoIP2 databases from MaxMind, shared under the CC BY-SA 4.0 license. Elasticsearch automatically downloads updates for these databases from the Elastic GeoIP endpoint: https://geoip.elastic.co/v1/database. To get download statistics for these updates, use the GeoIP stats API.\n\nIf your cluster cant connect to the Elastic GeoIP endpoint or you want to manage your own updates, [see Manage your own GeoIP2 database updates](https://www.elastic.co/guide/en/elasticsearch/reference/current/geoip-processor.html#manage-geoip-database-updates).\n\nIf Elasticsearch cant connect to the endpoint for 30 days all updated databases will become invalid. Elasticsearch will stop enriching documents with geoip data and will add tags: [\"_geoip_expired_database\"] field instead.\n\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/geoip-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst geoip = elasticstack.getIngestProcessorGeoip({\n    field: \"ip\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [geoip.then(geoip =\u003e geoip.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ngeoip = elasticstack.get_ingest_processor_geoip(field=\"ip\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[geoip.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var geoip = Elasticstack.GetIngestProcessorGeoip.Invoke(new()\n    {\n        Field = \"ip\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            geoip.Apply(getIngestProcessorGeoipResult =\u003e getIngestProcessorGeoipResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgeoip, err := elasticstack.GetIngestProcessorGeoip(ctx, \u0026elasticstack.GetIngestProcessorGeoipArgs{\n\t\t\tField: \"ip\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(geoip.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorGeoipArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var geoip = ElasticstackFunctions.getIngestProcessorGeoip(GetIngestProcessorGeoipArgs.builder()\n            .field(\"ip\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(geoip.applyValue(getIngestProcessorGeoipResult -\u003e getIngestProcessorGeoipResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${geoip.json}\nvariables:\n  geoip:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorGeoip\n      Arguments:\n        field: ip\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorGeoip.\n",
                "properties": {
                    "databaseFile": {
                        "type": "string",
                        "description": "The database filename referring to a database the module ships with (GeoLite2-City.mmdb, GeoLite2-Country.mmdb, or GeoLite2-ASN.mmdb) or a custom database in the `ingest-geoip` config directory.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to get the ip address from for the geographical lookup.\n"
                    },
                    "firstOnly": {
                        "type": "boolean",
                        "description": "If `true` only first found geoip data will be returned, even if field contains array.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.\n"
                    },
                    "properties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Controls what properties are added to the `target_field` based on the geoip lookup.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field that will hold the geographical information looked up from the MaxMind database.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorGeoip.\n",
                "properties": {
                    "databaseFile": {
                        "type": "string",
                        "description": "The database filename referring to a database the module ships with (GeoLite2-City.mmdb, GeoLite2-Country.mmdb, or GeoLite2-ASN.mmdb) or a custom database in the `ingest-geoip` config directory.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to get the ip address from for the geographical lookup.\n"
                    },
                    "firstOnly": {
                        "type": "boolean",
                        "description": "If `true` only first found geoip data will be returned, even if field contains array.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "properties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Controls what properties are added to the `target_field` based on the geoip lookup.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field that will hold the geographical information looked up from the MaxMind database.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorGrok:getIngestProcessorGrok": {
            "description": "Extracts structured fields out of a single text field within a document. You choose which field to extract matched fields from, as well as the grok pattern you expect will match. A grok pattern is like a regular expression that supports aliased expressions that can be reused.\n\nThis processor comes packaged with many [reusable patterns](https://github.com/elastic/elasticsearch/blob/master/libs/grok/src/main/resources/patterns).\n\nIf you need help building patterns to match your logs, you will find the [Grok Debugger](https://www.elastic.co/guide/en/kibana/master/xpack-grokdebugger.html) tool quite useful! [The Grok Constructor](https://grokconstructor.appspot.com/) is also a useful tool.\n\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/grok-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst grok = elasticstack.getIngestProcessorGrok({\n    field: \"message\",\n    patterns: [\n        `%{FAVORITE_DOG:pet}`,\n        `%{FAVORITE_CAT:pet}`,\n    ],\n    patternDefinitions: {\n        FAVORITE_DOG: \"beagle\",\n        FAVORITE_CAT: \"burmese\",\n    },\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [grok.then(grok =\u003e grok.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ngrok = elasticstack.get_ingest_processor_grok(field=\"message\",\n    patterns=[\n        \"%{FAVORITE_DOG:pet}\",\n        \"%{FAVORITE_CAT:pet}\",\n    ],\n    pattern_definitions={\n        \"FAVORITE_DOG\": \"beagle\",\n        \"FAVORITE_CAT\": \"burmese\",\n    })\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[grok.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grok = Elasticstack.GetIngestProcessorGrok.Invoke(new()\n    {\n        Field = \"message\",\n        Patterns = new[]\n        {\n            \"%{FAVORITE_DOG:pet}\",\n            \"%{FAVORITE_CAT:pet}\",\n        },\n        PatternDefinitions = \n        {\n            { \"FAVORITE_DOG\", \"beagle\" },\n            { \"FAVORITE_CAT\", \"burmese\" },\n        },\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            grok.Apply(getIngestProcessorGrokResult =\u003e getIngestProcessorGrokResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgrok, err := elasticstack.GetIngestProcessorGrok(ctx, \u0026elasticstack.GetIngestProcessorGrokArgs{\n\t\t\tField: \"message\",\n\t\t\tPatterns: []string{\n\t\t\t\tfmt.Sprintf(\"%vFAVORITE_DOG:pet}\", \"%{\"),\n\t\t\t\tfmt.Sprintf(\"%vFAVORITE_CAT:pet}\", \"%{\"),\n\t\t\t},\n\t\t\tPatternDefinitions: map[string]interface{}{\n\t\t\t\t\"FAVORITE_DOG\": \"beagle\",\n\t\t\t\t\"FAVORITE_CAT\": \"burmese\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(grok.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorGrokArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var grok = ElasticstackFunctions.getIngestProcessorGrok(GetIngestProcessorGrokArgs.builder()\n            .field(\"message\")\n            .patterns(            \n                \"%{FAVORITE_DOG:pet}\",\n                \"%{FAVORITE_CAT:pet}\")\n            .patternDefinitions(Map.ofEntries(\n                Map.entry(\"FAVORITE_DOG\", \"beagle\"),\n                Map.entry(\"FAVORITE_CAT\", \"burmese\")\n            ))\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(grok.applyValue(getIngestProcessorGrokResult -\u003e getIngestProcessorGrokResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${grok.json}\nvariables:\n  grok:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorGrok\n      Arguments:\n        field: message\n        patterns:\n          - '%{FAVORITE_DOG:pet}'\n          - '%{FAVORITE_CAT:pet}'\n        patternDefinitions:\n          FAVORITE_DOG: beagle\n          FAVORITE_CAT: burmese\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorGrok.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "ecsCompatibility": {
                        "type": "string",
                        "description": "Must be disabled or v1. If v1, the processor uses patterns with Elastic Common Schema (ECS) field names. **NOTE:** Supported only starting from version of Elasticsearch **7.16.x**.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to use for grok expression parsing\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "patternDefinitions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of pattern-name and pattern tuples defining custom patterns to be used by the current processor. Patterns matching existing names will override the pre-existing definition.\n"
                    },
                    "patterns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An ordered list of grok expression to match and extract named captures with. Returns on the first expression in the list that matches.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "traceMatch": {
                        "type": "boolean",
                        "description": "when true, `_ingest._grok_match_index` will be inserted into your matched documents metadata with the index into the pattern found in `patterns` that matched.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "patterns"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorGrok.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "ecsCompatibility": {
                        "type": "string",
                        "description": "Must be disabled or v1. If v1, the processor uses patterns with Elastic Common Schema (ECS) field names. **NOTE:** Supported only starting from version of Elasticsearch **7.16.x**.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to use for grok expression parsing\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "patternDefinitions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of pattern-name and pattern tuples defining custom patterns to be used by the current processor. Patterns matching existing names will override the pre-existing definition.\n"
                    },
                    "patterns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An ordered list of grok expression to match and extract named captures with. Returns on the first expression in the list that matches.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "traceMatch": {
                        "type": "boolean",
                        "description": "when true, `_ingest._grok_match_index` will be inserted into your matched documents metadata with the index into the pattern found in `patterns` that matched.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json",
                    "patterns"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorGsub:getIngestProcessorGsub": {
            "description": "Converts a string field by applying a regular expression and a replacement. If the field is an array of string, all members of the array will be converted. If any non-string values are encountered, the processor will throw an exception.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/gsub-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst gsub = elasticstack.getIngestProcessorGsub({\n    field: \"field1\",\n    pattern: \"\\\\.\",\n    replacement: \"-\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [gsub.then(gsub =\u003e gsub.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ngsub = elasticstack.get_ingest_processor_gsub(field=\"field1\",\n    pattern=\"\\\\.\",\n    replacement=\"-\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[gsub.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var gsub = Elasticstack.GetIngestProcessorGsub.Invoke(new()\n    {\n        Field = \"field1\",\n        Pattern = \"\\\\.\",\n        Replacement = \"-\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            gsub.Apply(getIngestProcessorGsubResult =\u003e getIngestProcessorGsubResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgsub, err := elasticstack.GetIngestProcessorGsub(ctx, \u0026elasticstack.GetIngestProcessorGsubArgs{\n\t\t\tField:       \"field1\",\n\t\t\tPattern:     \"\\\\.\",\n\t\t\tReplacement: \"-\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(gsub.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorGsubArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var gsub = ElasticstackFunctions.getIngestProcessorGsub(GetIngestProcessorGsubArgs.builder()\n            .field(\"field1\")\n            .pattern(\"\\\\.\")\n            .replacement(\"-\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(gsub.applyValue(getIngestProcessorGsubResult -\u003e getIngestProcessorGsubResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${gsub.json}\nvariables:\n  gsub:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorGsub\n      Arguments:\n        field: field1\n        pattern: \\.\n        replacement: '-'\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorGsub.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to apply the replacement to.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "The pattern to be replaced.\n"
                    },
                    "replacement": {
                        "type": "string",
                        "description": "The string to replace the matching patterns with.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "pattern",
                    "replacement"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorGsub.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to apply the replacement to.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "The pattern to be replaced.\n"
                    },
                    "replacement": {
                        "type": "string",
                        "description": "The string to replace the matching patterns with.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json",
                    "pattern",
                    "replacement"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorHtmlStrip:getIngestProcessorHtmlStrip": {
            "description": "Removes HTML tags from the field. If the field is an array of strings, HTML tags will be removed from all members of the array.\n\nSee: templates/data-sources/elasticsearch_ingest_processor_html_strip.md.tmpl\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst htmlStrip = elasticstack.getIngestProcessorHtmlStrip({\n    field: \"foo\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [htmlStrip.then(htmlStrip =\u003e htmlStrip.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nhtml_strip = elasticstack.get_ingest_processor_html_strip(field=\"foo\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[html_strip.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var htmlStrip = Elasticstack.GetIngestProcessorHtmlStrip.Invoke(new()\n    {\n        Field = \"foo\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            htmlStrip.Apply(getIngestProcessorHtmlStripResult =\u003e getIngestProcessorHtmlStripResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\thtmlStrip, err := elasticstack.GetIngestProcessorHtmlStrip(ctx, \u0026elasticstack.GetIngestProcessorHtmlStripArgs{\n\t\t\tField: \"foo\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(htmlStrip.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorHtmlStripArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var htmlStrip = ElasticstackFunctions.getIngestProcessorHtmlStrip(GetIngestProcessorHtmlStripArgs.builder()\n            .field(\"foo\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(htmlStrip.applyValue(getIngestProcessorHtmlStripResult -\u003e getIngestProcessorHtmlStripResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${htmlStrip.json}\nvariables:\n  htmlStrip:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorHtmlStrip\n      Arguments:\n        field: foo\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorHtmlStrip.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to apply the replacement to.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorHtmlStrip.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to apply the replacement to.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorJoin:getIngestProcessorJoin": {
            "description": "Joins each element of an array into a single string using a separator character between each element. Throws an error when the field is not an array.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/join-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst join = elasticstack.getIngestProcessorJoin({\n    field: \"joined_array_field\",\n    separator: \"-\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [join.then(join =\u003e join.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\njoin = elasticstack.get_ingest_processor_join(field=\"joined_array_field\",\n    separator=\"-\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[join.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @join = Elasticstack.GetIngestProcessorJoin.Invoke(new()\n    {\n        Field = \"joined_array_field\",\n        Separator = \"-\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            @join.Apply(getIngestProcessorJoinResult =\u003e getIngestProcessorJoinResult).Apply(@join =\u003e @join.Apply(getIngestProcessorJoinResult =\u003e getIngestProcessorJoinResult.Json)),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tjoin, err := elasticstack.GetIngestProcessorJoin(ctx, \u0026elasticstack.GetIngestProcessorJoinArgs{\n\t\t\tField:     \"joined_array_field\",\n\t\t\tSeparator: \"-\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(join.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorJoinArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var join = ElasticstackFunctions.getIngestProcessorJoin(GetIngestProcessorJoinArgs.builder()\n            .field(\"joined_array_field\")\n            .separator(\"-\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(join.applyValue(getIngestProcessorJoinResult -\u003e getIngestProcessorJoinResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${join.json}\nvariables:\n  join:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorJoin\n      Arguments:\n        field: joined_array_field\n        separator: '-'\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorJoin.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "Field containing array values to join.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "separator": {
                        "type": "string",
                        "description": "The separator character.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "separator"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorJoin.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "Field containing array values to join.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "separator": {
                        "type": "string",
                        "description": "The separator character.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json",
                    "separator"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorJson:getIngestProcessorJson": {
            "description": "Converts a JSON string into a structured JSON object.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/json-processor.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst jsonProc = elasticstack.getIngestProcessorJson({\n    field: \"string_source\",\n    targetField: \"json_target\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [jsonProc.then(jsonProc =\u003e jsonProc.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\njson_proc = elasticstack.get_ingest_processor_json(field=\"string_source\",\n    target_field=\"json_target\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[json_proc.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var jsonProc = Elasticstack.GetIngestProcessorJson.Invoke(new()\n    {\n        Field = \"string_source\",\n        TargetField = \"json_target\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            jsonProc.Apply(getIngestProcessorJsonResult =\u003e getIngestProcessorJsonResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tjsonProc, err := elasticstack.GetIngestProcessorJson(ctx, \u0026elasticstack.GetIngestProcessorJsonArgs{\n\t\t\tField:       \"string_source\",\n\t\t\tTargetField: pulumi.StringRef(\"json_target\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(jsonProc.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorJsonArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var jsonProc = ElasticstackFunctions.getIngestProcessorJson(GetIngestProcessorJsonArgs.builder()\n            .field(\"string_source\")\n            .targetField(\"json_target\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(jsonProc.applyValue(getIngestProcessorJsonResult -\u003e getIngestProcessorJsonResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${jsonProc.json}\nvariables:\n  jsonProc:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorJson\n      Arguments:\n        field: string_source\n        targetField: json_target\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorJson.\n",
                "properties": {
                    "addToRoot": {
                        "type": "boolean",
                        "description": "Flag that forces the parsed JSON to be added at the top level of the document. `target_field` must not be set when this option is chosen.\n"
                    },
                    "addToRootConflictStrategy": {
                        "type": "string",
                        "description": "When set to `replace`, root fields that conflict with fields from the parsed JSON will be overridden. When set to `merge`, conflicting fields will be merged. Only applicable if `add_to_root` is set to `true`.\n"
                    },
                    "allowDuplicateKeys": {
                        "type": "boolean",
                        "description": "When set to `true`, the JSON parser will not fail if the JSON contains duplicate keys. Instead, the last encountered value for any duplicate key wins.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to be parsed.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field that the converted structured object will be written into. Any existing content in this field will be overwritten.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorJson.\n",
                "properties": {
                    "addToRoot": {
                        "type": "boolean",
                        "description": "Flag that forces the parsed JSON to be added at the top level of the document. `target_field` must not be set when this option is chosen.\n"
                    },
                    "addToRootConflictStrategy": {
                        "type": "string",
                        "description": "When set to `replace`, root fields that conflict with fields from the parsed JSON will be overridden. When set to `merge`, conflicting fields will be merged. Only applicable if `add_to_root` is set to `true`.\n"
                    },
                    "allowDuplicateKeys": {
                        "type": "boolean",
                        "description": "When set to `true`, the JSON parser will not fail if the JSON contains duplicate keys. Instead, the last encountered value for any duplicate key wins.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to be parsed.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field that the converted structured object will be written into. Any existing content in this field will be overwritten.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorKv:getIngestProcessorKv": {
            "description": "This processor helps automatically parse messages (or specific event fields) which are of the `foo=bar` variety.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/kv-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst kv = elasticstack.getIngestProcessorKv({\n    field: \"message\",\n    fieldSplit: \" \",\n    valueSplit: \"=\",\n    excludeKeys: [\"tags\"],\n    prefix: \"setting_\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [kv.then(kv =\u003e kv.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nkv = elasticstack.get_ingest_processor_kv(field=\"message\",\n    field_split=\" \",\n    value_split=\"=\",\n    exclude_keys=[\"tags\"],\n    prefix=\"setting_\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[kv.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kv = Elasticstack.GetIngestProcessorKv.Invoke(new()\n    {\n        Field = \"message\",\n        FieldSplit = \" \",\n        ValueSplit = \"=\",\n        ExcludeKeys = new[]\n        {\n            \"tags\",\n        },\n        Prefix = \"setting_\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            kv.Apply(getIngestProcessorKvResult =\u003e getIngestProcessorKvResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkv, err := elasticstack.GetIngestProcessorKv(ctx, \u0026elasticstack.GetIngestProcessorKvArgs{\n\t\t\tField:      \"message\",\n\t\t\tFieldSplit: \" \",\n\t\t\tValueSplit: \"=\",\n\t\t\tExcludeKeys: []string{\n\t\t\t\t\"tags\",\n\t\t\t},\n\t\t\tPrefix: pulumi.StringRef(\"setting_\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(kv.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorKvArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var kv = ElasticstackFunctions.getIngestProcessorKv(GetIngestProcessorKvArgs.builder()\n            .field(\"message\")\n            .fieldSplit(\" \")\n            .valueSplit(\"=\")\n            .excludeKeys(\"tags\")\n            .prefix(\"setting_\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(kv.applyValue(getIngestProcessorKvResult -\u003e getIngestProcessorKvResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${kv.json}\nvariables:\n  kv:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorKv\n      Arguments:\n        field: message\n        fieldSplit: ' '\n        valueSplit: =\n        excludeKeys:\n          - tags\n        prefix: setting_\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorKv.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "excludeKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of keys to exclude from document\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to be parsed. Supports template snippets.\n"
                    },
                    "fieldSplit": {
                        "type": "string",
                        "description": "Regex pattern to use for splitting key-value pairs.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "includeKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of keys to filter and insert into document. Defaults to including all keys\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "prefix": {
                        "type": "string",
                        "description": "Prefix to be added to extracted keys.\n"
                    },
                    "stripBrackets": {
                        "type": "boolean",
                        "description": "If `true` strip brackets `()`, `\u003c\u003e`, `[]` as well as quotes `'` and `\"` from extracted values.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to insert the extracted keys into. Defaults to the root of the document.\n"
                    },
                    "trimKey": {
                        "type": "string",
                        "description": "String of characters to trim from extracted keys.\n"
                    },
                    "trimValue": {
                        "type": "string",
                        "description": "String of characters to trim from extracted values.\n"
                    },
                    "valueSplit": {
                        "type": "string",
                        "description": "Regex pattern to use for splitting the key from the value within a key-value pair.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "fieldSplit",
                    "valueSplit"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorKv.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "excludeKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of keys to exclude from document\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to be parsed. Supports template snippets.\n"
                    },
                    "fieldSplit": {
                        "type": "string",
                        "description": "Regex pattern to use for splitting key-value pairs.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "includeKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of keys to filter and insert into document. Defaults to including all keys\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "prefix": {
                        "type": "string",
                        "description": "Prefix to be added to extracted keys.\n"
                    },
                    "stripBrackets": {
                        "type": "boolean",
                        "description": "If `true` strip brackets `()`, `\u003c\u003e`, `[]` as well as quotes `'` and `\"` from extracted values.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to insert the extracted keys into. Defaults to the root of the document.\n"
                    },
                    "trimKey": {
                        "type": "string",
                        "description": "String of characters to trim from extracted keys.\n"
                    },
                    "trimValue": {
                        "type": "string",
                        "description": "String of characters to trim from extracted values.\n"
                    },
                    "valueSplit": {
                        "type": "string",
                        "description": "Regex pattern to use for splitting the key from the value within a key-value pair.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "fieldSplit",
                    "id",
                    "json",
                    "valueSplit"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorLowercase:getIngestProcessorLowercase": {
            "description": "Converts a string to its lowercase equivalent. If the field is an array of strings, all members of the array will be converted.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/lowercase-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst lowercase = elasticstack.getIngestProcessorLowercase({\n    field: \"foo\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [lowercase.then(lowercase =\u003e lowercase.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nlowercase = elasticstack.get_ingest_processor_lowercase(field=\"foo\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[lowercase.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var lowercase = Elasticstack.GetIngestProcessorLowercase.Invoke(new()\n    {\n        Field = \"foo\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            lowercase.Apply(getIngestProcessorLowercaseResult =\u003e getIngestProcessorLowercaseResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tlowercase, err := elasticstack.GetIngestProcessorLowercase(ctx, \u0026elasticstack.GetIngestProcessorLowercaseArgs{\n\t\t\tField: \"foo\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(lowercase.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorLowercaseArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var lowercase = ElasticstackFunctions.getIngestProcessorLowercase(GetIngestProcessorLowercaseArgs.builder()\n            .field(\"foo\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(lowercase.applyValue(getIngestProcessorLowercaseResult -\u003e getIngestProcessorLowercaseResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${lowercase.json}\nvariables:\n  lowercase:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorLowercase\n      Arguments:\n        field: foo\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorLowercase.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to make lowercase.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorLowercase.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to make lowercase.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorNetworkDirection:getIngestProcessorNetworkDirection": {
            "description": "Calculates the network direction given a source IP address, destination IP address, and a list of internal networks.\n\nThe network direction processor reads IP addresses from Elastic Common Schema (ECS) fields by default. If you use the ECS, only the `internal_networks` option must be specified.\n\n\nOne of either `internal_networks` or `internal_networks_field` must be specified. If `internal_networks_field` is specified, it follows the behavior specified by `ignore_missing`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst networkDirection = elasticstack.getIngestProcessorNetworkDirection({\n    internalNetworks: [\"private\"],\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [networkDirection.then(networkDirection =\u003e networkDirection.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nnetwork_direction = elasticstack.get_ingest_processor_network_direction(internal_networks=[\"private\"])\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[network_direction.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var networkDirection = Elasticstack.GetIngestProcessorNetworkDirection.Invoke(new()\n    {\n        InternalNetworks = new[]\n        {\n            \"private\",\n        },\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            networkDirection.Apply(getIngestProcessorNetworkDirectionResult =\u003e getIngestProcessorNetworkDirectionResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnetworkDirection, err := elasticstack.GetIngestProcessorNetworkDirection(ctx, \u0026elasticstack.GetIngestProcessorNetworkDirectionArgs{\n\t\t\tInternalNetworks: []string{\n\t\t\t\t\"private\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(networkDirection.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorNetworkDirectionArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var networkDirection = ElasticstackFunctions.getIngestProcessorNetworkDirection(GetIngestProcessorNetworkDirectionArgs.builder()\n            .internalNetworks(\"private\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(networkDirection.applyValue(getIngestProcessorNetworkDirectionResult -\u003e getIngestProcessorNetworkDirectionResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${networkDirection.json}\nvariables:\n  networkDirection:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorNetworkDirection\n      Arguments:\n        internalNetworks:\n          - private\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorNetworkDirection.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "destinationIp": {
                        "type": "string",
                        "description": "Field containing the destination IP address.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "internalNetworks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of internal networks.\n"
                    },
                    "internalNetworksField": {
                        "type": "string",
                        "description": "A field on the given document to read the internal_networks configuration from.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "sourceIp": {
                        "type": "string",
                        "description": "Field containing the source IP address.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Output field for the network direction.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorNetworkDirection.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "destinationIp": {
                        "type": "string",
                        "description": "Field containing the destination IP address.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "internalNetworks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of internal networks.\n"
                    },
                    "internalNetworksField": {
                        "type": "string",
                        "description": "A field on the given document to read the internal_networks configuration from.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "sourceIp": {
                        "type": "string",
                        "description": "Field containing the source IP address.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Output field for the network direction.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorPipeline:getIngestProcessorPipeline": {
            "description": "Executes another pipeline.\n\nThe name of the current pipeline can be accessed from the `_ingest.pipeline` ingest metadata key.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/pipeline-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst appendTags = elasticstack.getIngestProcessorAppend({\n    field: \"tags\",\n    values: [\n        \"production\",\n        \"{{{app}}}\",\n        \"{{{owner}}}\",\n    ],\n});\nconst pipelineA = new elasticstack.IngestPipeline(\"pipelineA\", {processors: [appendTags.then(appendTags =\u003e appendTags.json)]});\nconst fingerprint = elasticstack.getIngestProcessorFingerprint({\n    fields: [\"owner\"],\n});\nconst pipeline = elasticstack.getIngestProcessorPipelineOutput({\n    name: pipelineA.name,\n});\nconst pipelineB = new elasticstack.IngestPipeline(\"pipelineB\", {processors: [\n    pipeline.apply(pipeline =\u003e pipeline.json),\n    fingerprint.then(fingerprint =\u003e fingerprint.json),\n]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nappend_tags = elasticstack.get_ingest_processor_append(field=\"tags\",\n    values=[\n        \"production\",\n        \"{{{app}}}\",\n        \"{{{owner}}}\",\n    ])\npipeline_a = elasticstack.IngestPipeline(\"pipelineA\", processors=[append_tags.json])\nfingerprint = elasticstack.get_ingest_processor_fingerprint(fields=[\"owner\"])\npipeline = elasticstack.get_ingest_processor_pipeline_output(name=pipeline_a.name)\npipeline_b = elasticstack.IngestPipeline(\"pipelineB\", processors=[\n    pipeline.json,\n    fingerprint.json,\n])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var appendTags = Elasticstack.GetIngestProcessorAppend.Invoke(new()\n    {\n        Field = \"tags\",\n        Values = new[]\n        {\n            \"production\",\n            \"{{{app}}}\",\n            \"{{{owner}}}\",\n        },\n    });\n\n    var pipelineA = new Elasticstack.IngestPipeline(\"pipelineA\", new()\n    {\n        Processors = new[]\n        {\n            appendTags.Apply(getIngestProcessorAppendResult =\u003e getIngestProcessorAppendResult.Json),\n        },\n    });\n\n    var fingerprint = Elasticstack.GetIngestProcessorFingerprint.Invoke(new()\n    {\n        Fields = new[]\n        {\n            \"owner\",\n        },\n    });\n\n    var pipeline = Elasticstack.GetIngestProcessorPipeline.Invoke(new()\n    {\n        Name = pipelineA.Name,\n    });\n\n    var pipelineB = new Elasticstack.IngestPipeline(\"pipelineB\", new()\n    {\n        Processors = new[]\n        {\n            pipeline.Apply(getIngestProcessorPipelineResult =\u003e getIngestProcessorPipelineResult.Json),\n            fingerprint.Apply(getIngestProcessorFingerprintResult =\u003e getIngestProcessorFingerprintResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tappendTags, err := elasticstack.GetIngestProcessorAppend(ctx, \u0026elasticstack.GetIngestProcessorAppendArgs{\n\t\t\tField: \"tags\",\n\t\t\tValues: []string{\n\t\t\t\t\"production\",\n\t\t\t\t\"{{{app}}}\",\n\t\t\t\t\"{{{owner}}}\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpipelineA, err := elasticstack.NewIngestPipeline(ctx, \"pipelineA\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(appendTags.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfingerprint, err := elasticstack.GetIngestProcessorFingerprint(ctx, \u0026elasticstack.GetIngestProcessorFingerprintArgs{\n\t\t\tFields: []string{\n\t\t\t\t\"owner\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpipeline := elasticstack.GetIngestProcessorPipelineOutput(ctx, elasticstack.GetIngestProcessorPipelineOutputArgs{\n\t\t\tName: pipelineA.Name,\n\t\t}, nil)\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"pipelineB\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\tpipeline.ApplyT(func(pipeline elasticstack.GetIngestProcessorPipelineResult) (*string, error) {\n\t\t\t\t\treturn \u0026pipeline.Json, nil\n\t\t\t\t}).(pulumi.StringPtrOutput),\n\t\t\t\t*pulumi.String(fingerprint.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorAppendArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorFingerprintArgs;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var appendTags = ElasticstackFunctions.getIngestProcessorAppend(GetIngestProcessorAppendArgs.builder()\n            .field(\"tags\")\n            .values(            \n                \"production\",\n                \"{{{app}}}\",\n                \"{{{owner}}}\")\n            .build());\n\n        var pipelineA = new IngestPipeline(\"pipelineA\", IngestPipelineArgs.builder()        \n            .processors(appendTags.applyValue(getIngestProcessorAppendResult -\u003e getIngestProcessorAppendResult.json()))\n            .build());\n\n        final var fingerprint = ElasticstackFunctions.getIngestProcessorFingerprint(GetIngestProcessorFingerprintArgs.builder()\n            .fields(\"owner\")\n            .build());\n\n        final var pipeline = ElasticstackFunctions.getIngestProcessorPipeline(GetIngestProcessorPipelineArgs.builder()\n            .name(pipelineA.name())\n            .build());\n\n        var pipelineB = new IngestPipeline(\"pipelineB\", IngestPipelineArgs.builder()        \n            .processors(            \n                pipeline.applyValue(getIngestProcessorPipelineResult -\u003e getIngestProcessorPipelineResult).applyValue(pipeline -\u003e pipeline.applyValue(getIngestProcessorPipelineResult -\u003e getIngestProcessorPipelineResult.json())),\n                fingerprint.applyValue(getIngestProcessorFingerprintResult -\u003e getIngestProcessorFingerprintResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  pipelineA:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${appendTags.json}\n  pipelineB:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${pipeline.json}\n        - ${fingerprint.json}\nvariables:\n  appendTags:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorAppend\n      Arguments:\n        field: tags\n        values:\n          - production\n          - '{{{app}}}'\n          - '{{{owner}}}'\n  fingerprint:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorFingerprint\n      Arguments:\n        fields:\n          - owner\n  pipeline:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorPipeline\n      Arguments:\n        name: ${pipelineA.name}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorPipeline.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the pipeline to execute.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorPipeline.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the pipeline to execute.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id",
                    "json",
                    "name"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorRegisteredDomain:getIngestProcessorRegisteredDomain": {
            "description": "Extracts the registered domain (also known as the effective top-level domain or eTLD), sub-domain, and top-level domain from a fully qualified domain name (FQDN). Uses the registered domains defined in the Mozilla Public Suffix List.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/registered-domain-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst domain = elasticstack.getIngestProcessorRegisteredDomain({\n    field: \"fqdn\",\n    targetField: \"url\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [domain.then(domain =\u003e domain.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ndomain = elasticstack.get_ingest_processor_registered_domain(field=\"fqdn\",\n    target_field=\"url\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[domain.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var domain = Elasticstack.GetIngestProcessorRegisteredDomain.Invoke(new()\n    {\n        Field = \"fqdn\",\n        TargetField = \"url\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            domain.Apply(getIngestProcessorRegisteredDomainResult =\u003e getIngestProcessorRegisteredDomainResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdomain, err := elasticstack.GetIngestProcessorRegisteredDomain(ctx, \u0026elasticstack.GetIngestProcessorRegisteredDomainArgs{\n\t\t\tField:       \"fqdn\",\n\t\t\tTargetField: pulumi.StringRef(\"url\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(domain.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorRegisteredDomainArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var domain = ElasticstackFunctions.getIngestProcessorRegisteredDomain(GetIngestProcessorRegisteredDomainArgs.builder()\n            .field(\"fqdn\")\n            .targetField(\"url\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(domain.applyValue(getIngestProcessorRegisteredDomainResult -\u003e getIngestProcessorRegisteredDomainResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${domain.json}\nvariables:\n  domain:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorRegisteredDomain\n      Arguments:\n        field: fqdn\n        targetField: url\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorRegisteredDomain.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "Field containing the source FQDN.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Object field containing extracted domain components. If an `\u003cempty string\u003e`, the processor adds components to the documents root.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorRegisteredDomain.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "Field containing the source FQDN.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Object field containing extracted domain components. If an `\u003cempty string\u003e`, the processor adds components to the documents root.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorRemove:getIngestProcessorRemove": {
            "description": "Removes existing fields. If one field doesnt exist, an exception will be thrown.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/remove-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst remove = elasticstack.getIngestProcessorRemove({\n    fields: [\n        \"user_agent\",\n        \"url\",\n    ],\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [remove.then(remove =\u003e remove.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nremove = elasticstack.get_ingest_processor_remove(fields=[\n    \"user_agent\",\n    \"url\",\n])\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[remove.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @remove = Elasticstack.GetIngestProcessorRemove.Invoke(new()\n    {\n        Fields = new[]\n        {\n            \"user_agent\",\n            \"url\",\n        },\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            @remove.Apply(getIngestProcessorRemoveResult =\u003e getIngestProcessorRemoveResult).Apply(@remove =\u003e @remove.Apply(getIngestProcessorRemoveResult =\u003e getIngestProcessorRemoveResult.Json)),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tremove, err := elasticstack.GetIngestProcessorRemove(ctx, \u0026elasticstack.GetIngestProcessorRemoveArgs{\n\t\t\tFields: []string{\n\t\t\t\t\"user_agent\",\n\t\t\t\t\"url\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(remove.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorRemoveArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var remove = ElasticstackFunctions.getIngestProcessorRemove(GetIngestProcessorRemoveArgs.builder()\n            .fields(            \n                \"user_agent\",\n                \"url\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(remove.applyValue(getIngestProcessorRemoveResult -\u003e getIngestProcessorRemoveResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${remove.json}\nvariables:\n  remove:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorRemove\n      Arguments:\n        fields:\n          - user_agent\n          - url\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorRemove.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "fields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Fields to be removed.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "fields"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorRemove.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "fields": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Fields to be removed.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "fields",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorRename:getIngestProcessorRename": {
            "description": "Renames an existing field. If the field doesnt exist or the new name is already used, an exception will be thrown.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/rename-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst rename = elasticstack.getIngestProcessorRename({\n    field: \"provider\",\n    targetField: \"cloud.provider\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [rename.then(rename =\u003e rename.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nrename = elasticstack.get_ingest_processor_rename(field=\"provider\",\n    target_field=\"cloud.provider\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[rename.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rename = Elasticstack.GetIngestProcessorRename.Invoke(new()\n    {\n        Field = \"provider\",\n        TargetField = \"cloud.provider\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            rename.Apply(getIngestProcessorRenameResult =\u003e getIngestProcessorRenameResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trename, err := elasticstack.GetIngestProcessorRename(ctx, \u0026elasticstack.GetIngestProcessorRenameArgs{\n\t\t\tField:       \"provider\",\n\t\t\tTargetField: \"cloud.provider\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(rename.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorRenameArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var rename = ElasticstackFunctions.getIngestProcessorRename(GetIngestProcessorRenameArgs.builder()\n            .field(\"provider\")\n            .targetField(\"cloud.provider\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(rename.applyValue(getIngestProcessorRenameResult -\u003e getIngestProcessorRenameResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${rename.json}\nvariables:\n  rename:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorRename\n      Arguments:\n        field: provider\n        targetField: cloud.provider\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorRename.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to be renamed.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The new name of the field.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "targetField"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorRename.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to be renamed.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The new name of the field.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json",
                    "targetField"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorScript:getIngestProcessorScript": {
            "description": "Runs an inline or stored script on incoming documents. The script runs in the ingest context.\n\nThe script processor uses the script cache to avoid recompiling the script for each incoming document. To improve performance, ensure the script cache is properly sized before using a script processor in production.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/script-processor.html\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorScript.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "lang": {
                        "type": "string",
                        "description": "Script language.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "params": {
                        "type": "string",
                        "description": "Object containing parameters for the script.\n"
                    },
                    "scriptId": {
                        "type": "string",
                        "description": "ID of a stored script. If no `source` is specified, this parameter is required.\n"
                    },
                    "source": {
                        "type": "string",
                        "description": "Inline script. If no id is specified, this parameter is required.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorScript.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "lang": {
                        "type": "string",
                        "description": "Script language.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "params": {
                        "type": "string",
                        "description": "Object containing parameters for the script.\n"
                    },
                    "scriptId": {
                        "type": "string",
                        "description": "ID of a stored script. If no `source` is specified, this parameter is required.\n"
                    },
                    "source": {
                        "type": "string",
                        "description": "Inline script. If no id is specified, this parameter is required.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorSet:getIngestProcessorSet": {
            "description": "Sets one field and associates it with the specified value. If the field already exists, its value will be replaced with the provided one.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/set-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst set = elasticstack.getIngestProcessorSet({\n    field: \"count\",\n    value: \"1\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [set.then(set =\u003e set.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nset = elasticstack.get_ingest_processor_set(field=\"count\",\n    value=\"1\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[set.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @set = Elasticstack.GetIngestProcessorSet.Invoke(new()\n    {\n        Field = \"count\",\n        Value = \"1\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            @set.Apply(getIngestProcessorSetResult =\u003e getIngestProcessorSetResult).Apply(@set =\u003e @set.Apply(getIngestProcessorSetResult =\u003e getIngestProcessorSetResult.Json)),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tset, err := elasticstack.GetIngestProcessorSet(ctx, \u0026elasticstack.GetIngestProcessorSetArgs{\n\t\t\tField: \"count\",\n\t\t\tValue: pulumi.StringRef(\"1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(set.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorSetArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var set = ElasticstackFunctions.getIngestProcessorSet(GetIngestProcessorSetArgs.builder()\n            .field(\"count\")\n            .value(1)\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(set.applyValue(getIngestProcessorSetResult -\u003e getIngestProcessorSetResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${set.json}\nvariables:\n  set:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorSet\n      Arguments:\n        field: count\n        value: 1\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorSet.\n",
                "properties": {
                    "copyFrom": {
                        "type": "string",
                        "description": "The origin field which will be copied to `field`, cannot set `value` simultaneously.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to insert, upsert, or update.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreEmptyValue": {
                        "type": "boolean",
                        "description": "If `true` and `value` is a template snippet that evaluates to `null` or the empty string, the processor quietly exits without modifying the document\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "mediaType": {
                        "type": "string",
                        "description": "The media type for encoding value.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "override": {
                        "type": "boolean",
                        "description": "If processor will update fields with pre-existing non-null-valued field.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value to be set for the field. Supports template snippets. May specify only one of `value` or `copy_from`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorSet.\n",
                "properties": {
                    "copyFrom": {
                        "type": "string",
                        "description": "The origin field which will be copied to `field`, cannot set `value` simultaneously.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to insert, upsert, or update.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreEmptyValue": {
                        "type": "boolean",
                        "description": "If `true` and `value` is a template snippet that evaluates to `null` or the empty string, the processor quietly exits without modifying the document\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "mediaType": {
                        "type": "string",
                        "description": "The media type for encoding value.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "override": {
                        "type": "boolean",
                        "description": "If processor will update fields with pre-existing non-null-valued field.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value to be set for the field. Supports template snippets. May specify only one of `value` or `copy_from`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorSetSecurityUser:getIngestProcessorSetSecurityUser": {
            "description": "Sets user-related details (such as `username`, `roles`, `email`, `full_name`, `metadata`, `api_key`, `realm` and `authentication_typ`e) from the current authenticated user to the current document by pre-processing the ingest. The `api_key` property exists only if the user authenticates with an API key. It is an object containing the id, name and metadata (if it exists and is non-empty) fields of the API key. The realm property is also an object with two fields, name and type. When using API key authentication, the realm property refers to the realm from which the API key is created. The `authentication_type property` is a string that can take value from `REALM`, `API_KEY`, `TOKEN` and `ANONYMOUS`.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest-node-set-security-user-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst user = elasticstack.getIngestProcessorSetSecurityUser({\n    field: \"user\",\n    properties: [\n        \"username\",\n        \"realm\",\n    ],\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [user.then(user =\u003e user.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nuser = elasticstack.get_ingest_processor_set_security_user(field=\"user\",\n    properties=[\n        \"username\",\n        \"realm\",\n    ])\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[user.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var user = Elasticstack.GetIngestProcessorSetSecurityUser.Invoke(new()\n    {\n        Field = \"user\",\n        Properties = new[]\n        {\n            \"username\",\n            \"realm\",\n        },\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            user.Apply(getIngestProcessorSetSecurityUserResult =\u003e getIngestProcessorSetSecurityUserResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuser, err := elasticstack.GetIngestProcessorSetSecurityUser(ctx, \u0026elasticstack.GetIngestProcessorSetSecurityUserArgs{\n\t\t\tField: \"user\",\n\t\t\tProperties: []string{\n\t\t\t\t\"username\",\n\t\t\t\t\"realm\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(user.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorSetSecurityUserArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var user = ElasticstackFunctions.getIngestProcessorSetSecurityUser(GetIngestProcessorSetSecurityUserArgs.builder()\n            .field(\"user\")\n            .properties(            \n                \"username\",\n                \"realm\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(user.applyValue(getIngestProcessorSetSecurityUserResult -\u003e getIngestProcessorSetSecurityUserResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${user.json}\nvariables:\n  user:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorSetSecurityUser\n      Arguments:\n        field: user\n        properties:\n          - username\n          - realm\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorSetSecurityUser.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to store the user information into.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "properties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Controls what user related properties are added to the `field`.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorSetSecurityUser.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to store the user information into.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "properties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Controls what user related properties are added to the `field`.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorSort:getIngestProcessorSort": {
            "description": "Sorts the elements of an array ascending or descending. Homogeneous arrays of numbers will be sorted numerically, while arrays of strings or heterogeneous arrays of strings + numbers will be sorted lexicographically. Throws an error when the field is not an array.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst sort = elasticstack.getIngestProcessorSort({\n    field: \"array_field_to_sort\",\n    order: \"desc\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [sort.then(sort =\u003e sort.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nsort = elasticstack.get_ingest_processor_sort(field=\"array_field_to_sort\",\n    order=\"desc\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[sort.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sort = Elasticstack.GetIngestProcessorSort.Invoke(new()\n    {\n        Field = \"array_field_to_sort\",\n        Order = \"desc\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            sort.Apply(getIngestProcessorSortResult =\u003e getIngestProcessorSortResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsort, err := elasticstack.GetIngestProcessorSort(ctx, \u0026elasticstack.GetIngestProcessorSortArgs{\n\t\t\tField: \"array_field_to_sort\",\n\t\t\tOrder: pulumi.StringRef(\"desc\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(sort.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorSortArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var sort = ElasticstackFunctions.getIngestProcessorSort(GetIngestProcessorSortArgs.builder()\n            .field(\"array_field_to_sort\")\n            .order(\"desc\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(sort.applyValue(getIngestProcessorSortResult -\u003e getIngestProcessorSortResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${sort.json}\nvariables:\n  sort:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorSort\n      Arguments:\n        field: array_field_to_sort\n        order: desc\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorSort.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to be sorted\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "order": {
                        "type": "string",
                        "description": "The sort order to use. Accepts `asc` or `desc`.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the sorted value to, by default `field` is updated in-place\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorSort.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to be sorted\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "order": {
                        "type": "string",
                        "description": "The sort order to use. Accepts `asc` or `desc`.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the sorted value to, by default `field` is updated in-place\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorSplit:getIngestProcessorSplit": {
            "description": "Splits a field into an array using a separator character. Only works on string fields.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/split-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst split = elasticstack.getIngestProcessorSplit({\n    field: \"my_field\",\n    separator: \"\\\\s+\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [split.then(split =\u003e split.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nsplit = elasticstack.get_ingest_processor_split(field=\"my_field\",\n    separator=\"\\\\s+\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[split.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var split = Elasticstack.GetIngestProcessorSplit.Invoke(new()\n    {\n        Field = \"my_field\",\n        Separator = \"\\\\s+\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            split.Apply(getIngestProcessorSplitResult =\u003e getIngestProcessorSplitResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsplit, err := elasticstack.GetIngestProcessorSplit(ctx, \u0026elasticstack.GetIngestProcessorSplitArgs{\n\t\t\tField:     \"my_field\",\n\t\t\tSeparator: \"\\\\s+\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(split.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorSplitArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var split = ElasticstackFunctions.getIngestProcessorSplit(GetIngestProcessorSplitArgs.builder()\n            .field(\"my_field\")\n            .separator(\"\\\\s+\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(split.applyValue(getIngestProcessorSplitResult -\u003e getIngestProcessorSplitResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${split.json}\nvariables:\n  split:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorSplit\n      Arguments:\n        field: my_field\n        separator: \\s+\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorSplit.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to split\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "preserveTrailing": {
                        "type": "boolean",
                        "description": "Preserves empty trailing fields, if any.\n"
                    },
                    "separator": {
                        "type": "string",
                        "description": "A regex which matches the separator, eg `,` or `\\s+`\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "separator"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorSplit.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to split\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "preserveTrailing": {
                        "type": "boolean",
                        "description": "Preserves empty trailing fields, if any.\n"
                    },
                    "separator": {
                        "type": "string",
                        "description": "A regex which matches the separator, eg `,` or `\\s+`\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json",
                    "separator"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorTrim:getIngestProcessorTrim": {
            "description": "Trims whitespace from field. If the field is an array of strings, all members of the array will be trimmed.\n\n**NOTE:** This only works on leading and trailing whitespace.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/trim-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst trim = elasticstack.getIngestProcessorTrim({\n    field: \"foo\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [trim.then(trim =\u003e trim.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\ntrim = elasticstack.get_ingest_processor_trim(field=\"foo\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[trim.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var trim = Elasticstack.GetIngestProcessorTrim.Invoke(new()\n    {\n        Field = \"foo\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            trim.Apply(getIngestProcessorTrimResult =\u003e getIngestProcessorTrimResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttrim, err := elasticstack.GetIngestProcessorTrim(ctx, \u0026elasticstack.GetIngestProcessorTrimArgs{\n\t\t\tField: \"foo\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(trim.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorTrimArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var trim = ElasticstackFunctions.getIngestProcessorTrim(GetIngestProcessorTrimArgs.builder()\n            .field(\"foo\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(trim.applyValue(getIngestProcessorTrimResult -\u003e getIngestProcessorTrimResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${trim.json}\nvariables:\n  trim:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorTrim\n      Arguments:\n        field: foo\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorTrim.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The string-valued field to trim whitespace from.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the trimmed value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorTrim.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The string-valued field to trim whitespace from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the trimmed value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorUppercase:getIngestProcessorUppercase": {
            "description": "Converts a string to its uppercase equivalent. If the field is an array of strings, all members of the array will be converted.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/uppercase-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst uppercase = elasticstack.getIngestProcessorUppercase({\n    field: \"foo\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [uppercase.then(uppercase =\u003e uppercase.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nuppercase = elasticstack.get_ingest_processor_uppercase(field=\"foo\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[uppercase.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var uppercase = Elasticstack.GetIngestProcessorUppercase.Invoke(new()\n    {\n        Field = \"foo\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            uppercase.Apply(getIngestProcessorUppercaseResult =\u003e getIngestProcessorUppercaseResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuppercase, err := elasticstack.GetIngestProcessorUppercase(ctx, \u0026elasticstack.GetIngestProcessorUppercaseArgs{\n\t\t\tField: \"foo\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(uppercase.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorUppercaseArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var uppercase = ElasticstackFunctions.getIngestProcessorUppercase(GetIngestProcessorUppercaseArgs.builder()\n            .field(\"foo\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(uppercase.applyValue(getIngestProcessorUppercaseResult -\u003e getIngestProcessorUppercaseResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${uppercase.json}\nvariables:\n  uppercase:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorUppercase\n      Arguments:\n        field: foo\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorUppercase.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to make uppercase.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorUppercase.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to make uppercase.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorUriParts:getIngestProcessorUriParts": {
            "description": "Parses a Uniform Resource Identifier (URI) string and extracts its components as an object. This URI object includes properties for the URIs domain, path, fragment, port, query, scheme, user info, username, and password.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/uri-parts-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst parts = elasticstack.getIngestProcessorUriParts({\n    field: \"input_field\",\n    targetField: \"url\",\n    keepOriginal: true,\n    removeIfSuccessful: false,\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [parts.then(parts =\u003e parts.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nparts = elasticstack.get_ingest_processor_uri_parts(field=\"input_field\",\n    target_field=\"url\",\n    keep_original=True,\n    remove_if_successful=False)\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[parts.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var parts = Elasticstack.GetIngestProcessorUriParts.Invoke(new()\n    {\n        Field = \"input_field\",\n        TargetField = \"url\",\n        KeepOriginal = true,\n        RemoveIfSuccessful = false,\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            parts.Apply(getIngestProcessorUriPartsResult =\u003e getIngestProcessorUriPartsResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tparts, err := elasticstack.GetIngestProcessorUriParts(ctx, \u0026elasticstack.GetIngestProcessorUriPartsArgs{\n\t\t\tField:              \"input_field\",\n\t\t\tTargetField:        pulumi.StringRef(\"url\"),\n\t\t\tKeepOriginal:       pulumi.BoolRef(true),\n\t\t\tRemoveIfSuccessful: pulumi.BoolRef(false),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(parts.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorUriPartsArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var parts = ElasticstackFunctions.getIngestProcessorUriParts(GetIngestProcessorUriPartsArgs.builder()\n            .field(\"input_field\")\n            .targetField(\"url\")\n            .keepOriginal(true)\n            .removeIfSuccessful(false)\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(parts.applyValue(getIngestProcessorUriPartsResult -\u003e getIngestProcessorUriPartsResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${parts.json}\nvariables:\n  parts:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorUriParts\n      Arguments:\n        field: input_field\n        targetField: url\n        keepOriginal: true\n        removeIfSuccessful: false\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorUriParts.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "Field containing the URI string.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "keepOriginal": {
                        "type": "boolean",
                        "description": "If true, the processor copies the unparsed URI to `\u003ctarget_field\u003e.original.`\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "removeIfSuccessful": {
                        "type": "boolean",
                        "description": "If `true`, the processor removes the `field` after parsing the URI string. If parsing fails, the processor does not remove the `field`.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Output field for the URI object.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorUriParts.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "Field containing the URI string.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "keepOriginal": {
                        "type": "boolean",
                        "description": "If true, the processor copies the unparsed URI to `\u003ctarget_field\u003e.original.`\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "removeIfSuccessful": {
                        "type": "boolean",
                        "description": "If `true`, the processor removes the `field` after parsing the URI string. If parsing fails, the processor does not remove the `field`.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "Output field for the URI object.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorUrldecode:getIngestProcessorUrldecode": {
            "description": "URL-decodes a string. If the field is an array of strings, all members of the array will be decoded.\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/urldecode-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst urldecode = elasticstack.getIngestProcessorUrldecode({\n    field: \"my_url_to_decode\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [urldecode.then(urldecode =\u003e urldecode.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nurldecode = elasticstack.get_ingest_processor_urldecode(field=\"my_url_to_decode\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[urldecode.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var urldecode = Elasticstack.GetIngestProcessorUrldecode.Invoke(new()\n    {\n        Field = \"my_url_to_decode\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            urldecode.Apply(getIngestProcessorUrldecodeResult =\u003e getIngestProcessorUrldecodeResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\turldecode, err := elasticstack.GetIngestProcessorUrldecode(ctx, \u0026elasticstack.GetIngestProcessorUrldecodeArgs{\n\t\t\tField: \"my_url_to_decode\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(urldecode.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorUrldecodeArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var urldecode = ElasticstackFunctions.getIngestProcessorUrldecode(GetIngestProcessorUrldecodeArgs.builder()\n            .field(\"my_url_to_decode\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(urldecode.applyValue(getIngestProcessorUrldecodeResult -\u003e getIngestProcessorUrldecodeResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${urldecode.json}\nvariables:\n  urldecode:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorUrldecode\n      Arguments:\n        field: my_url_to_decode\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorUrldecode.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to decode\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorUrldecode.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the processor.\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field to decode\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "if": {
                        "type": "string",
                        "description": "Conditionally execute the processor\n"
                    },
                    "ignoreFailure": {
                        "type": "boolean",
                        "description": "Ignore failures for the processor.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Handle failures for the processor.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Identifier for the processor.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field to assign the converted value to, by default `field` is updated in-place.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getIngestProcessorUserAgent:getIngestProcessorUserAgent": {
            "description": "The `user_agent` processor extracts details from the user agent string a browser sends with its web requests. This processor adds this information by default under the `user_agent` field.\n\nThe ingest-user-agent module ships by default with the regexes.yaml made available by uap-java with an Apache 2.0 license. For more details see https://github.com/ua-parser/uap-core.\n\n\nSee: https://www.elastic.co/guide/en/elasticsearch/reference/current/user-agent-processor.html\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst agent = elasticstack.getIngestProcessorUserAgent({\n    field: \"agent\",\n});\nconst myIngestPipeline = new elasticstack.IngestPipeline(\"myIngestPipeline\", {processors: [agent.then(agent =\u003e agent.json)]});\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nagent = elasticstack.get_ingest_processor_user_agent(field=\"agent\")\nmy_ingest_pipeline = elasticstack.IngestPipeline(\"myIngestPipeline\", processors=[agent.json])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var agent = Elasticstack.GetIngestProcessorUserAgent.Invoke(new()\n    {\n        Field = \"agent\",\n    });\n\n    var myIngestPipeline = new Elasticstack.IngestPipeline(\"myIngestPipeline\", new()\n    {\n        Processors = new[]\n        {\n            agent.Apply(getIngestProcessorUserAgentResult =\u003e getIngestProcessorUserAgentResult.Json),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tagent, err := elasticstack.GetIngestProcessorUserAgent(ctx, \u0026elasticstack.GetIngestProcessorUserAgentArgs{\n\t\t\tField: \"agent\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = elasticstack.NewIngestPipeline(ctx, \"myIngestPipeline\", \u0026elasticstack.IngestPipelineArgs{\n\t\t\tProcessors: pulumi.StringArray{\n\t\t\t\t*pulumi.String(agent.Json),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetIngestProcessorUserAgentArgs;\nimport com.pulumi.elasticstack.IngestPipeline;\nimport com.pulumi.elasticstack.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var agent = ElasticstackFunctions.getIngestProcessorUserAgent(GetIngestProcessorUserAgentArgs.builder()\n            .field(\"agent\")\n            .build());\n\n        var myIngestPipeline = new IngestPipeline(\"myIngestPipeline\", IngestPipelineArgs.builder()        \n            .processors(agent.applyValue(getIngestProcessorUserAgentResult -\u003e getIngestProcessorUserAgentResult.json()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myIngestPipeline:\n    type: elasticstack:IngestPipeline\n    properties:\n      processors:\n        - ${agent.json}\nvariables:\n  agent:\n    fn::invoke:\n      Function: elasticstack:getIngestProcessorUserAgent\n      Arguments:\n        field: agent\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getIngestProcessorUserAgent.\n",
                "properties": {
                    "extractDeviceType": {
                        "type": "boolean",
                        "description": "Extracts device type from the user agent string on a best-effort basis. Supported only starting from Elasticsearch version **8.0**\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field containing the user agent string.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "properties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Controls what properties are added to `target_field`.\n"
                    },
                    "regexFile": {
                        "type": "string",
                        "description": "The name of the file in the `config/ingest-user-agent` directory containing the regular expressions for parsing the user agent string.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field that will be filled with the user agent details.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIngestProcessorUserAgent.\n",
                "properties": {
                    "extractDeviceType": {
                        "type": "boolean",
                        "description": "Extracts device type from the user agent string on a best-effort basis. Supported only starting from Elasticsearch version **8.0**\n"
                    },
                    "field": {
                        "type": "string",
                        "description": "The field containing the user agent string.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource.\n"
                    },
                    "ignoreMissing": {
                        "type": "boolean",
                        "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.\n"
                    },
                    "json": {
                        "type": "string",
                        "description": "JSON representation of this data source.\n"
                    },
                    "properties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Controls what properties are added to `target_field`.\n"
                    },
                    "regexFile": {
                        "type": "string",
                        "description": "The name of the file in the `config/ingest-user-agent` directory containing the regular expressions for parsing the user agent string.\n"
                    },
                    "targetField": {
                        "type": "string",
                        "description": "The field that will be filled with the user agent details.\n"
                    }
                },
                "type": "object",
                "required": [
                    "field",
                    "id",
                    "json"
                ]
            }
        },
        "elasticstack:index/getSecurityRole:getSecurityRole": {
            "description": "Use this data source to get information about an existing Elasticsearch role. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst roleSecurityRole = elasticstack.getSecurityRole({\n    name: \"testrole\",\n});\nexport const role = roleSecurityRole.then(roleSecurityRole =\u003e roleSecurityRole.name);\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nrole_security_role = elasticstack.get_security_role(name=\"testrole\")\npulumi.export(\"role\", role_security_role.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var roleSecurityRole = Elasticstack.GetSecurityRole.Invoke(new()\n    {\n        Name = \"testrole\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"role\"] = roleSecurityRole.Apply(getSecurityRoleResult =\u003e getSecurityRoleResult.Name),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\troleSecurityRole, err := elasticstack.LookupSecurityRole(ctx, \u0026elasticstack.LookupSecurityRoleArgs{\n\t\t\tName: \"testrole\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"role\", roleSecurityRole.Name)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetSecurityRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var roleSecurityRole = ElasticstackFunctions.getSecurityRole(GetSecurityRoleArgs.builder()\n            .name(\"testrole\")\n            .build());\n\n        ctx.export(\"role\", roleSecurityRole.applyValue(getSecurityRoleResult -\u003e getSecurityRoleResult.name()));\n    }\n}\n```\n```yaml\nvariables:\n  roleSecurityRole:\n    fn::invoke:\n      Function: elasticstack:getSecurityRole\n      Arguments:\n        name: testrole\noutputs:\n  role: ${roleSecurityRole.name}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getSecurityRole.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/getSecurityRoleElasticsearchConnection:getSecurityRoleElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "runAs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of users that the owners of this role can impersonate.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecurityRole.\n",
                "properties": {
                    "applications": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/getSecurityRoleApplication:getSecurityRoleApplication"
                        },
                        "description": "A list of application privilege entries.\n"
                    },
                    "clusters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of cluster privileges. These privileges define the cluster level actions that users with this role are able to execute.\n"
                    },
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/getSecurityRoleElasticsearchConnection:getSecurityRoleElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "global": {
                        "type": "string",
                        "description": "An object defining global privileges.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "indices": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/getSecurityRoleIndex:getSecurityRoleIndex"
                        },
                        "description": "A list of indices permissions entries.\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Optional meta-data.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "runAs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of users that the owners of this role can impersonate.\n"
                    }
                },
                "type": "object",
                "required": [
                    "applications",
                    "clusters",
                    "global",
                    "id",
                    "indices",
                    "metadata",
                    "name"
                ]
            }
        },
        "elasticstack:index/getSecurityRoleMapping:getSecurityRoleMapping": {
            "description": "Retrieves role mappings. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role-mapping.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst mapping = elasticstack.getSecurityRoleMapping({\n    name: \"my_mapping\",\n});\nexport const user = mapping.then(mapping =\u003e mapping.name);\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nmapping = elasticstack.get_security_role_mapping(name=\"my_mapping\")\npulumi.export(\"user\", mapping.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mapping = Elasticstack.GetSecurityRoleMapping.Invoke(new()\n    {\n        Name = \"my_mapping\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"user\"] = mapping.Apply(getSecurityRoleMappingResult =\u003e getSecurityRoleMappingResult.Name),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmapping, err := elasticstack.LookupSecurityRoleMapping(ctx, \u0026elasticstack.LookupSecurityRoleMappingArgs{\n\t\t\tName: \"my_mapping\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"user\", mapping.Name)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetSecurityRoleMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var mapping = ElasticstackFunctions.getSecurityRoleMapping(GetSecurityRoleMappingArgs.builder()\n            .name(\"my_mapping\")\n            .build());\n\n        ctx.export(\"user\", mapping.applyValue(getSecurityRoleMappingResult -\u003e getSecurityRoleMappingResult.name()));\n    }\n}\n```\n```yaml\nvariables:\n  mapping:\n    fn::invoke:\n      Function: elasticstack:getSecurityRoleMapping\n      Arguments:\n        name: my_mapping\noutputs:\n  user: ${mapping.name}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getSecurityRoleMapping.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/getSecurityRoleMappingElasticsearchConnection:getSecurityRoleMappingElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The distinct name that identifies the role mapping, used solely as an identifier.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecurityRoleMapping.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/getSecurityRoleMappingElasticsearchConnection:getSecurityRoleMappingElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Mappings that have `enabled` set to `false` are ignored when role mapping is performed.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Additional metadata that helps define which roles are assigned to each user. Keys beginning with `_` are reserved for system usage.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The distinct name that identifies the role mapping, used solely as an identifier.\n"
                    },
                    "roleTemplates": {
                        "type": "string",
                        "description": "A list of mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of role names that are granted to the users that match the role mapping rules.\n"
                    },
                    "rules": {
                        "type": "string",
                        "description": "The rules that determine which users should be matched by the mapping. A rule is a logical condition that is expressed by using a JSON DSL.\n"
                    }
                },
                "type": "object",
                "required": [
                    "enabled",
                    "id",
                    "metadata",
                    "name",
                    "roleTemplates",
                    "roles",
                    "rules"
                ]
            }
        },
        "elasticstack:index/getSecurityUser:getSecurityUser": {
            "description": "Use this data source to get information about existing Elasticsearch user. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user.html\".\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as elasticstack from \"@pulumi/elasticstack\";\n\nconst userSecurityUser = elasticstack.getSecurityUser({\n    username: \"elastic\",\n});\nexport const user = userSecurityUser;\n```\n```python\nimport pulumi\nimport pulumi_elasticstack as elasticstack\n\nuser_security_user = elasticstack.get_security_user(username=\"elastic\")\npulumi.export(\"user\", user_security_user)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Elasticstack = Pulumi.Elasticstack;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var userSecurityUser = Elasticstack.GetSecurityUser.Invoke(new()\n    {\n        Username = \"elastic\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"user\"] = userSecurityUser.Apply(getSecurityUserResult =\u003e getSecurityUserResult),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/zlepper/pulumi-elasticstack/sdk/go/elasticstack\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuserSecurityUser, err := elasticstack.LookupSecurityUser(ctx, \u0026elasticstack.LookupSecurityUserArgs{\n\t\t\tUsername: \"elastic\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"user\", userSecurityUser)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.elasticstack.ElasticstackFunctions;\nimport com.pulumi.elasticstack.inputs.GetSecurityUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var userSecurityUser = ElasticstackFunctions.getSecurityUser(GetSecurityUserArgs.builder()\n            .username(\"elastic\")\n            .build());\n\n        ctx.export(\"user\", userSecurityUser.applyValue(getSecurityUserResult -\u003e getSecurityUserResult));\n    }\n}\n```\n```yaml\nvariables:\n  userSecurityUser:\n    fn::invoke:\n      Function: elasticstack:getSecurityUser\n      Arguments:\n        username: elastic\noutputs:\n  user: ${userSecurityUser}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getSecurityUser.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/getSecurityUserElasticsearchConnection:getSecurityUserElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "An identifier for the user\n"
                    }
                },
                "type": "object",
                "required": [
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSecurityUser.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/getSecurityUserElasticsearchConnection:getSecurityUserElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The email of the user.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies whether the user is enabled. The default value is true.\n"
                    },
                    "fullName": {
                        "type": "string",
                        "description": "The full name of the user.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "metadata": {
                        "type": "string",
                        "description": "Arbitrary metadata that you want to associate with the user.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of roles the user has. The roles determine the users access permissions. Default is [].\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "An identifier for the user\n"
                    }
                },
                "type": "object",
                "required": [
                    "email",
                    "enabled",
                    "fullName",
                    "id",
                    "metadata",
                    "roles",
                    "username"
                ]
            }
        },
        "elasticstack:index/getSnapshotRepository:getSnapshotRepository": {
            "description": "This data source provides the information about the registered snaphosts repositories\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSnapshotRepository.\n",
                "properties": {
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/getSnapshotRepositoryElasticsearchConnection:getSnapshotRepositoryElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the snapshot repository.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSnapshotRepository.\n",
                "properties": {
                    "azures": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/getSnapshotRepositoryAzure:getSnapshotRepositoryAzure"
                        },
                        "description": "Azure Blob storage as a repository. Set only if the type of the fetched repo is `azure`.\n"
                    },
                    "elasticsearchConnection": {
                        "$ref": "#/types/elasticstack:index/getSnapshotRepositoryElasticsearchConnection:getSnapshotRepositoryElasticsearchConnection",
                        "description": "Elasticsearch connection configuration block.\n"
                    },
                    "fs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/getSnapshotRepositoryF:getSnapshotRepositoryF"
                        },
                        "description": "Shared filesystem repository. Set only if the type of the fetched repo is `fs`.\n"
                    },
                    "gcs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/getSnapshotRepositoryGc:getSnapshotRepositoryGc"
                        },
                        "description": "Google Cloud Storage service as a repository. Set only if the type of the fetched repo is `gcs`.\n"
                    },
                    "hdfs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/getSnapshotRepositoryHdf:getSnapshotRepositoryHdf"
                        },
                        "description": "HDFS File System as a repository. Set only if the type of the fetched repo is `hdfs`.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Internal identifier of the resource\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the snapshot repository.\n"
                    },
                    "s3s": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/getSnapshotRepositoryS3:getSnapshotRepositoryS3"
                        },
                        "description": "AWS S3 as a repository. Set only if the type of the fetched repo is `s3`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Repository type.\n"
                    },
                    "urls": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/elasticstack:index/getSnapshotRepositoryUrl:getSnapshotRepositoryUrl"
                        },
                        "description": "URL repository. Set only if the type of the fetched repo is `url`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "azures",
                    "fs",
                    "gcs",
                    "hdfs",
                    "id",
                    "name",
                    "s3s",
                    "type",
                    "urls"
                ]
            }
        }
    }
}